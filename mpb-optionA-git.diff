diff --git a/MagicPedalboardNew.sc b/MagicPedalboardNew.sc
--- a/MagicPedalboardNew.sc
+++ b/MagicPedalboardNew.sc
@@ -1,7 +1,6 @@
-/* MagicPedalboardNew.sc v0.4.3
+/* MagicPedalboardNew.sc v0.4.3
  A/B pedalboard chain manager built on Ndefs.
  - Chains are Arrays of Symbols ordered [sink, …, source].
- - Uses JITLib embedding: Ndef(left) <<> Ndef(right).
  - Creates two sinks: \chainA and \chainB, and plays the current chain on init.
  - Most mutators act on the next chain; explicit current-chain bypass helpers are provided.
  - Optional display adaptor (MagicDisplay / MagicDisplayGUI) receives notifications, including detailed chain views.
@@ -331,6 +330,39 @@
         serverIsRunning = Server.default.serverRunning;
         ^serverIsRunning
     }
+
+    // MagicPedalboardNew.sc
+    // v0.4.3-p1
+    // MD 20250917-1010
+    //
+    // Purpose: Class-level exclusivity helper (Option A) — silence NEXT at the sink source
+    //          and keep CURRENT robust+playing. Deterministic against monitor tails/races.
+    // Style:   tilde vars, var-first, lowercase names, no server.sync,
+    //          server ops inside Server.default.bind.
+    enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
+        var currentSink, nextSink, chans, fadeCur;
+        currentSink = currentChain[0];
+        nextSink = nextChain[0];
+        chans = defaultNumChannels;
+        fadeCur = fadeCurrent.clip(0.05, 0.2);
+
+        Server.default.bind({
+            // CURRENT: robust sink consumes embedded input; ensure playing
+            Ndef(currentSink, { \in.ar(chans) });
+            Ndef(currentSink).ar(chans);
+            Ndef(currentSink).fadeTime_(fadeCur);
+            if (Ndef(currentSink).isPlaying.not) {
+                Ndef(currentSink).play(numChannels: chans)
+            };
+
+            // NEXT: hard silence at sink source; stop its monitor
+            Ndef(nextSink, { Silent.ar(chans) });
+            Ndef(nextSink).ar(chans);
+            Ndef(nextSink).fadeTime_(0.01);
+            Ndef(nextSink).stop;
+        });
+
+        ^this
+    }
 
     effectiveListForInternal { arg listRef;
         var dict, resultList, lastIndex, isProcessor, isBypassed;
@@ -404,6 +436,8 @@
             this.rebuildUnbound(nextChain);
             this.rebuildUnbound(currentChain);
         });
+        // enforce exclusive invariant (Option A): CURRENT audible; NEXT silent
+        this.enforceExclusiveCurrentOptionA(0.1);
 
         if(display.notNil) { display.showReset(currentChain, nextChain) };
     }
@@ -346,6 +380,7 @@
     switchChain { arg fadeTime = 0.1;
         var temporaryList, oldSinkKey, newSinkKey, actualFadeTime, canRun;
         canRun = this.ensureServerTree;
+        // (guard preserved)
         if(canRun.not) { ^this };
         actualFadeTime = fadeTime.clip(0.08, 0.2);
         oldSinkKey = currentChain[0];
@@ -364,6 +399,8 @@
             // ensure both chains are in correct post-swap state
             this.rebuildUnbound(currentChain);
             this.rebuildUnbound(nextChain);
         });
+        // enforce exclusivity post-swap (CURRENT uses actualFadeTime, NEXT silenced)
+        this.enforceExclusiveCurrentOptionA(actualFadeTime);
 
         if(display.notNil) {
             display.showSwitch(oldSinkKey, currentChain[0], currentChain, nextChain);

