/* MagicDisplay.sc  v0.1.1
   Console display adaptor for MagicPedalboardNew.
   Prints structured messages now; later you can subclass with a real GUI.
   // MD 20250912-1345
*/

MagicDisplay : Object {

    classvar < version;

    var < logLevel;  // 0 = silent, 1 = normal, 2 = verbose

    *initClass {
        version = "v0.1.1";
        ("MagicDisplay " ++ version).postln;
    }

    *new { |level = 1|
        ^super.new.init(level)
    }

    init { |level|
        var initialLevel;
        initialLevel = level ? 1;
        logLevel = initialLevel;
        ^this
    }

    help {
        var text;
        text = "MagicDisplay " ++ version
        ++ "\nMethods:\n"
        ++ "  showInit(pedalboard, versionString, current, next)\n"
        ++ "  showRebuild(which, fullChain, effective)\n"
        ++ "  showPlay(sink), showStop(sink), showSwitch(oldSink, newSink, current, next)\n"
        ++ "  showMutation(action, args, nextChain)\n"
        ++ "  showBypass(which, key, state, chain, bypassKeys)\n"
        ++ "  showReset(current, next), showChains(current, next, bypassA, bypassB)\n"
        ++ "  showChainsDetailed(current, next, bypassA, bypassB, effCurrent, effNext)\n"
        ++ "  showError(message)\n";
        text.postln;
    }

    showInit { |pedalboard, versionString, current, next|
        if(logLevel > 0) { ("[MPB:init] " ++ versionString ++ "  current=" ++ current ++ "  next=" ++ next).postln };
    }

    showRebuild { |which, fullChain, effective|
        if(logLevel > 0) { ("[MPB:rebuild:" ++ which ++ "] full=" ++ fullChain ++ "  effective=" ++ effective).postln };
    }

    showPlay { |sinkKey|
        if(logLevel > 0) { ("[MPB:play] sink=" ++ sinkKey).postln };
    }

    showStop { |sinkKey|
        if(logLevel > 0) { ("[MPB:stop] sink=" ++ sinkKey).postln };
    }

    showSwitch { |oldSink, newSink, current, next|
        if(logLevel > 0) {
            ("[MPB:switch] " ++ oldSink ++ " â†’ " ++ newSink
                ++ "  current=" ++ current ++ "  next=" ++ next).postln;
        };
    }

    showMutation { |action, args, nextChain|
        if(logLevel > 0) { ("[MPB:mutate] " ++ action ++ " " ++ args ++ "  next=" ++ nextChain).postln };
    }

    showBypass { |which, key, state, chain, bypassKeys|
        if(logLevel > 0) {
            ("[MPB:bypass:" ++ which ++ "] " ++ key ++ " -> " ++ state
                ++ "  chain=" ++ chain ++ "  activeBypass=" ++ bypassKeys).postln;
        };
    }

    showReset { |current, next|
        if(logLevel > 0) { ("[MPB:reset] current=" ++ current ++ "  next=" ++ next).postln };
    }

    showChains { |current, next, bypassAKeys, bypassBKeys|
        if(logLevel > 0) {
            "MagicPedalboardNew.printChains:".postln;
            ("A: " ++ current ++ "   bypassA: " ++ bypassAKeys).postln;
            ("B: " ++ next    ++ "   bypassB: " ++ bypassBKeys).postln;
        };
    }

    showChainsDetailed { |current, next, bypassAKeys, bypassBKeys, effCurrent, effNext|
        var header, formatOne;

        if(logLevel <= 0) { ^this };

        header = { |titleString| ("==== " ++ titleString ++ " ====").postln };

        formatOne = { |titleString, listRef, bypassKeys, effective|
            var sinkKey, sourceKey, lastIndex, indexCounter, lineText;

            lastIndex = listRef.size - 1;
            sinkKey = listRef[0];
            sourceKey = listRef[lastIndex];

            header.(titleString);
            ("sink : " ++ sinkKey).postln;

            indexCounter = 1;
            if(listRef.size > 2) {
                "procs:".postln;
                listRef.copyRange(1, lastIndex - 1).do { |procKey|
                    var isBypassed, mark;
                    isBypassed = bypassKeys.includes(procKey);
                    mark = if(isBypassed) { "BYP" } { "ON " };
                    lineText = ("  [" ++ indexCounter ++ "] " ++ procKey ++ "  (" ++ mark ++ ")");
                    lineText.postln;
                    indexCounter = indexCounter + 1;
                };
            }{
                "procs: (none)".postln;
            };

            ("src  : " ++ sourceKey).postln;
            ("eff  : " ++ effective.join("  ->  ")).postln;
            "".postln;
        };

        formatOne.("CURRENT", current, bypassAKeys, effCurrent);
        formatOne.("NEXT",    next,    bypassBKeys, effNext);
    }

    showError { |message|
        ("[MPB:error] " ++ message).warn;
    }
}
/*  MagicPedalboardNew.sc  v0.3.2
    A/B pedalboard chain manager built on Ndefs.
    - Chains are Arrays of Symbols ordered [sink, â€¦, source].
    - Uses JITLib embedding: Ndef(left) <<> Ndef(right).
    - Creates two sinks: \chainA and \chainB, and plays the current chain on init.
    - Most mutators act on the next chain; explicit current-chain bypass helpers are provided.
    - Optional display adaptor (MagicDisplay) receives notifications, including detailed chain views.
    // MD 20250912-1345
*/

MagicPedalboardNew : Object {

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // class metadata
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    classvar < version;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // instance state
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var < currentChain;      // read-only pointer
    var < nextChain;         // read-only pointer

    var chainAList;          // [\chainA, ...processors..., source]
    var chainBList;          // [\chainB, ...processors..., source]

    var bypassA;             // IdentityDictionary: key(Symbol) -> Bool
    var bypassB;             // IdentityDictionary: key(Symbol) -> Bool

    var < defaultNumChannels;
    var < defaultSource;

    // optional display adaptor (console now, GUI later)
    var < display;

    *initClass {
        version = "v0.3.2";
        ("MagicPedalboardNew " ++ version).postln;
    }

    *new { |disp = nil|
        ^super.new.init(disp)
    }

    init { |disp|
        var sinkFunc;

        display = disp;

        defaultNumChannels = 2;
        defaultSource = \ts0;

        sinkFunc = {
            var inputSignal;
            inputSignal = \in.ar(defaultNumChannels);
            inputSignal
        };

        Ndef(\chainA, sinkFunc);
        Ndef(\chainB, sinkFunc);

        chainAList = [\chainA, defaultSource];
        chainBList = [\chainB, defaultSource];

        bypassA = IdentityDictionary.new;
        bypassB = IdentityDictionary.new;

        currentChain = chainAList;
        nextChain = chainBList;

        // initial wiring + start
        this.rebuild(currentChain);
        this.rebuild(nextChain);
        Server.default.bind({ Ndef(\chainA).play(numChannels: defaultNumChannels) });

        if(display.notNil) {
            display.showInit(this, version, currentChain, nextChain);
        };

        ^this
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // public API
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    setDisplay { |disp|
        display = disp;
        if(display.notNil) {
            display.showInit(this, version, currentChain, nextChain);
        };
    }

    help {
        var text;
        text = String.new;
        text = text
        ++ "MagicPedalboardNew " ++ version ++ "\n"
        ++ "Chains are Arrays of Symbols ordered [sink, â€¦, source].\n"
        ++ "On init, creates \\chainA and \\chainB and plays current.\n\n"
        ++ "Core methods (operate mostly on the *next* chain):\n"
        ++ "  printChains\n"
        ++ "  playCurrent, stopCurrent, switchChain\n"
        ++ "  add(key), addAt(key, index)\n"
        ++ "  removeAt(index), swap(indexA, indexB)\n"
        ++ "  bypass(key, state=true), bypassAt(index, state=true)\n"
        ++ "  clearChain\n"
        ++ "Current-chain bypass helpers:\n"
        ++ "  bypassCurrent(key, state=true), bypassAtCurrent(index, state=true)\n"
        ++ "Diagnostics/helpers:\n"
        ++ "  effectiveCurrent, effectiveNext, bypassKeysCurrent, bypassKeysNext, reset\n"
        ++ "Source setters:\n"
        ++ "  setSource(key) [next], setSourceCurrent(key) [current]\n";
        text.postln;
    }

    // Detailed printing routed through display if available
    printChains {
        var bypassAKeys, bypassBKeys, effA, effB;

        bypassAKeys = this.bypassKeysForListInternal(chainAList);
        bypassBKeys = this.bypassKeysForListInternal(chainBList);

        effA = this.effectiveListForInternal(chainAList);
        effB = this.effectiveListForInternal(chainBList);

        if(display.notNil and: { display.respondsTo(\showChainsDetailed) }) {
            display.showChainsDetailed(
                chainAList, chainBList,
                bypassAKeys, bypassBKeys,
                effA, effB
            );
        }{
            "â€” Chains â€”".postln;
            "MagicPedalboardNew.printChains:".postln;
            ("A: " ++ chainAList ++ (if(chainAList === currentChain) { "  (current)" } { "  (next)" })).postln;
            ("   bypassA: " ++ bypassAKeys).postln;
            ("   effA:    " ++ effA).postln;
            ("B: " ++ chainBList ++ (if(chainBList === currentChain) { "  (current)" } { "  (next)" })).postln;
            ("   bypassB: " ++ bypassBKeys).postln;
            ("   effB:    " ++ effB).postln;
            "".postln;
        };
    }

    playCurrent {
        var sinkKey;
        sinkKey = currentChain[0];
        this.rebuild(currentChain);
        Server.default.bind({ Ndef(sinkKey).play(numChannels: defaultNumChannels) });
        if(display.notNil) { display.showPlay(sinkKey) };
    }

    stopCurrent {
        var sinkKey;
        sinkKey = currentChain[0];
        Server.default.bind({ Ndef(sinkKey).stop });
        if(display.notNil) { display.showStop(sinkKey) };
    }

    switchChain {
        var tempChainRef, oldSinkKey, newSinkKey;

        oldSinkKey = currentChain[0];

        Server.default.bind({
            // stop old current sink
            Ndef(oldSinkKey).stop;

            // swap pointers
            tempChainRef = currentChain;
            currentChain = nextChain;
            nextChain = tempChainRef;

            // rebuild both without nesting binds
            this.rebuildUnbound(nextChain);
            this.rebuildUnbound(currentChain);

            // start new current sink
            newSinkKey = currentChain[0];
            Ndef(newSinkKey).play(numChannels: defaultNumChannels);
        });

        if(display.notNil) {
            display.showSwitch(oldSinkKey, currentChain[0], currentChain, nextChain);
        };
    }

    // ---- next-chain mutations ------------------------------------------------

    add { | key |
        var insertIndex;
        insertIndex = nextChain.size - 1;
        this.addAt(key, insertIndex);
        if(display.notNil) { display.showMutation(\add, [key], nextChain) };
    }

    addAt { | key, index |
        var indexClamped, newList;
        indexClamped = index.clip(1, nextChain.size - 1);
        newList = nextChain.insert(indexClamped, key);
        this.setNextListInternal(newList);
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\addAt, [key, indexClamped], nextChain) };
    }

    removeAt { | index |
        var sizeNow, lastIndex, newList, removedKey;

        sizeNow = nextChain.size;
        lastIndex = sizeNow - 1;

        if(sizeNow <= 2) {
            if(display.notNil) { display.showError("removeAt refused: need at least [sink, source]") }
            { "refuse to remove: need at least [sink, source]".postln };
        }{
            if((index == 0) or: { index == lastIndex }) {
                if(display.notNil) { display.showError("removeAt refused: cannot remove sink or source") }
                { "refuse to remove sink or source".postln };
            }{
                removedKey = nextChain[index];
                newList = nextChain.copy;
                newList.removeAt(index);
                this.setNextListInternal(newList);
                this.bypassDictForListInternal(nextChain).removeAt(removedKey);
                this.rebuild(nextChain);
                if(display.notNil) { display.showMutation(\removeAt, [index, removedKey], nextChain) };
            }
        }
    }

    swap { | indexAParam, indexBParam |
        var lastIndex, indexA, indexB, newList, tempKey;

        lastIndex = nextChain.size - 1;

        indexA = indexAParam.clip(1, lastIndex - 1);
        indexB = indexBParam.clip(1, lastIndex - 1);

        if(indexA == indexB) {
            // nothing to do
        }{
            newList = nextChain.copy;
            tempKey = newList[indexA];
            newList[indexA] = newList[indexB];
            newList[indexB] = tempKey;
            this.setNextListInternal(newList);
            this.rebuild(nextChain);
            if(display.notNil) { display.showMutation(\swap, [indexA, indexB], nextChain) };
        }
    }

    clearChain {
        var sinkKey, sourceKey, newList;

        if(nextChain.size < 2) { ^this };

        sinkKey = nextChain[0];
        sourceKey = nextChain[nextChain.size - 1];

        newList = [sinkKey, sourceKey];
        this.setNextListInternal(newList);
        this.bypassDictForListInternal(nextChain).clear;
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\clearChain, [], nextChain) };
    }

    bypass { | key, state = true |
        var dict;
        dict = this.bypassDictForListInternal(nextChain);
        dict[key] = state;
        this.rebuild(nextChain);
        if(display.notNil) {
            display.showBypass(\next, key, state, nextChain, this.bypassKeysForListInternal(nextChain));
        };
    }

    bypassAt { | index, state = true |
        var lastIndex, clampedIndex, keyAtIndex;
        lastIndex = nextChain.size - 1;
        clampedIndex = index.clip(1, lastIndex - 1);
        keyAtIndex = nextChain[clampedIndex];
        this.bypass(keyAtIndex, state);
    }

    // ---- current-chain bypass ------------------------------------------------

    bypassCurrent { | key, state = true |
        var dict;
        dict = this.bypassDictForListInternal(currentChain);
        dict[key] = state;
        this.rebuild(currentChain);
        if(display.notNil) {
            display.showBypass(\current, key, state, currentChain, this.bypassKeysForListInternal(currentChain));
        };
    }

    bypassAtCurrent { | index, state = true |
        var lastIndex, clampedIndex, keyAtIndex;
        lastIndex = currentChain.size - 1;
        clampedIndex = index.clip(1, lastIndex - 1);
        keyAtIndex = currentChain[clampedIndex];
        this.bypassCurrent(keyAtIndex, state);
    }

    // ---- source setters (built-in) ------------------------------------------

    setSource { | key |
        var newList, lastIndex;
        lastIndex = nextChain.size - 1;
        newList = nextChain.copy;
        newList[lastIndex] = key;
        this.setNextListInternal(newList);
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\setSource, [key], nextChain) };
    }

    setSourceCurrent { | key |
        var newList, lastIndex;
        lastIndex = currentChain.size - 1;
        newList = currentChain.copy;
        newList[lastIndex] = key;
        if(currentChain === chainAList) {
            chainAList = newList; currentChain = chainAList;
        }{
            chainBList = newList; currentChain = chainBList;
        };
        this.rebuild(currentChain);
        if(display.notNil) { display.showMutation(\setSourceCurrent, [key], currentChain) };
    }

    // ---- diagnostics helpers -------------------------------------------------

    effectiveCurrent { ^this.effectiveListForInternal(currentChain) }
    effectiveNext    { ^this.effectiveListForInternal(nextChain) }
    bypassKeysCurrent { ^this.bypassKeysForListInternal(currentChain) }
    bypassKeysNext    { ^this.bypassKeysForListInternal(nextChain) }

    reset {
        var sinkAKey, sinkBKey;

        sinkAKey = \chainA;
        sinkBKey = \chainB;

        chainAList = [sinkAKey, defaultSource];
        chainBList = [sinkBKey, defaultSource];

        bypassA.clear;
        bypassB.clear;

        currentChain = chainAList;
        nextChain = chainBList;

        Server.default.bind({
            this.rebuildUnbound(nextChain);
            this.rebuildUnbound(currentChain);
            Ndef(sinkBKey).stop;
            Ndef(sinkAKey).play(numChannels: defaultNumChannels);
        });

        if(display.notNil) { display.showReset(currentChain, nextChain) };
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // internal helpers (lowercase, no leading underscore)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    setNextListInternal { | newList |
        if(nextChain === chainAList) {
            chainAList = newList; nextChain = chainAList;
        }{
            chainBList = newList; nextChain = chainBList;
        }
    }

    bypassDictForListInternal { | listRef |
        ^if(listRef === chainAList) { bypassA } { bypassB }
    }

    bypassKeysForListInternal { | listRef |
        var dict, keysBypassed;

        dict = this.bypassDictForListInternal(listRef);
        keysBypassed = Array.new;

        dict.keysValuesDo { |key, state|
            if(state == true) { keysBypassed = keysBypassed.add(key) };
        };

        ^keysBypassed
    }

    ensureStereoInternal { | key |
        var proxyBus;
        proxyBus = Ndef(key).bus;
        if(proxyBus.isNil or: { proxyBus.rate != \audio } or: { proxyBus.numChannels != defaultNumChannels }) {
            Ndef(key).ar(defaultNumChannels);
        };
    }

    ensureServerTree {
        if(Server.default.serverRunning) {
            Server.default.initTree;
        };
    }

    effectiveListForInternal { | listRef |
        var dict, resultList, lastIndex;

        dict = this.bypassDictForListInternal(listRef);
        resultList = Array.new;
        lastIndex = listRef.size - 1;

        listRef.do { |key, indexPosition|
            var isProcessor, isBypassed;
            isProcessor = (indexPosition > 0) and: (indexPosition < lastIndex);
            isBypassed = isProcessor and: { dict[key] == true };
            if((indexPosition == 0) or: { indexPosition == lastIndex }) {
                resultList = resultList.add(key);
            }{
                if(isBypassed.not) { resultList = resultList.add(key) };
            };
        };

        ^resultList
    }

    // Public rebuild: bundles server ops
    rebuild { | listRef |
        var whichChain;
        whichChain = if(listRef === currentChain) { \current } { \next };

        Server.default.bind({
            this.rebuildUnbound(listRef);
        });

        if(display.notNil) {
            display.showRebuild(whichChain, listRef, this.effectiveListForInternal(listRef));
        };
    }

    // Internal rebuild that assumes we are already inside a server bind
    rebuildUnbound { | listRef |
        var effective, indexCounter, leftKey, rightKey, sinkKey;

        if(listRef.size < 2) { ^this };

        this.ensureServerTree;

        effective = this.effectiveListForInternal(listRef);

        effective.do { |keySymbol|
            this.ensureStereoInternal(keySymbol)
        };

        indexCounter = 0;
        while { indexCounter < (effective.size - 1) } {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        };

        sinkKey = effective[0];

        if(listRef === currentChain) {
            Ndef(sinkKey).play(numChannels: defaultNumChannels);
        }{
            Ndef(sinkKey).stop;
        };
    }
}

// Simple sources / processors (stereo)
Ndef(\ts0, { Silent.ar(2) });
Ndef(\tsSaw, { Saw.ar(200, 0.12) ! 2 });
Ndef(\tsDust, { Dust.ar(2000) ! 2 });

Ndef(\tremolo, { |rate = 5, depth = 0.8|
    var inSig = \in.ar(2);
    inSig * SinOsc.kr(rate).range(1 - depth, 1)
});

// Create display + pedalboard
d = MagicDisplay.new(1);          // verbose console
m = MagicPedalboardNew.new(d);    // pass display at construction
// Exercise a few actions
m.setSourceCurrent(\tsSaw);
m.add(\tremolo);
m.printChains;

m.switchChain;
m.setSource(\tsDust);
m.clearChain;
m.printChains;

m.stopCurrent;

// Test_MagicDisplay_wireup_v0_3.scd
// MD 20250911-1143


// Simple sources / processors (stereo)
Ndef(\ts0, { Silent.ar(2) });
Ndef(\tsSaw, { Saw.ar(200, 0.12) ! 2 });
Ndef(\tsDust, { Dust.ar(2000) ! 2 });

Ndef(\tremolo, { |rate = 5, depth = 0.8|
    var inSig = \in.ar(2);
    inSig * SinOsc.kr(rate).range(1 - depth, 1)
});

// Create display + pedalboard
d = MagicDisplay.new(1);          // verbose console
m = MagicPedalboardNew.new(d);    // pass display at construction
// Exercise a few actions
m.setSourceCurrent(\tsSaw);
m.add(\tremolo);
m.printChains;

m.switchChain;
m.setSource(\tsDust);
m.clearChain;
m.printChains;

m.stopCurrent;

/* Test_MagicPedalboardNew_v0_10_QA_PauseResume_Fixed.scd
   Interactive QA demo for MagicPedalboardNew v0.1.5
   - Two-step issue capture:
       [Report Issue (Pause)] -> type note -> [Submit Issue & Resume]  (or [Resume (No Issue)])
   - Routine runs on SystemClock; GUI updates are deferred to AppClock.
   - Robust against missing setSource / setSourceCurrent (uses fallbacks).
*/

(
var qaWindow, infoText, noteTextField, reportButton, submitButton, resumeButton, updateInfoFn;
var waitShortDur, waitMedDur;
var sayFn, countdownFn, showFn;
var snapshotFn, setActiveStepFn, pushStepFn, absorbPendingIssueForFn;
var requestPauseFn, waitIfPausedFn, submitIssueFn, resumeNoIssueFn;
var setCurrentSourceRobustFn, setNextSourceRobustFn;
var runRoutine;

var beforeDict, afterDict;     // used within the Routine
var activeStepId, activeStepTitle, activeStepExpected;

var pedalboard;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 0) Sources and processors (stereo; processors use \in)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ndef(\ts0,   { Silent.ar(2) });                      // silent baseline
Ndef(\tsDust,{ Dust.ar(2000) ! 2 });                 // irregular bursts
Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });             // bright saw
Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });       // steady sine

Ndef(\tremolo, { |rate = 4, depth = 0.9|
    var inputSignal, mod;
    inputSignal = \in.ar(2);
    mod = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * mod
});

Ndef(\lofi, { |bits = 4, rate = 4000|
    var inputSignal;
    inputSignal = \in.ar(2);
    Decimator.ar(inputSignal, rate, bits)
});

Ndef(\atten, { |gain = 0.25|
    var inputSignal;
    inputSignal = \in.ar(2) * gain;
    inputSignal
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1) Instantiate + reset
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pedalboard = MagicPedalboardNew.new;
pedalboard.reset; // canonical baseline

// Robust helpers for source setting (handle older class versions)
setCurrentSourceRobustFn = { |key|
    var hasSetter;
    hasSetter = pedalboard.respondsTo(\setSourceCurrent);
    if(hasSetter) {
        pedalboard.setSourceCurrent(key);
    }{
        // fallback: temporarily switch, set NEXT as current, switch back
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "ERROR: setSourceCurrent missing; cannot set current source.".warn;
        };
        pedalboard.switchChain;
    }
};

setNextSourceRobustFn = { |key|
    var hasSetter;
    hasSetter = pedalboard.respondsTo(\setSource);
    if(hasSetter) {
        pedalboard.setSource(key);
    }{
        // fallback: temporarily switch to make NEXT current, set current, switch back
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "ERROR: missing setSource and setSourceCurrent; cannot set next source.".warn;
        };
        pedalboard.switchChain;
    }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 2) QA state (no GUI calls here)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
~qa = (
    steps: Array.new,
    issues: Array.new,
    currentStep: nil,                  // after a step is pushed, points to that entry
    pendingIssues: IdentityDictionary.new,   // stepId -> (reason:, note:)
    pauseRequested: false,
    pauseCondition: Condition.new
);

snapshotFn = {
    (
        time: Main.elapsedTime,
        current: pedalboard.currentChain.copy,
        next: pedalboard.nextChain.copy,
        effCurrent: pedalboard.effectiveCurrent,
        effNext: pedalboard.effectiveNext,
        bypassCurrent: pedalboard.bypassKeysCurrent,
        bypassNext: pedalboard.bypassKeysNext
    )
};

setActiveStepFn = { |stepId, stepTitle, expectedText|
    activeStepId = stepId;
    activeStepTitle = stepTitle;
    activeStepExpected = expectedText;
    AppClock.sched(0, {
        infoText.string = "Step: % â€” %\nExpect: %".format(stepId, stepTitle, expectedText);
        qaWindow.name = "MPBNew QA â€“ two-step issue capture";
        nil
    });
};

pushStepFn = { |stepId, stepTitle, expectedText, beforeSnap, afterSnap|
    var entry;
    entry = (
        id: stepId,
        title: stepTitle,
        expected: expectedText,
        before: beforeSnap,
        after: afterSnap,
        userFlagged: false,
        userReason: nil,
        userNote: nil
    );
    ~qa.steps = ~qa.steps.add(entry);
    ~qa.currentStep = entry;
    absorbPendingIssueForFn.(stepId, entry);
};

absorbPendingIssueForFn = { |stepId, entry|
    var pending;
    pending = ~qa.pendingIssues[stepId];
    if(pending.notNil) {
        entry[\userFlagged] = true;
        entry[\userReason] = pending[\reason];
        entry[\userNote] = pending[\note];
        if(~qa.issues.includes(stepId).not) {
            ~qa.issues = ~qa.issues.add(stepId);
        };
        ~qa.pendingIssues.removeAt(stepId);
    };
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3) Pause / resume workflow
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
requestPauseFn = {
    ~qa.pauseRequested = true;
    AppClock.sched(0, {
        infoText.string = "PAUSED at % â€” %\nType your note, then Submit or Resume."
            .format(activeStepId ? "(unknown)", activeStepTitle ? "(unknown)");
        qaWindow.name = "MPBNew QA â€“ PAUSED";
        nil
    });
};

waitIfPausedFn = {
    // This is called inside the Routine (on SystemClock now).
    while { ~qa.pauseRequested } {
        ~qa.pauseCondition.wait; // signal comes from AppClock handlers (buttons/keys)
    };
};

submitIssueFn = {
    var noteText, reasonText, stepIdLocal;
    noteText = noteTextField.string;
    reasonText = "user report (paused)";
    stepIdLocal = activeStepId ? ("unknown-" ++ Main.elapsedTime.round(0.01));

    ~qa.pendingIssues[stepIdLocal] = (reason: reasonText, note: noteText);

    ("[QA] Issue captured for step %".format(stepIdLocal)).postln;
    if(noteText.notNil and: { noteText != "" }) { ("[QA] Note: " ++ noteText).postln };

    ~qa.pauseRequested = false;
    ~qa.pauseCondition.signal;

    AppClock.sched(0, {
        infoText.string = "Captured issue for step %.\nResumingâ€¦".format(stepIdLocal);
        qaWindow.name = "MPBNew QA â€“ two-step issue capture";
        nil
    });
};

resumeNoIssueFn = {
    ~qa.pauseRequested = false;
    ~qa.pauseCondition.signal;

    AppClock.sched(0, {
        infoText.string = "Resuming without logging an issueâ€¦";
        qaWindow.name = "MPBNew QA â€“ two-step issue capture";
        nil
    });
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4) Console helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sayFn = { |text|
    var msg;
    msg = text.asString;
    msg.postln;
};

countdownFn = { |seconds = 3|
    var remaining;
    remaining = seconds;
    while { remaining > 0 } {
        waitIfPausedFn.();             // allow pausing mid-countdown
        (remaining.asString ++ "...").postln;
        1.wait;                        // SystemClock wait
        remaining = remaining - 1;
    };
    waitIfPausedFn.();                 // pause again before executing the action
    "Now.".postln;
};

showFn = {
    "â€” Chains â€”".postln;
    pedalboard.printChains;
    "".postln;
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 5) QA UI (AppClock-safe GUI)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
qaWindow = Window("MPBNew QA â€“ two-step issue capture", Rect(100, 100, 640, 210)).front.alwaysOnTop_(true);
infoText = StaticText(qaWindow, Rect(10, 10, 620, 40)).string_("Step: (pending)");
noteTextField = TextField(qaWindow, Rect(10, 60, 620, 24)).string_("Type your note hereâ€¦");

// left: report (pause). middle: submit & resume. right: resume without logging.
reportButton = Button(qaWindow, Rect(10, 100, 200, 30))
    .states_([["Report Issue (Pause)", Color.white, Color.red]])
    .action_({ requestPauseFn.() });

submitButton = Button(qaWindow, Rect(220, 100, 200, 30))
    .states_([["Submit Issue & Resume", Color.white, Color(0, 0.5, 0)]])
    .action_({ submitIssueFn.() });

resumeButton = Button(qaWindow, Rect(430, 100, 200, 30))
    .states_([["Resume (No Issue)", Color.white, Color.gray]])
    .action_({ resumeNoIssueFn.() });

// keyboard: X pauses, Enter submits, Esc resumes without logging
qaWindow.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
    if(char == $x or: { char == $X }) { requestPauseFn.() };
    if(keycode == 36 or: { keycode == 52 }) { submitIssueFn.() }; // Enter / keypad Enter
    if(keycode == 53) { resumeNoIssueFn.() };                      // Esc
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 6) Narrated sequence (RUN ON SystemClock)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
waitShortDur = 1.8;
waitMedDur   = 3.0;

runRoutine = Routine({
    // A) Start silent on CURRENT
    setActiveStepFn.("A1", "Start silent \\\\ts0 on CURRENT", "Silence");
    sayFn.("Starting with a silent CURRENT chain: [\\chainA, \\ts0]. Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setCurrentSourceRobustFn.(\ts0);
    pedalboard.playCurrent;
    showFn.();
    sayFn.("You should hear nothing.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("A1", "silent on CURRENT", "You should hear nothing.", beforeDict, afterDict);

    // B) Change CURRENT source to Dust
    setActiveStepFn.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
    sayFn.("Change CURRENT source to Dust(2000). Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setCurrentSourceRobustFn.(\tsDust);
    showFn.();
    sayFn.("You should hear irregular noise bursts in stereo.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("B1", "dust on CURRENT", "Irregular noise bursts", beforeDict, afterDict);

    // C) Prepare NEXT: Saw + Tremolo, then switch
    setActiveStepFn.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
    sayFn.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
    sayFn.("Setting NEXT source to Saw in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    setNextSourceRobustFn.(\tsSaw);
    pedalboard.add(\tremolo);     // inserts before source
    showFn.();
    sayFn.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear a saw tone with strong amplitude modulation (tremolo).");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", beforeDict, afterDict);

    // D) Bypass tremolo on CURRENT, then un-bypass
    setActiveStepFn.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
    sayFn.("Bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, true);
    showFn.();
    sayFn.("You should hear plain Saw (no tremolo).");
    waitIfPausedFn.(); waitShortDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("D1", "bypass tremolo", "Plain Saw", beforeDict, afterDict);

    setActiveStepFn.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
    sayFn.("Un-bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, false);
    showFn.();
    sayFn.("Tremolo should be back.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("D2", "un-bypass tremolo", "Saw with tremolo", beforeDict, afterDict);

    // E) Prepare NEXT: Atten + Lofi + Saw (swap), then switch
    setActiveStepFn.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
    sayFn.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
    sayFn.("Adding \\atten at index 1 in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.addAt(\atten, 1);
    showFn.();

    sayFn.("Adding \\lofi at index 2 in");
    countdownFn.(2);
    pedalboard.addAt(\lofi, 2);
    showFn.();

    sayFn.("Swap NEXT indices 1 and 2 in");
    countdownFn.(2);
    pedalboard.swap(1, 2);
    showFn.();
    sayFn.("Switch to NEXT so Atten+Lofi+Saw becomes CURRENT. Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear Saw with lower level and obvious bitcrush/decimation.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", beforeDict, afterDict);

    // F) On NEXT: remove index 1, then clear
    setActiveStepFn.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
    sayFn.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
    sayFn.("Removing at index 1 on NEXT in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.removeAt(1);
    showFn.();

    sayFn.("Clear NEXT back to [sink, source] in");
    countdownFn.(2);
    pedalboard.clearChain;
    showFn.();
    waitIfPausedFn.(); waitShortDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("F1", "remove + clear NEXT", "[sink, source]", beforeDict, afterDict);

    // G) NEXT source to Sine, then switch
    setActiveStepFn.("G1", "Set NEXT source to Sine, then switch", "Steady sine tone");
    sayFn.("Set NEXT source to Sine and then switch.");
    sayFn.("Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setNextSourceRobustFn.(\tsSine);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should now hear a steady sine tone.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("G1", "switch to Sine", "Steady sine tone", beforeDict, afterDict);

    // Wrap up
    setActiveStepFn.("Z", "Demo complete", "Nothing playing after stop");
    sayFn.("Demo complete. Stopping current chain in");
    countdownFn.(3);
    pedalboard.stopCurrent;

    // Summary (build + copy to clipboard)
    {
        var summaryStr;

        "========== MagicPedalboardNew QA Summary ==========".postln;
        ("Class " ++ MagicPedalboardNew.version).postln;
        ("Steps run: " ++ ~qa.steps.size).postln;
        if(~qa.issues.size == 0 and: { ~qa.pendingIssues.size == 0 }) {
            "No issues were flagged. ðŸŽ‰".postln;
        }{
            ("% issues flagged (submitted during run):".format(~qa.issues.size)).postln;
            ~qa.steps.do { |stepEntry|
                if(stepEntry[\userFlagged] == true) {
                    (stepEntry[\id] ++ " â€” " ++ stepEntry[\title]).postln;
                    ("Expected: " ++ stepEntry[\expected]).postln;
                    ("Before: current=" ++ stepEntry[\before].current ++ " next=" ++ stepEntry[\before].next).postln;
                    ("After : current=" ++ stepEntry[\after].current ++ " next=" ++ stepEntry[\after].next).postln;
                    ("Bypass(Current/Next): " ++ stepEntry[\after].bypassCurrent ++ " / " ++ stepEntry[\after].bypassNext).postln;
                    if(stepEntry[\userNote].notNil and: { stepEntry[\userNote] != "" }) {
                        ("Note: " ++ stepEntry[\userNote]).postln;
                    };
                    "".postln;
                };
            };
            if(~qa.pendingIssues.size > 0) {
                "Pending issues captured before step completion:".postln;
                ~qa.pendingIssues.keysValuesDo { |sid, rec|
                    (sid ++ "  (no step snapshot available yet)").postln;
                    ("Note: " ++ rec[\note]).postln;
                };
            };
        };

        summaryStr = String.streamContents { |str|
            str << "========== MagicPedalboardNew QA Summary ==========" << Char.nl;
            str << ("Class " ++ MagicPedalboardNew.version) << Char.nl;
            str << ("Steps run: " ++ ~qa.steps.size) << Char.nl;
            if(~qa.issues.size == 0 and: { ~qa.pendingIssues.size == 0 }) {
                str << "No issues were flagged." << Char.nl;
            }{
                str << ("% issues flagged:".format(~qa.issues.size)) << Char.nl;
                ~qa.steps.do { |stepEntry|
                    if(stepEntry[\userFlagged] == true) {
                        str << (stepEntry[\id] ++ " â€” " ++ stepEntry[\title]) << Char.nl;
                        str << ("Expected: " ++ stepEntry[\expected]) << Char.nl;
                        str << ("Before: current=" ++ stepEntry[\before].current ++ " next=" ++ stepEntry[\before].next) << Char.nl;
                        str << ("After : current=" ++ stepEntry[\after].current ++ " next=" ++ stepEntry[\after].next) << Char.nl;
                        str << ("Bypass(Current/Next): " ++ stepEntry[\after].bypassCurrent ++ " / " ++ stepEntry[\after].bypassNext) << Char.nl;
                        if(stepEntry[\userNote].notNil and: { stepEntry[\userNote] != "" }) {
                            str << ("Note: " ++ stepEntry[\userNote]) << Char.nl;
                        };
                        str << Char.nl;
                    };
                };
                if(~qa.pendingIssues.size > 0) {
                    str << "Pending issues captured before step completion:" << Char.nl;
                    ~qa.pendingIssues.keysValuesDo { |sid, rec|
                        str << sid << "  (no step snapshot available yet)" << Char.nl;
                        str << ("Note: " ++ rec[\note]) << Char.nl;
                    };
                };
            };
        };

        if(GUI.respondsTo(\setClipboard)) {
            GUI.setClipboard(summaryStr);
            "Summary copied to clipboard.".postln;
        };
    }.value;

}).play(SystemClock);   // <<< IMPORTANT: run on SystemClock (not AppClock)
)
// Test_MagicPedalboardNew_v0_11_QA_PauseResume_Fixed.scd
// MD 20250911-1225

(
var qaWindow, infoText, noteTextField, reportButton, submitButton, resumeButton, updateInfoFn;
var waitShortDur, waitMedDur;
var sayFn, countdownFn, showFn;
var snapshotFn, setActiveStepFn, pushStepFn, absorbPendingIssueForFn;
var requestPauseFn, waitIfPausedFn, submitIssueFn, resumeNoIssueFn;
var setCurrentSourceRobustFn, setNextSourceRobustFn, forceSilentBaselineFn;
var runRoutine;

var beforeDict, afterDict;
var activeStepId, activeStepTitle, activeStepExpected;
var pedalboard;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 0) Sources and processors (stereo; processors use \in)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ndef(\ts0,   { Silent.ar(2) });
Ndef(\tsDust,{ Dust.ar(2000) ! 2 });
Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });
Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });

Ndef(\tremolo, { |rate = 4, depth = 0.9|
    var inputSignal, mod;
    inputSignal = \in.ar(2);
    mod = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * mod
});

Ndef(\lofi, { |bits = 4, rate = 4000|
    var inputSignal;
    inputSignal = \in.ar(2);
    Decimator.ar(inputSignal, rate, bits)
});

Ndef(\atten, { |gain = 0.25|
    var inputSignal;
    inputSignal = \in.ar(2) * gain;
    inputSignal
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1) Instantiate + reset + HARD SILENT BASELINE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pedalboard = MagicPedalboardNew.new;
pedalboard.reset; // canonical baseline from the class

// robust helpers for source setting
setCurrentSourceRobustFn = { |key|
    if(pedalboard.respondsTo(\setSourceCurrent)) {
        pedalboard.setSourceCurrent(key);
    }{
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "[QA] ERROR: setSourceCurrent missing; cannot set current source.".warn;
        };
        pedalboard.switchChain;
    }
};

setNextSourceRobustFn = { |key|
    if(pedalboard.respondsTo(\setSource)) {
        pedalboard.setSource(key);
    }{
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "[QA] ERROR: missing setSource and setSourceCurrent; cannot set next source.".warn;
        };
        pedalboard.switchChain;
    }
};

// hard silent baseline: both chains => [sink, \ts0], both cleared, only current plays
forceSilentBaselineFn = {
    "[QA] Force silent baselineâ€¦".postln;
    pedalboard.reset;                 // resets to [\chainA,\ts0] / [\chainB,\ts0], plays A
    setCurrentSourceRobustFn.(\ts0);  // explicit, even if reset did it
    setNextSourceRobustFn.(\ts0);

    // clear NEXT, then switch/clear to clear CURRENT as well
    pedalboard.clearChain;            // clears NEXT to [sink, source]
    pedalboard.switchChain;
    pedalboard.clearChain;            // clears NEXT (which is previous CURRENT)
    pedalboard.switchChain;

    // make absolutely sure no test Ndefs are playing directly
    [\tsDust, \tsSaw, \tsSine, \tremolo, \lofi, \atten].do { |k|
        if(Ndef(k).isPlaying) { Ndef(k).stop }
    };

    // play current sink, stop next
    Ndef(\chainA).play(numChannels: 2);
    Ndef(\chainB).stop;

    "[QA] Baseline set. Expect: silence.".postln;
};
forceSilentBaselineFn.();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 2) QA state (no GUI calls here)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
~qa = (
    steps: Array.new,
    issues: Array.new,
    currentStep: nil,
    pendingIssues: IdentityDictionary.new,   // stepId -> (reason:, note:)
    pauseRequested: false,
    pauseCondition: Condition.new
);

snapshotFn = {
    (
        time: Main.elapsedTime,
        current: pedalboard.currentChain.copy,
        next: pedalboard.nextChain.copy,
        effCurrent: pedalboard.effectiveCurrent,
        effNext: pedalboard.effectiveNext,
        bypassCurrent: pedalboard.bypassKeysCurrent,
        bypassNext: pedalboard.bypassKeysNext
    )
};

setActiveStepFn = { |stepId, stepTitle, expectedText|
    activeStepId = stepId;
    activeStepTitle = stepTitle;
    activeStepExpected = expectedText;
    AppClock.sched(0, {
        infoText.string = "Step: % â€” %\nExpect: %".format(stepId, stepTitle, expectedText);
        qaWindow.name = "MPBNew QA â€“ two-step issue capture";
        nil
    });
};

pushStepFn = { |stepId, stepTitle, expectedText, beforeSnap, afterSnap|
    var entry;
    entry = (
        id: stepId,
        title: stepTitle,
        expected: expectedText,
        before: beforeSnap,
        after: afterSnap,
        userFlagged: false,
        userReason: nil,
        userNote: nil
    );
    ~qa.steps = ~qa.steps.add(entry);
    ~qa.currentStep = entry;
    absorbPendingIssueForFn.(stepId, entry);
};

absorbPendingIssueForFn = { |stepId, entry|
    var pending;
    pending = ~qa.pendingIssues[stepId];
    if(pending.notNil) {
        entry[\userFlagged] = true;
        entry[\userReason] = pending[\reason];
        entry[\userNote] = pending[\note];
        if(~qa.issues.includes(stepId).not) { ~qa.issues = ~qa.issues.add(stepId) };
        ~qa.pendingIssues.removeAt(stepId);
    };
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3) Pause / resume workflow (Routine on SystemClock; GUI on AppClock)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
requestPauseFn = {
    "[QA] pause requested".postln;
    ~qa.pauseRequested = true;
    AppClock.sched(0, {
        infoText.string = "PAUSED at % â€” %\nType your note, then Submit or Resume."
            .format(activeStepId ? "(unknown)", activeStepTitle ? "(unknown)");
        qaWindow.name = "MPBNew QA â€“ PAUSED";
        // enable submit/resume, disable report
        reportButton.enabled = false;
        submitButton.enabled = true;
        resumeButton.enabled = true;
        nil
    });
};

waitIfPausedFn = {
    while { ~qa.pauseRequested } { ~qa.pauseCondition.wait };
};

submitIssueFn = {
    var noteText, reasonText, stepIdLocal;
    noteText = noteTextField.string;
    reasonText = "user report (paused)";
    stepIdLocal = activeStepId ? ("unknown-" ++ Main.elapsedTime.round(0.01));
    ~qa.pendingIssues[stepIdLocal] = (reason: reasonText, note: noteText);
    ("[QA] issue submitted for step %".format(stepIdLocal)).postln;
    if(noteText.notNil and: { noteText != "" }) { ("[QA] note: " ++ noteText).postln };

    ~qa.pauseRequested = false;
    ~qa.pauseCondition.signal;
    AppClock.sched(0, {
        infoText.string = "Captured issue for step %.\nResumingâ€¦".format(stepIdLocal);
        qaWindow.name = "MPBNew QA â€“ two-step issue capture";
        // after resume, re-enable report and disable submit/resume
        reportButton.enabled = true;
        submitButton.enabled = false;
        resumeButton.enabled = false;
        nil
    });
};

resumeNoIssueFn = {
    "[QA] resume (no issue)".postln;
    ~qa.pauseRequested = false;
    ~qa.pauseCondition.signal;
    AppClock.sched(0, {
        infoText.string = "Resuming without logging an issueâ€¦";
        qaWindow.name = "MPBNew QA â€“ two-step issue capture";
        reportButton.enabled = true;
        submitButton.enabled = false;
        resumeButton.enabled = false;
        nil
    });
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4) Console helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sayFn = { |text| text.asString.postln };

countdownFn = { |seconds = 3|
    var remaining;
    remaining = seconds;
    while { remaining > 0 } {
        waitIfPausedFn.();
        (remaining.asString ++ "...").postln;
        1.wait; // SystemClock wait
        remaining = remaining - 1;
    };
    waitIfPausedFn.();
    "Now.".postln;
};

showFn = {
    "â€” Chains â€”".postln;
    pedalboard.printChains;
    "".postln;
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 5) QA UI (AppClock-safe GUI)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
qaWindow = Window("MPBNew QA â€“ two-step issue capture", Rect(100, 100, 700, 220)).front.alwaysOnTop_(true);
infoText = StaticText(qaWindow, Rect(10, 10, 680, 40)).string_("Step: (pending)");
noteTextField = TextField(qaWindow, Rect(10, 60, 680, 24)).string_("Type your note hereâ€¦");

// left: report (pause). middle: submit & resume. right: resume without logging.
reportButton = Button(qaWindow, Rect(10, 100, 220, 30))
    .states_([["Report Issue (Pause)", Color.white, Color.red]])
    .action_({ requestPauseFn.() });

submitButton = Button(qaWindow, Rect(240, 100, 220, 30))
    .states_([["Submit Issue & Resume", Color.white, Color(0, 0.5, 0)]])
    .action_({ submitIssueFn.() })
    .enabled_(false);

resumeButton = Button(qaWindow, Rect(470, 100, 220, 30))
    .states_([["Resume (No Issue)", Color.white, Color.gray]])
    .action_({ resumeNoIssueFn.() })
    .enabled_(false);

// keyboard: X pauses, Enter submits, Esc resumes without logging
qaWindow.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
    if(char == $x or: { char == $X }) { requestPauseFn.() };
    if(keycode == 36 or: { keycode == 52 }) { submitIssueFn.() }; // Enter / keypad Enter
    if(keycode == 53) { resumeNoIssueFn.() };                      // Esc
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 6) Narrated sequence (RUN ON SystemClock)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
waitShortDur = 1.8;
waitMedDur   = 3.0;

runRoutine = Routine({
    // A) Start silent on CURRENT
    setActiveStepFn.("A1", "Start silent \\ts0 on CURRENT", "Silence");
    sayFn.("Starting with a silent CURRENT chain. Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setCurrentSourceRobustFn.(\ts0);
    pedalboard.playCurrent;
    showFn.();
    sayFn.("You should hear nothing.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("A1", "silent on CURRENT", "You should hear nothing.", beforeDict, afterDict);

    // B) Change CURRENT source to Dust
    setActiveStepFn.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
    sayFn.("Change CURRENT source to Dust(2000). Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setCurrentSourceRobustFn.(\tsDust);
    showFn.();
    sayFn.("You should hear irregular noise bursts in stereo.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("B1", "dust on CURRENT", "Irregular noise bursts", beforeDict, afterDict);

    // C) Prepare NEXT: Saw + Tremolo, then switch
    setActiveStepFn.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
    sayFn.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
    sayFn.("Setting NEXT source to Saw in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    setNextSourceRobustFn.(\tsSaw);
    pedalboard.add(\tremolo);
    showFn.();
    sayFn.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear a saw tone with strong amplitude modulation (tremolo).");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", beforeDict, afterDict);

    // D) Bypass tremolo on CURRENT, then un-bypass
    setActiveStepFn.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
    sayFn.("Bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, true);
    showFn.();
    sayFn.("You should hear plain Saw (no tremolo).");
    waitIfPausedFn.(); waitShortDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("D1", "bypass tremolo", "Plain Saw", beforeDict, afterDict);

    setActiveStepFn.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
    sayFn.("Un-bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, false);
    showFn.();
    sayFn.("Tremolo should be back.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("D2", "un-bypass tremolo", "Saw with tremolo", beforeDict, afterDict);

    // E) Prepare NEXT: Atten + Lofi + Saw (swap), then switch
    setActiveStepFn.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
    sayFn.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
    sayFn.("Adding \\atten at index 1 in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.addAt(\atten, 1);
    showFn.();

    sayFn.("Adding \\lofi at index 2 in");
    countdownFn.(2);
    pedalboard.addAt(\lofi, 2);
    showFn.();

    sayFn.("Swap NEXT indices 1 and 2 in");
    countdownFn.(2);
    pedalboard.swap(1, 2);
    showFn.();
    sayFn.("Switch to NEXT so Atten+Lofi+Saw becomes CURRENT. Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear Saw with lower level and obvious bitcrush/decimation.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", beforeDict, afterDict);

    // F) On NEXT: remove index 1, then clear
    setActiveStepFn.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
    sayFn.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
    sayFn.("Removing at index 1 on NEXT in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.removeAt(1);
    showFn.();

    sayFn.("Clear NEXT back to [sink, source] in");
    countdownFn.(2);
    pedalboard.clearChain;
    showFn.();
    waitIfPausedFn.(); waitShortDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("F1", "remove + clear NEXT", "[sink, source]", beforeDict, afterDict);

    // G) NEXT source to Sine, then switch
    setActiveStepFn.("G1", "Set NEXT source to Sine, then switch", "Steady sine tone");
    sayFn.("Set NEXT source to Sine and then switch.");
    sayFn.("Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setNextSourceRobustFn.(\tsSine);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should now hear a steady sine tone.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("G1", "switch to Sine", "Steady sine tone", beforeDict, afterDict);

    // Wrap up
    setActiveStepFn.("Z", "Demo complete", "Nothing playing after stop");
    sayFn.("Demo complete. Stopping current chain in");
    countdownFn.(3);
    pedalboard.stopCurrent;

    // Summary
    {
        var summaryStr;

        "========== MagicPedalboardNew QA Summary ==========".postln;
        ("Class " ++ MagicPedalboardNew.version).postln;
        ("Steps run: " ++ ~qa.steps.size).postln;
        if(~qa.issues.size == 0 and: { ~qa.pendingIssues.size == 0 }) {
            "No issues were flagged. ðŸŽ‰".postln;
        }{
            ("% issues flagged (submitted during run):".format(~qa.issues.size)).postln;
            ~qa.steps.do { |st|
                if(st[\userFlagged] == true) {
                    (st[\id] ++ " â€” " ++ st[\title]).postln;
                    ("Expected: " ++ st[\expected]).postln;
                    ("Before: current=" ++ st[\before].current ++ " next=" ++ st[\before].next).postln;
                    ("After : current=" ++ st[\after].current ++ " next=" ++ st[\after].next).postln;
                    ("Bypass(Current/Next): " ++ st[\after].bypassCurrent ++ " / " ++ st[\after].bypassNext).postln;
                    if(st[\userNote].notNil and: { st[\userNote] != "" }) {
                        ("Note: " ++ st[\userNote]).postln;
                    };
                    "".postln;
                };
            };
            if(~qa.pendingIssues.size > 0) {
                "Pending issues captured before step completion:".postln;
                ~qa.pendingIssues.keysValuesDo { |sid, rec|
                    (sid ++ "  (no step snapshot available yet)").postln;
                    ("Note: " ++ rec[\note]).postln;
                };
            };
        };

        summaryStr = String.streamContents { |str|
            str << "========== MagicPedalboardNew QA Summary ==========" << Char.nl;
            str << ("Class " ++ MagicPedalboardNew.version) << Char.nl;
            str << ("Steps run: " ++ ~qa.steps.size) << Char.nl;
            if(~qa.issues.size == 0 and: { ~qa.pendingIssues.size == 0 }) {
                str << "No issues were flagged." << Char.nl;
            }{
                str << ("% issues flagged:".format(~qa.issues.size)) << Char.nl;
                ~qa.steps.do { |st|
                    if(st[\userFlagged] == true) {
                        str << (st[\id] ++ " â€” " ++ st[\title]) << Char.nl;
                        str << ("Expected: " ++ st[\expected]) << Char.nl;
                        str << ("Before: current=" ++ st[\before].current ++ " next=" ++ st[\before].next) << Char.nl;
                        str << ("After : current=" ++ st[\after].current ++ " next=" ++ st[\after].next) << Char.nl;
                        str << ("Bypass(Current/Next): " ++ st[\after].bypassCurrent
                            ++ " / " ++ st[\after].bypassNext) << Char.nl;
                        if(st[\userNote].notNil and: { st[\userNote] != "" }) {
                            str << ("Note: " ++ st[\userNote]) << Char.nl;
                        };
                        str << Char.nl;
                    };
                };
                if(~qa.pendingIssues.size > 0) {
                    str << "Pending issues captured before step completion:" << Char.nl;
                    ~qa.pendingIssues.keysValuesDo { |sid, rec|
                        str << sid << "  (no step snapshot available yet)" << Char.nl;
                        str << ("Note: " ++ rec[\note]) << Char.nl;
                    };
                };
            };
        };

        if(GUI.respondsTo(\setClipboard)) {
            GUI.setClipboard(summaryStr);
            "Summary copied to clipboard.".postln;
        };
    }.value;

}).play(SystemClock); // Routine on SystemClock
)
// Test_MagicPedalboardNew_v0_12_QA_PauseResume_FixedPreflight.scd
// MD 20250911-1315

(
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// All code is executed only after the server is booted and ready.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
s.waitForBoot({

    var qaWindow, infoText, noteTextField, reportButton, submitButton, resumeButton, updateInfoFn;
    var waitShortDur, waitMedDur;
    var sayFn, countdownFn, showFn;
    var snapshotFn, setActiveStepFn, pushStepFn, absorbPendingIssueForFn;
    var requestPauseFn, waitIfPausedFn, submitIssueFn, resumeNoIssueFn;
    var setCurrentSourceRobustFn, setNextSourceRobustFn, forceSilentBaselineFn, preflightCleanupFn;
    var runRoutine;

    var beforeDict, afterDict;
    var activeStepId, activeStepTitle, activeStepExpected;
    var pedalboard;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 0) Preflight cleanup: stop Ndefs, clear any ProxySpaces, and
    //    re-initialize the default group safely (no s.freeAll).
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    preflightCleanupFn = {
        "[QA] Preflight: checking for stray Ndefs and active ProxySpaceâ€¦".postln;

        // Stop any Ndefs that might be playing, then clear them
        Ndef.all.keysValuesDo { |key, proxy|
            if(proxy.isPlaying) {
                ("[QA] Stopping stray Ndef: " ++ key).postln;
                proxy.stop;
            };
            proxy.clear;
        };

        // Clear all ProxySpaces known to SC (if exposed):
        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo { |srv, ps|
                if(ps.notNil) {
                    ("[QA] Clearing ProxySpace on " ++ srv).postln;
                    ps.clear; // frees ~proxies (e.g., ~tsDust, ~tremolo)
                };
            };
        };

        // If the current environment *is* a ProxySpace, pop it
        if(currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" }) {
            "[QA] Active ProxySpace is current env â†’ pop it.".postln;
            currentEnvironment.pop;
        } {
            "[QA] No active ProxySpace as current env.".postln;
        };

        // SAFELY reset the server tree: recreate Group 1 then free its children
        s.initTree;                // (re)create default group 1 under root
        s.defaultGroup.freeAll;    // keep group 1, remove its children
    };
    preflightCleanupFn.();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 1) Sources and processors (stereo; processors use \in)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Ndef(\ts0,   { Silent.ar(2) });
    Ndef(\tsDust,{ Dust.ar(2000) ! 2 });
    Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });
    Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });

    Ndef(\tremolo, { |rate = 4, depth = 0.9|
        var inputSignal, mod;
        inputSignal = \in.ar(2);
        mod = SinOsc.kr(rate).range(1 - depth, 1);
        inputSignal * mod
    });

    Ndef(\lofi, { |bits = 4, rate = 4000|
        var inputSignal;
        inputSignal = \in.ar(2);
        Decimator.ar(inputSignal, rate, bits)
    });

    Ndef(\atten, { |gain = 0.25|
        var inputSignal;
        inputSignal = \in.ar(2) * gain;
        inputSignal
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 2) Instantiate + reset + HARD SILENT BASELINE
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    pedalboard = MagicPedalboardNew.new;
    pedalboard.reset; // canonical baseline from the class

    // robust helpers for source setting
    setCurrentSourceRobustFn = { |key|
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            pedalboard.switchChain;
            if(pedalboard.respondsTo(\setSourceCurrent)) {
                pedalboard.setSourceCurrent(key);
            }{
                "[QA] ERROR: setSourceCurrent missing; cannot set current source.".warn;
            };
            pedalboard.switchChain;
        }
    };

    setNextSourceRobustFn = { |key|
        if(pedalboard.respondsTo(\setSource)) {
            pedalboard.setSource(key);
        }{
            pedalboard.switchChain;
            if(pedalboard.respondsTo(\setSourceCurrent)) {
                pedalboard.setSourceCurrent(key);
            }{
                "[QA] ERROR: missing setSource and setSourceCurrent; cannot set next source.".warn;
            };
            pedalboard.switchChain;
        }
    };

    // Guarantee silence and a canonical shape on both chains
    forceSilentBaselineFn = {
        "[QA] Force silent baselineâ€¦".postln;
        pedalboard.reset;                 // [\chainA,\ts0] + [\chainB,\ts0], plays A
        setCurrentSourceRobustFn.(\ts0);
        setNextSourceRobustFn.(\ts0);

        pedalboard.clearChain;            // clear NEXT
        pedalboard.switchChain;
        pedalboard.clearChain;            // clear previous CURRENT (now NEXT)
        pedalboard.switchChain;

        // ensure only current sink plays
        Ndef(\chainA).play(numChannels: 2);
        Ndef(\chainB).stop;

        "[QA] Baseline set. Expect: silence now.".postln;
    };
    forceSilentBaselineFn.();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 3) QA state (no GUI calls here)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    ~qa = (
        steps: Array.new,
        issues: Array.new,
        currentStep: nil,
        pendingIssues: IdentityDictionary.new,   // stepId -> (reason:, note:)
        pauseRequested: false,
        pauseCondition: Condition.new
    );

    snapshotFn = {
        (
            time: Main.elapsedTime,
            current: pedalboard.currentChain.copy,
            next: pedalboard.nextChain.copy,
            effCurrent: pedalboard.effectiveCurrent,
            effNext: pedalboard.effectiveNext,
            bypassCurrent: pedalboard.bypassKeysCurrent,
            bypassNext: pedalboard.bypassKeysNext
        )
    };

    setActiveStepFn = { |stepId, stepTitle, expectedText|
        activeStepId = stepId;
        activeStepTitle = stepTitle;
        activeStepExpected = expectedText;
        AppClock.sched(0, {
            infoText.string = "Step: % â€” %\nExpect: %".format(stepId, stepTitle, expectedText);
            qaWindow.name = "MPBNew QA â€“ two-step issue capture";
            nil
        });
    };

    pushStepFn = { |stepId, stepTitle, expectedText, beforeSnap, afterSnap|
        var entry;
        entry = (
            id: stepId,
            title: stepTitle,
            expected: expectedText,
            before: beforeSnap,
            after: afterSnap,
            userFlagged: false,
            userReason: nil,
            userNote: nil
        );
        ~qa.steps = ~qa.steps.add(entry);
        ~qa.currentStep = entry;
        absorbPendingIssueForFn.(stepId, entry);
    };

    absorbPendingIssueForFn = { |stepId, entry|
        var pending;
        pending = ~qa.pendingIssues[stepId];
        if(pending.notNil) {
            entry[\userFlagged] = true;
            entry[\userReason] = pending[\reason];
            entry[\userNote] = pending[\note];
            if(~qa.issues.includes(stepId).not) { ~qa.issues = ~qa.issues.add(stepId) };
            ~qa.pendingIssues.removeAt(stepId);
        };
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 4) Pause / resume workflow (Routine on SystemClock; GUI on AppClock)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    requestPauseFn = {
        "[QA] pause requested".postln;
        ~qa.pauseRequested = true;
        AppClock.sched(0, {
            infoText.string = "PAUSED at % â€” %\nType your note, then Submit or Resume."
                .format(activeStepId ? "(unknown)", activeStepTitle ? "(unknown)");
            qaWindow.name = "MPBNew QA â€“ PAUSED";
            reportButton.enabled = false;
            submitButton.enabled = true;
            resumeButton.enabled = true;
            nil
        });
    };

    waitIfPausedFn = {
        while { ~qa.pauseRequested } { ~qa.pauseCondition.wait };
    };

    submitIssueFn = {
        var noteText, reasonText, stepIdLocal;
        noteText = noteTextField.string;
        reasonText = "user report (paused)";
        stepIdLocal = activeStepId ? ("unknown-" ++ Main.elapsedTime.round(0.01));
        ~qa.pendingIssues[stepIdLocal] = (reason: reasonText, note: noteText);
        ("[QA] issue submitted for step %".format(stepIdLocal)).postln;
        if(noteText.notNil and: { noteText != "" }) { ("[QA] note: " ++ noteText).postln };

        ~qa.pauseRequested = false;
        ~qa.pauseCondition.signal;
        AppClock.sched(0, {
            infoText.string = "Captured issue for step %.\nResumingâ€¦".format(stepIdLocal);
            qaWindow.name = "MPBNew QA â€“ two-step issue capture";
            reportButton.enabled = true;
            submitButton.enabled = false;
            resumeButton.enabled = false;
            nil
        });
    };

    resumeNoIssueFn = {
        "[QA] resume (no issue)".postln;
        ~qa.pauseRequested = false;
        ~qa.pauseCondition.signal;
        AppClock.sched(0, {
            infoText.string = "Resuming without logging an issueâ€¦";
            qaWindow.name = "MPBNew QA â€“ two-step issue capture";
            reportButton.enabled = true;
            submitButton.enabled = false;
            resumeButton.enabled = false;
            nil
        });
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 5) Console helpers
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    sayFn = { |text| text.asString.postln };

    countdownFn = { |seconds = 3|
        var remaining;
        remaining = seconds;
        while { remaining > 0 } {
            waitIfPausedFn.();
            (remaining.asString ++ "...").postln;
            1.wait; // SystemClock wait
            remaining = remaining - 1;
        };
        waitIfPausedFn.();
        "Now.".postln;
    };

    showFn = {
        "â€” Chains â€”".postln;
        pedalboard.printChains;
        "".postln;
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 6) QA UI (AppClock-safe GUI)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    qaWindow = Window("MPBNew QA â€“ two-step issue capture", Rect(100, 100, 700, 220)).front.alwaysOnTop_(true);
    infoText = StaticText(qaWindow, Rect(10, 10, 680, 40)).string_("Step: (pending)");
    noteTextField = TextField(qaWindow, Rect(10, 60, 680, 24)).string_("Type your note hereâ€¦");

    reportButton = Button(qaWindow, Rect(10, 100, 220, 30))
        .states_([["Report Issue (Pause)", Color.white, Color.red]])
        .action_({ requestPauseFn.() });

    submitButton = Button(qaWindow, Rect(240, 100, 220, 30))
        .states_([["Submit Issue & Resume", Color.white, Color(0, 0.5, 0)]])
        .action_({ submitIssueFn.() })
        .enabled_(false);

    resumeButton = Button(qaWindow, Rect(470, 100, 220, 30))
        .states_([["Resume (No Issue)", Color.white, Color.gray]])
        .action_({ resumeNoIssueFn.() })
        .enabled_(false);

    // keyboard shortcuts
    qaWindow.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
        if(char == $x or: { char == $X }) { requestPauseFn.() };
        if(keycode == 36 or: { keycode == 52 }) { submitIssueFn.() }; // Enter / keypad Enter
        if(keycode == 53) { resumeNoIssueFn.() };                      // Esc
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 7) Narrated sequence (RUN ON SystemClock)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    waitShortDur = 1.8;
    waitMedDur   = 3.0;

    runRoutine = Routine({

        // A) Start silent on CURRENT
        setActiveStepFn.("A1", "Start silent \\ts0 on CURRENT", "Silence");
        sayFn.("Starting with a silent CURRENT chain. Starting in");
        countdownFn.(3);
        beforeDict = snapshotFn.();
        setCurrentSourceRobustFn.(\ts0);
        pedalboard.playCurrent;
        showFn.();
        sayFn.("You should hear nothing.");
        waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
        afterDict = snapshotFn.();
        pushStepFn.("A1", "silent on CURRENT", "You should hear nothing.", beforeDict, afterDict);

        // â€¦ (keep your B/C/D/E/F/G steps unchanged) â€¦

    }).play(SystemClock);
});
)
// Test_MagicPedalboardNew_v0_13_QA_PauseResume_GUI.scd // WORKING right at 13:41
// MD 20250912-1325

(
// Run only after the server is booted.
s.waitForBoot({

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // var-first: declare everything used in this block up front
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    var preflightCleanup;
    var m, setCurrent, setNext, forceSilentBaseline;
    var qa;
    var win, infoText, noteField, btnReport, btnSubmit, btnResume;
    var say, countdown, show, snapshot, setActiveStep, pushStep, absorbPending, waitIfPaused;
    var runRoutine;
    var before, after;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 0) Preflight: clear old JITLib state; keep the default group
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    preflightCleanup = {
        "[QA] Preflight: clearing Ndefs & ProxySpacesâ€¦".postln;

        // Stop & clear any lingering Ndefs from older sessions
        Ndef.all.keysValuesDo { |key, proxy|
            if(proxy.isPlaying) { ("[CLEAN] stop " ++ key).postln; proxy.stop };
            proxy.clear;
        };

        // Clear any ProxySpaces we can see (class may not expose .all on some builds)
        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo { |srv, ps|
                if(ps.notNil) { ("[CLEAN] ProxySpace on " ++ srv).postln; ps.clear };
            };
        };

        // If the *current* environment is a ProxySpace, pop it
        if(currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" }) {
            "[CLEAN] Pop current ProxySpace env".postln;
            currentEnvironment.pop;
        };

        // Safe server-tree reset (no s.freeAll): keep Group 1 so Ndef/JITLib can attach
        s.initTree;
        s.defaultGroup.freeAll;

        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 1) Minimal test sources / processors
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    Ndef(\ts0,   { Silent.ar(2) });
    Ndef(\tsDust,{ Dust.ar(2000) ! 2 });
    Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });
    Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });

    Ndef(\tremolo, { |rate = 4, depth = 0.9|
        var x;
        x = \in.ar(2);
        x * SinOsc.kr(rate).range(1 - depth, 1)
    });

    Ndef(\lofi, { |bits = 4, rate = 4000|
        var x;
        x = \in.ar(2);
        Decimator.ar(x, rate, bits)
    });

    Ndef(\atten, { |gain = 0.25|
        var x;
        x = \in.ar(2);
        x * gain
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 2) Pedalboard + hard silent baseline
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    m = MagicPedalboardNew.new;
    m.reset;

    setCurrent = { |key|
        if(m.respondsTo(\setSourceCurrent)) { m.setSourceCurrent(key) }
        { "ERROR: setSourceCurrent missing".warn };
    };
    setNext = { |key|
        if(m.respondsTo(\setSource)) { m.setSource(key) }
        { "ERROR: setSource missing".warn };
    };

    forceSilentBaseline = {
        "[QA] Force silent baselineâ€¦".postln;
        m.reset;
        setCurrent.(\ts0);
        setNext.(\ts0);

        m.clearChain;            // clear NEXT
        m.switchChain;
        m.clearChain;            // clear previous CURRENT (now NEXT)
        m.switchChain;

        Ndef(\chainA).play(numChannels: 2);
        Ndef(\chainB).stop;

        "[QA] Baseline set. Expect: silence now.".postln;
    };
    forceSilentBaseline.();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 3) QA state (pause controller, steps, issues)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    qa = (
        steps: Array.new,
        issues: Array.new,
        currentStep: nil,
        pendingIssues: IdentityDictionary.new,   // stepId -> (reason:, note:)
        pauseRequested: false,
        pauseCondition: Condition.new
    );

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 4) GUI (AppClock). Window shows PAUSED state & toggles buttons.
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    win = Window("MPBNew QA â€“ press X to pause; Enter to submit; Esc to resume",
                 Rect(100, 100, 740, 230)).front.alwaysOnTop_(true);
    infoText = StaticText(win, Rect(10, 10, 720, 44)).string_("Step: (pending)");
    noteField = TextField(win, Rect(10, 60, 720, 24)).string_("Type your note hereâ€¦");

    btnReport = Button(win, Rect(10, 100, 230, 30))
        .states_([["Report Issue (Pause)", Color.white, Color.red]])
        .action_({
            qa[\pauseRequested] = true; "[QA] pause requested".postln;
            AppClock.sched(0, {
                infoText.string = "PAUSED: type a note, then Submit or Resume.";
                win.name = "MPBNew QA â€“ PAUSED";
                btnReport.enabled = false; btnSubmit.enabled = true; btnResume.enabled = true; nil
            });
        });

    btnSubmit = Button(win, Rect(250, 100, 230, 30))
        .states_([["Submit Issue & Resume", Color.white, Color(0, 0.5, 0)]])
        .action_({
            var noteTxt, stepIdLocal, reasonTxt;
            noteTxt = noteField.string;
            reasonTxt = "user report (paused)";
            stepIdLocal = qa[\currentStep].notNil.if({ qa[\currentStep][\id] }, { "unknown-" ++ Main.elapsedTime.round(0.01) });
            qa[\pendingIssues][stepIdLocal] = (reason: reasonTxt, note: noteTxt);
            ("[QA] issue submitted for " ++ stepIdLocal).postln;
            if(noteTxt.notNil and: { noteTxt != "" }) { ("[QA] note: " ++ noteTxt).postln };
            qa[\pauseRequested] = false; qa[\pauseCondition].signal;
            AppClock.sched(0, {
                infoText.string = "Captured issue for " ++ stepIdLocal ++ ". Resumingâ€¦";
                win.name = "MPBNew QA";
                btnReport.enabled = true; btnSubmit.enabled = false; btnResume.enabled = false; nil
            });
        })
        .enabled_(false);

    btnResume = Button(win, Rect(490, 100, 230, 30))
        .states_([["Resume (No Issue)", Color.white, Color.gray]])
        .action_({
            "[QA] resume (no issue)".postln;
            qa[\pauseRequested] = false; qa[\pauseCondition].signal;
            AppClock.sched(0, {
                infoText.string = "Resuming without logging an issueâ€¦";
                win.name = "MPBNew QA";
                btnReport.enabled = true; btnSubmit.enabled = false; btnResume.enabled = false; nil
            });
        })
        .enabled_(false);

    // keyboard shortcuts
    win.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
        if(char == $x or: { char == $X }) { btnReport.action.value };
        if(keycode == 36 or: { keycode == 52 }) { btnSubmit.action.value }; // Enter / keypad Enter
        if(keycode == 53) { btnResume.action.value };                       // Esc
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 5) Helpers (SystemClock-safe)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    say = { |txt| txt.asString.postln };

    countdown = { |n = 3|
        var i;
        i = n;
        while { i > 0 } {
            waitIfPaused.();
            (i.asString ++ "...").postln;
            1.wait;  // SystemClock wait
            i = i - 1;
        };
        waitIfPaused.();
        "Now.".postln;
    };

    waitIfPaused = {
        var t0;
        if(qa[\pauseRequested]) { "[QA] waiting (paused)".postln };
        t0 = Main.elapsedTime;
        while { qa[\pauseRequested] } {
            qa[\pauseCondition].wait;   // signalled by AppClock (GUI buttons)
            if(qa[\pauseRequested] and: { Main.elapsedTime - t0 > 30 }) {
                "[QA] timeout â†’ auto-resume".warn;
                qa[\pauseRequested] = false;
                qa[\pauseCondition].signal;
            };
        };
        if(qa[\pauseRequested].not) { "[QA] resumed".postln };
    };

    show = {
        "â€” Chains â€”".postln;
        m.printChains;
        "".postln;
    };

    snapshot = {
        (
            time: Main.elapsedTime,
            current: m.currentChain.copy,
            next: m.nextChain.copy,
            effCurrent: m.effectiveCurrent,
            effNext: m.effectiveNext,
            bypassCurrent: m.bypassKeysCurrent,
            bypassNext: m.bypassKeysNext
        )
    };

    setActiveStep = { |id, title, expected|
        qa[\currentStep] = nil;  // will set when pushing the step
        AppClock.sched(0, {
            infoText.string = "Step: " ++ id ++ " â€” " ++ title ++ "\nExpect: " ++ expected;
            win.name = "MPBNew QA";
            nil
        });
    };

    absorbPending = { |id, entry|
        var p;
        p = qa[\pendingIssues][id];
        if(p.notNil) {
            entry[\userFlagged] = true;
            entry[\userReason] = p[\reason];
            entry[\userNote] = p[\note];
            if(qa[\issues].includes(id).not) { qa[\issues] = qa[\issues].add(id) };
            qa[\pendingIssues].removeAt(id);
        };
    };

    pushStep = { |id, title, expected, beforeSnap, afterSnap|
        var e;
        e = (id: id, title: title, expected: expected, before: beforeSnap,
             after: afterSnap, userFlagged: false, userReason: nil, userNote: nil);
        qa[\steps] = qa[\steps].add(e);
        qa[\currentStep] = e;
        absorbPending.(id, e);
    };

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // 6) Narrative Routine (RUN ON SystemClock)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    runRoutine = Routine({

        // A) Start silent
        setActiveStep.("A1", "Start silent \\ts0 on CURRENT", "Silence");
        say.("Starting with a silent CURRENT chain. Starting in");
        countdown.(3);
        before = snapshot.();
        setCurrent.(\ts0);
        m.playCurrent;
        show.();
        say.("You should hear nothing.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("A1", "silent on CURRENT", "You should hear nothing.", before, after);

        // B) CURRENT â†’ Dust
        setActiveStep.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
        say.("Change CURRENT source to Dust(2000). Starting in");
        countdown.(3);
        before = snapshot.();
        setCurrent.(\tsDust);
        show.();
        say.("You should hear irregular noise bursts in stereo.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("B1", "dust on CURRENT", "Irregular noise bursts", before, after);

        // C) NEXT: Saw + Tremolo â†’ switch
        setActiveStep.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
        say.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
        say.("Setting NEXT source to Saw in");
        countdown.(2);
        before = snapshot.();
        setNext.(\tsSaw);
        m.add(\tremolo);
        show.();
        say.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
        countdown.(3);
        m.switchChain; show.();
        say.("You should hear a saw tone with strong amplitude modulation (tremolo).");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", before, after);

        // D1) Bypass tremolo
        setActiveStep.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
        say.("Bypass CURRENT tremolo. Starting in");
        countdown.(2);
        before = snapshot.();
        m.bypassCurrent(\tremolo, true); show.();
        say.("You should hear plain Saw (no tremolo).");
        waitIfPaused.(); 1.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("D1", "bypass tremolo", "Plain Saw", before, after);

        // D2) Un-bypass tremolo
        setActiveStep.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
        say.("Un-bypass CURRENT tremolo. Starting in");
        countdown.(2);
        before = snapshot.();
        m.bypassCurrent(\tremolo, false); show.();
        say.("Tremolo should be back.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("D2", "un-bypass tremolo", "Saw with tremolo", before, after);

        // E) Prepare NEXT: atten + lofi + swap â†’ switch
        setActiveStep.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
        say.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
        say.("Adding \\atten at index 1 in");
        countdown.(2);
        before = snapshot.();
        m.addAt(\atten, 1); show.();

        say.("Adding \\lofi at index 2 in");
        countdown.(2);
        m.addAt(\lofi, 2); show.();

        say.("Swap NEXT indices 1 and 2 in");
        countdown.(2);
        m.swap(1, 2); show.();

        say.("Switch to NEXT in");
        countdown.(3);
        m.switchChain; show.();
        say.("You should hear Saw with lower level and obvious bitcrush/decimation.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", before, after);

        // F) On NEXT: remove @1, then clear
        setActiveStep.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
        say.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
        say.("Removing at index 1 on NEXT in");
        countdown.(2);
        before = snapshot.();
        m.removeAt(1); show.();
        say.("Clear NEXT back to [sink, source] in");
        countdown.(2);
        m.clearChain; show.();
        waitIfPaused.(); 1.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("F1", "remove + clear NEXT", "[sink, source]", before, after);

        // G) NEXT â†’ ts0, then switch (silent again)
        setActiveStep.("G1", "Set NEXT source to ts0, then switch", "Silence");
        say.("Set NEXT source to \\ts0 and then switch.");
        say.("Starting in");
        countdown.(3);
        before = snapshot.();
        setNext.(\ts0);
        m.switchChain; show.();
        say.("You should now hear silence.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("G1", "switch to ts0", "Silence", before, after);

        // Done
        say.("Done. Stopping."); m.stopCurrent;
    }).play(SystemClock);   // Routine on SystemClock; GUI on AppClock
});
)
// Test_MagicPedalboardNew_v0_3_1_Sanity_NoGUI.scd
// MD 20250912-1345

(
s.waitForBoot({
    var say, countdown, show, preflight, setCurrent, setNext, board, displayAdaptor;

    say = { |txt| txt.asString.postln };
    countdown = { |n = 3| n.do { |k| ((n - k).asString ++ "...").postln; 1.wait }; "Now.".postln; };

    preflight = {
        // safe cleanup
        Ndef.all.keysValuesDo { |key, proxy| if(proxy.isPlaying) { proxy.stop }; proxy.clear };
        if(ProxySpace.respondsTo(\all)) { ProxySpace.all.valuesDo { |ps| if(ps.notNil) { ps.clear } } };
        s.initTree; s.defaultGroup.freeAll;
    };

    show = { "â€” Chains (detailed) â€”".postln; board.printChains; "".postln; };

    setCurrent = { |key| if(board.respondsTo(\setSourceCurrent)) { board.setSourceCurrent(key) } };
    setNext    = { |key| if(board.respondsTo(\setSource))        { board.setSource(key)        } };

    preflight.();

    displayAdaptor = MagicDisplay.new(1);
    board = MagicPedalboardNew.new(displayAdaptor);
    board.reset;

    // silent baseline
    setCurrent.(\ts0); setNext.(\ts0);
    board.clearChain; board.switchChain; board.clearChain; board.switchChain;
    Ndef(\chainA).play(numChannels: 2); Ndef(\chainB).stop;

    say.("A1: silent"); show.(); 2.wait;

    say.("B1: CURRENT->Dust"); setCurrent.(\tsDust); show.(); 2.wait;

    say.("C1: NEXT Saw+Trem -> switch");
    setNext.(\tsSaw); board.add(\tremolo); show.();
    countdown.(3); board.switchChain; show.(); 2.wait;

    say.("D1: bypass tremolo"); board.bypassCurrent(\tremolo, true); show.(); 1.wait;
    say.("D2: un-bypass tremolo"); board.bypassCurrent(\tremolo, false); show.(); 2.wait;

    say.("E1: NEXT add atten@1, lofi@2, swap -> switch");
    board.addAt(\atten, 1); board.addAt(\lofi, 2); board.swap(1, 2); show.();
    countdown.(2); board.switchChain; show.(); 2.wait;

    say.("F1: NEXT removeAt(1), clear");
    board.removeAt(1); show.(); board.clearChain; show.(); 1.wait;

    say.("G1: NEXT->ts0, switch");
    setNext.(\ts0); countdown.(2); board.switchChain; show.(); 2.wait;

    say.("Done. Stopping."); board.stopCurrent;
});
)
// Test_MagicPedalboardNew_v0_3_2_Sanity_NoGUI.scd
// MD 20250912-1350

(
s.waitForBoot({
    var say, countdown, show, preflight, setCurrent, setNext, board, displayAdaptor;

    say = { |text| text.asString.postln };

    countdown = { |n = 3|
        var k;
        k = n;
        while { k > 0 } {
            ((k).asString ++ "...").postln;
            1.wait;
            k = k - 1;
        };
        "Now.".postln;
    };

    preflight = {
        // stop + clear any Ndefs lingering from older sessions
        Ndef.all.keysValuesDo { |keySymbol, nodeProxy|
            if(nodeProxy.isPlaying) { nodeProxy.stop };
            nodeProxy.clear;
        };

        // clear any ProxySpaces we can see (IdentityDictionary â‡’ no valuesDo)
        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo { |serverKey, proxySpace|
                if(proxySpace.notNil) { proxySpace.clear };
            };
        };

        // safe server tree reset (keep Group 1)
        s.initTree;
        s.defaultGroup.freeAll;
    };

    show = {
        "â€” Chains (detailed) â€”".postln;
        board.printChains;
        "".postln;
    };

    setCurrent = { |key|
        if(board.respondsTo(\setSourceCurrent)) { board.setSourceCurrent(key) }
        { "ERROR: setSourceCurrent missing".warn };
    };

    setNext = { |key|
        if(board.respondsTo(\setSource)) { board.setSource(key) }
        { "ERROR: setSource missing".warn };
    };

    // ---- go ----
    preflight.();

    // minimal sources/processors for the demo
    Ndef(\ts0,   { Silent.ar(2) });
    Ndef(\tsDust,{ Dust.ar(2000) ! 2 });
    Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });
    Ndef(\tremolo, { |rate = 4, depth = 0.9|
        var inputSignal;
        inputSignal = \in.ar(2);
        inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
    });
    Ndef(\lofi, { |bits = 4, rate = 4000|
        var inputSignal;
        inputSignal = \in.ar(2);
        Decimator.ar(inputSignal, rate, bits)
    });
    Ndef(\atten, { |gain = 0.25|
        var inputSignal;
        inputSignal = \in.ar(2) * gain;
        inputSignal
    });

    displayAdaptor = MagicDisplay.new(1);
    board = MagicPedalboardNew.new(displayAdaptor);
    board.reset;

    // canonical silent baseline
    setCurrent.(\ts0);
    setNext.(\ts0);
    board.clearChain; board.switchChain; board.clearChain; board.switchChain;
    Ndef(\chainA).play(numChannels: 2);
    Ndef(\chainB).stop;

    say.("A1: silent"); show.(); 2.wait;

    say.("B1: CURRENTâ†’Dust"); setCurrent.(\tsDust); show.(); 2.wait;

    say.("C1: NEXT Saw+Trem â†’ switch");
    setNext.(\tsSaw); board.add(\tremolo); show.();
    countdown.(3); board.switchChain; show.(); 2.wait;

    say.("D1: bypass tremolo"); board.bypassCurrent(\tremolo, true); show.(); 1.wait;
    say.("D2: un-bypass tremolo"); board.bypassCurrent(\tremolo, false); show.(); 2.wait;

    say.("E1: NEXT add atten@1, lofi@2, swap â†’ switch");
    board.addAt(\atten, 1); board.addAt(\lofi, 2); board.swap(1, 2); show.();
    countdown.(2); board.switchChain; show.(); 2.wait;

    say.("F1: NEXT removeAt(1), clear");
    board.removeAt(1); show.(); board.clearChain; show.(); 1.wait;

    say.("G1: NEXTâ†’ts0, switch");
    setNext.(\ts0); countdown.(2); board.switchChain; show.(); 2.wait;

    say.("Done. Stopping."); board.stopCurrent;
});
)
// Test_MPB_Sanity_NoGUI_v0_13.scd
// MD 20250911-1320

(
// Run everything only after the server is up.
s.waitForBoot({
    var say, countdown, show, sanityPreflight, setCurrent, setNext;
    var m;

    say = { |txt| txt.asString.postln };
    countdown = { |n = 3|
        n.do { |i| ((n - i).asString ++ "...").postln; 1.wait }; "Now.".postln;
    };
    show = {
        "â€” Chains â€”".postln;
        m.printChains;
        "".postln;
    };

    // ---- Safe preflight (no s.freeAll), clear any old JITLib state ----
    sanityPreflight = {
        "== Preflight ==".postln;

        // stop + clear any Ndefs lingering from older sessions
        Ndef.all.keysValuesDo { |k, p|
            if(p.isPlaying) { ("[CLEAN] stop " ++ k).postln; p.stop };
            p.clear;
        };

        // clear all ProxySpaces we can see
        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo { |srv, ps|
                if(ps.notNil) { ("[CLEAN] ProxySpace on " ++ srv).postln; ps.clear };
            };
        };

        // ensure server tree is sane
        s.initTree;
        s.defaultGroup.freeAll;

        "== Preflight done ==".postln;
    };

    setCurrent = { |key|
        if(m.respondsTo(\setSourceCurrent)) { m.setSourceCurrent(key) }
        { "ERROR: setSourceCurrent missing".warn };
    };
    setNext = { |key|
        if(m.respondsTo(\setSource)) { m.setSource(key) }
        { "ERROR: setSource missing".warn };
    };

    // ---- Go ----
    sanityPreflight.();

    // Minimal source + processor Ndefs
    Ndef(\ts0,   { Silent.ar(2) });
    Ndef(\tsDust,{ Dust.ar(2000) ! 2 });
    Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });
    Ndef(\tremolo, { |rate = 4, depth = 0.9|
        var x = \in.ar(2); x * SinOsc.kr(rate).range(1 - depth, 1)
    });

    // Pedalboard
    m = MagicPedalboardNew.new;
    m.reset;

    // Hard silent baseline
    setCurrent.(\ts0);
    setNext.(\ts0);
    m.clearChain;         // clear NEXT
    m.switchChain;
    m.clearChain;         // clear previous CURRENT (now NEXT)
    m.switchChain;
    Ndef(\chainA).play(numChannels: 2);
    Ndef(\chainB).stop;

    // ---- Narrative, no pauses, explicit progress logs ----
    say.("A1 begin");
    say.("Starting silent. Starting in"); countdown.(3);
    show.(); say.("A1 end (should be silent)"); 2.wait;

    say.("B1 begin");
    say.("Switch CURRENT to Dust. Starting in"); countdown.(3);
    setCurrent.(\tsDust);
    show.(); say.("B1 end (should hear irregular bursts)"); 2.wait;

    say.("C1 begin");
    say.("Prepare NEXT: Saw + Tremolo. Starting in"); countdown.(2);
    setNext.(\tsSaw);
    m.add(\tremolo);
    show.();
    say.("Switching to NEXT in"); countdown.(3);
    m.switchChain; show.();
    say.("C1 end (should hear saw with tremolo)"); 2.wait;

    say.("D1 begin");
    say.("Bypass tremolo. Starting in"); countdown.(2);
    m.bypassCurrent(\tremolo, true); show.();
    say.("D1 end (plain saw)"); 1.wait;

    say.("D2 begin");
    say.("Un-bypass tremolo. Starting in"); countdown.(2);
    m.bypassCurrent(\tremolo, false); show.();
    say.("D2 end (tremolo returns)"); 2.wait;

    say.("E1 begin");
    say.("Prepare NEXT: add atten@1, lofi@2, swap. Starting in"); countdown.(2);
    m.addAt(\atten, 1); m.addAt(\lofi, 2); m.swap(1, 2); show.();
    say.("Switch to NEXT in"); countdown.(3);
    m.switchChain; show.();
    say.("E1 end (quiet + crushed)"); 2.wait;

    say.("F1 begin");
    say.("On NEXT, removeAt(1), then clear in"); countdown.(2);
    m.removeAt(1); show.(); m.clearChain; show.();
    say.("F1 end"); 1.wait;

    say.("G1 begin");
    say.("Set NEXT to \\ts0 (back to silence) and switch. Starting in"); countdown.(3);
    setNext.(\ts0); m.switchChain; show.();
    say.("G1 end (silent again)"); 2.wait;

    say.("Done. Stopping."); m.stopCurrent;
});
)
