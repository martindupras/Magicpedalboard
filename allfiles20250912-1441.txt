/* MagicDisplay.sc  v0.1.2
   Console display adaptor for MagicPedalboardNew.
   Prints structured messages now; later you can subclass with a real GUI.
   // MD 20250912-1345
*/

MagicDisplay : Object {

    classvar < version;

    var < logLevel;  // 0 = silent, 1 = normal, 2 = verbose

    *initClass {
        version = "v0.1.2";
        ("MagicDisplay " ++ version).postln;
    }

    *new { |level = 1|
        ^super.new.init(level)
    }

    init { |level|
        var initialLevel;
        initialLevel = level ? 1;
        logLevel = initialLevel;
        ^this
    }

    help {
        var text;
        text = "MagicDisplay " ++ version
        ++ "\nMethods:\n"
        ++ "  showInit(pedalboard, versionString, current, next)\n"
        ++ "  showRebuild(which, fullChain, effective)\n"
        ++ "  showPlay(sink), showStop(sink), showSwitch(oldSink, newSink, current, next)\n"
        ++ "  showMutation(action, args, nextChain)\n"
        ++ "  showBypass(which, key, state, chain, bypassKeys)\n"
        ++ "  showReset(current, next), showChains(current, next, bypassA, bypassB)\n"
        ++ "  showChainsDetailed(current, next, bypassA, bypassB, effCurrent, effNext)\n"
        ++ "  showError(message)\n";
        text.postln;
    }

    showInit { |pedalboard, versionString, current, next|
        if(logLevel > 0) { ("[MPB:init] " ++ versionString ++ "  current=" ++ current ++ "  next=" ++ next).postln };
    }

    showRebuild { |which, fullChain, effective|
        if(logLevel > 0) { ("[MPB:rebuild:" ++ which ++ "] full=" ++ fullChain ++ "  effective=" ++ effective).postln };
    }

    showPlay { |sinkKey|
        if(logLevel > 0) { ("[MPB:play] sink=" ++ sinkKey).postln };
    }

    showStop { |sinkKey|
        if(logLevel > 0) { ("[MPB:stop] sink=" ++ sinkKey).postln };
    }

    showSwitch { |oldSink, newSink, current, next|
        if(logLevel > 0) {
            ("[MPB:switch] " ++ oldSink ++ " → " ++ newSink
                ++ "  current=" ++ current ++ "  next=" ++ next).postln;
        };
    }

    showMutation { |action, args, nextChain|
        if(logLevel > 0) { ("[MPB:mutate] " ++ action ++ " " ++ args ++ "  next=" ++ nextChain).postln };
    }

    showBypass { |which, key, state, chain, bypassKeys|
        if(logLevel > 0) {
            ("[MPB:bypass:" ++ which ++ "] " ++ key ++ " -> " ++ state
                ++ "  chain=" ++ chain ++ "  activeBypass=" ++ bypassKeys).postln;
        };
    }

    showReset { |current, next|
        if(logLevel > 0) { ("[MPB:reset] current=" ++ current ++ "  next=" ++ next).postln };
    }

    showChains { |current, next, bypassAKeys, bypassBKeys|
        if(logLevel > 0) {
            "MagicPedalboardNew.printChains:".postln;
            ("A: " ++ current ++ "   bypassA: " ++ bypassAKeys).postln;
            ("B: " ++ next    ++ "   bypassB: " ++ bypassBKeys).postln;
        };
    }

    showChainsDetailed { |current, next, bypassAKeys, bypassBKeys, effCurrent, effNext|
        var header, formatOne;

        if(logLevel <= 0) { ^this };

        header = { |titleString| ("==== " ++ titleString ++ " ====").postln };

        formatOne = { |titleString, listRef, bypassKeys, effective|
            var sinkKey, sourceKey, lastIndex, indexCounter, lineText;

            lastIndex = listRef.size - 1;
            sinkKey = listRef[0];
            sourceKey = listRef[lastIndex];

            header.(titleString);
            ("sink : " ++ sinkKey).postln;

            indexCounter = 1;
            if(listRef.size > 2) {
                "procs:".postln;
                listRef.copyRange(1, lastIndex - 1).do { |procKey|
                    var isBypassed, mark;
                    isBypassed = bypassKeys.includes(procKey);
                    mark = if(isBypassed) { "BYP" } { "ON " };
                    lineText = ("  [" ++ indexCounter ++ "] " ++ procKey ++ "  (" ++ mark ++ ")");
                    lineText.postln;
                    indexCounter = indexCounter + 1;
                };
            }{
                "procs: (none)".postln;
            };

            ("src  : " ++ sourceKey).postln;
            ("eff  : " ++ effective.join("  ->  ")).postln;
            "".postln;
        };

        formatOne.("CURRENT", current, bypassAKeys, effCurrent);
        formatOne.("NEXT",    next,    bypassBKeys, effNext);
    }

    showError { |message|
        ("[MPB:error] " ++ message).warn;
    }
}
/*  MagicPedalboardNew.sc  v0.3.4
    A/B pedalboard chain manager built on Ndefs.
    - Chains are Arrays of Symbols ordered [sink, …, source].
    - Uses JITLib embedding: Ndef(left) <<> Ndef(right).
    - Creates two sinks: \chainA and \chainB, and plays the current chain on init.
    - Most mutators act on the next chain; explicit current-chain bypass helpers are provided.
    - Optional display adaptor (MagicDisplay) receives notifications, including detailed chain views.
    // MD 20250912-1400
*/

MagicPedalboardNew : Object {

    // ───────────────────────────────────────────────────────────────
    // class metadata
    // ───────────────────────────────────────────────────────────────
    classvar < version;

    // ───────────────────────────────────────────────────────────────
    // instance state
    // ───────────────────────────────────────────────────────────────
    var < currentChain;      // read-only pointer
    var < nextChain;         // read-only pointer

    var chainAList;          // [\chainA, ...processors..., source]
    var chainBList;          // [\chainB, ...processors..., source]

    var bypassA;             // IdentityDictionary: key(Symbol) -> Bool
    var bypassB;             // IdentityDictionary: key(Symbol) -> Bool

    var < defaultNumChannels;
    var < defaultSource;

    // optional display adaptor (console now, GUI later)
    var < display;

    *initClass {
        version = "v0.3.4";
        ("MagicPedalboardNew " ++ version).postln;
    }

    *new { |disp = nil|
        ^super.new.init(disp)
    }

    init { |disp|
        var sinkFunc;

        display = disp;

        defaultNumChannels = 2;
        defaultSource = \ts0;

        sinkFunc = {
            var inputSignal;
            inputSignal = \in.ar(defaultNumChannels);
            inputSignal
        };

        Ndef(\chainA, sinkFunc);
        Ndef(\chainB, sinkFunc);

        chainAList = [\chainA, defaultSource];
        chainBList = [\chainB, defaultSource];

        bypassA = IdentityDictionary.new;
        bypassB = IdentityDictionary.new;

        currentChain = chainAList;
        nextChain = chainBList;

        // initial wiring + start
        this.rebuild(currentChain);
        this.rebuild(nextChain);
        Server.default.bind({ Ndef(\chainA).play(numChannels: defaultNumChannels) });

        if(display.notNil) {
            display.showInit(this, version, currentChain, nextChain);
        };

        ^this
    }

    // ───────────────────────────────────────────────────────────────
    // public API
    // ───────────────────────────────────────────────────────────────

    setDisplay { |disp|
        display = disp;
        if(display.notNil) {
            display.showInit(this, version, currentChain, nextChain);
        };
    }

    help {
        var text;
        text = String.new;
        text = text
        ++ "MagicPedalboardNew " ++ version ++ "\n"
        ++ "Chains are Arrays of Symbols ordered [sink, …, source].\n"
        ++ "On init, creates \\chainA and \\chainB and plays current.\n\n"
        ++ "Core methods (operate mostly on the *next* chain):\n"
        ++ "  printChains\n"
        ++ "  playCurrent, stopCurrent, switchChain\n"
        ++ "  add(key), addAt(key, index)\n"
        ++ "  removeAt(index), swap(indexA, indexB)\n"
        ++ "  bypass(key, state=true), bypassAt(index, state=true)\n"
        ++ "  clearChain\n"
        ++ "Current-chain bypass helpers:\n"
        ++ "  bypassCurrent(key, state=true), bypassAtCurrent(index, state=true)\n"
        ++ "Diagnostics/helpers:\n"
        ++ "  effectiveCurrent, effectiveNext, bypassKeysCurrent, bypassKeysNext, reset\n"
        ++ "Source setters:\n"
        ++ "  setSource(key) [next], setSourceCurrent(key) [current]\n";
        text.postln;
    }

    // Detailed printing routed through display if available
    printChains {
        var bypassAKeys, bypassBKeys, effA, effB;

        bypassAKeys = this.bypassKeysForListInternal(chainAList);
        bypassBKeys = this.bypassKeysForListInternal(chainBList);

        effA = this.effectiveListForInternal(chainAList);
        effB = this.effectiveListForInternal(chainBList);

        if(display.notNil and: { display.respondsTo(\showChainsDetailed) }) {
            display.showChainsDetailed(
                chainAList, chainBList,
                bypassAKeys, bypassBKeys,
                effA, effB
            );
        }{
            "— Chains —".postln;
            "MagicPedalboardNew.printChains:".postln;
            ("A: " ++ chainAList ++ (if(chainAList === currentChain) { "  (current)" } { "  (next)" })).postln;
            ("   bypassA: " ++ bypassAKeys).postln;
            ("   effA:    " ++ effA).postln;
            ("B: " ++ chainBList ++ (if(chainBList === currentChain) { "  (current)" } { "  (next)" })).postln;
            ("   bypassB: " ++ bypassBKeys).postln;
            ("   effB:    " ++ effB).postln;
            "".postln;
        };
    }

    playCurrent {
        var sinkKey;
        sinkKey = currentChain[0];
        this.rebuild(currentChain);
        Server.default.bind({ Ndef(sinkKey).play(numChannels: defaultNumChannels) });
        if(display.notNil) { display.showPlay(sinkKey) };
    }

    stopCurrent {
        var sinkKey;
        sinkKey = currentChain[0];
        Server.default.bind({ Ndef(sinkKey).stop });
        if(display.notNil) { display.showStop(sinkKey) };
    }

    switchChain {
        var tempChainRef, oldSinkKey, newSinkKey;

        oldSinkKey = currentChain[0];

        Server.default.bind({
            // stop old current sink
            Ndef(oldSinkKey).stop;

            // swap pointers
            tempChainRef = currentChain;
            currentChain = nextChain;
            nextChain = tempChainRef;

            // rebuild both without nesting binds
            this.rebuildUnbound(nextChain);
            this.rebuildUnbound(currentChain);

            // start new current sink
            newSinkKey = currentChain[0];
            Ndef(newSinkKey).play(numChannels: defaultNumChannels);
        });

        if(display.notNil) {
            display.showSwitch(oldSinkKey, currentChain[0], currentChain, nextChain);
        };
    }

	//with fade
switchChainWithFade {
    var tempChainRef, oldSinkKey, newSinkKey, fadeTime;
    fadeTime = 0.1; // seconds

    oldSinkKey = currentChain[0];
    newSinkKey = nextChain[0];

    Server.default.bind {
        // fade out old sink
        Ndef(oldSinkKey).fadeTime_(fadeTime);
        Ndef(oldSinkKey).stop;

        // swap chains
        tempChainRef = currentChain;
        currentChain = nextChain;
        nextChain = tempChainRef;

        // rebuild both chains
        this.rebuildUnbound(nextChain);
        this.rebuildUnbound(currentChain);

        // fade in new sink
        Ndef(newSinkKey).fadeTime_(fadeTime);
        Ndef(newSinkKey).play(numChannels: defaultNumChannels);
    };

    if(display.notNil) {
        display.showSwitch(oldSinkKey, currentChain[0], currentChain, nextChain);
    };
}


    // ---- next-chain mutations ------------------------------------------------

    add { | key |
        var insertIndex;
        insertIndex = nextChain.size - 1;
        this.addAt(key, insertIndex);
        if(display.notNil) { display.showMutation(\add, [key], nextChain) };
    }

    addAt { | key, index |
        var indexClamped, newList;
        indexClamped = index.clip(1, nextChain.size - 1);
        newList = nextChain.insert(indexClamped, key);
        this.setNextListInternal(newList);
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\addAt, [key, indexClamped], nextChain) };
    }

    removeAt { | index |
        var sizeNow, lastIndex, newList, removedKey;

        sizeNow = nextChain.size;
        lastIndex = sizeNow - 1;

        if(sizeNow <= 2) {
            if(display.notNil) { display.showError("removeAt refused: need at least [sink, source]") }
            { "refuse to remove: need at least [sink, source]".postln };
        }{
            if((index == 0) or: { index == lastIndex }) {
                if(display.notNil) { display.showError("removeAt refused: cannot remove sink or source") }
                { "refuse to remove sink or source".postln };
            }{
                removedKey = nextChain[index];
                newList = nextChain.copy;
                newList.removeAt(index);
                this.setNextListInternal(newList);
                this.bypassDictForListInternal(nextChain).removeAt(removedKey);
                this.rebuild(nextChain);
                if(display.notNil) { display.showMutation(\removeAt, [index, removedKey], nextChain) };
            }
        }
    }

    swap { | indexAParam, indexBParam |
        var lastIndex, indexA, indexB, newList, tempKey;

        lastIndex = nextChain.size - 1;

        indexA = indexAParam.clip(1, lastIndex - 1);
        indexB = indexBParam.clip(1, lastIndex - 1);

        if(indexA == indexB) {
            // nothing to do
        }{
            newList = nextChain.copy;
            tempKey = newList[indexA];
            newList[indexA] = newList[indexB];
            newList[indexB] = tempKey;
            this.setNextListInternal(newList);
            this.rebuild(nextChain);
            if(display.notNil) { display.showMutation(\swap, [indexA, indexB], nextChain) };
        }
    }

    clearChain {
        var sinkKey, sourceKey, newList;

        if(nextChain.size < 2) { ^this };

        sinkKey = nextChain[0];
        sourceKey = nextChain[nextChain.size - 1];

        newList = [sinkKey, sourceKey];
        this.setNextListInternal(newList);
        this.bypassDictForListInternal(nextChain).clear;
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\clearChain, [], nextChain) };
    }

    bypass { | key, state = true |
        var dict;
        dict = this.bypassDictForListInternal(nextChain);
        dict[key] = state;
        this.rebuild(nextChain);
        if(display.notNil) {
            display.showBypass(\next, key, state, nextChain, this.bypassKeysForListInternal(nextChain));
        };
    }

    bypassAt { | index, state = true |
        var lastIndex, clampedIndex, keyAtIndex;
        lastIndex = nextChain.size - 1;
        clampedIndex = index.clip(1, lastIndex - 1);
        keyAtIndex = nextChain[clampedIndex];
        this.bypass(keyAtIndex, state);
    }

    // ---- current-chain bypass ------------------------------------------------

    bypassCurrent { | key, state = true |
        var dict;
        dict = this.bypassDictForListInternal(currentChain);
        dict[key] = state;
        this.rebuild(currentChain);
        if(display.notNil) {
            display.showBypass(\current, key, state, currentChain, this.bypassKeysForListInternal(currentChain));
        };
    }

    bypassAtCurrent { | index, state = true |
        var lastIndex, clampedIndex, keyAtIndex;
        lastIndex = currentChain.size - 1;
        clampedIndex = index.clip(1, lastIndex - 1);
        keyAtIndex = currentChain[clampedIndex];
        this.bypassCurrent(keyAtIndex, state);
    }

    // ---- source setters (built-in) ------------------------------------------

    setSource { | key |
        var newList, lastIndex;
        lastIndex = nextChain.size - 1;
        newList = nextChain.copy;
        newList[lastIndex] = key;
        this.setNextListInternal(newList);
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\setSource, [key], nextChain) };
    }

    setSourceCurrent { | key |
        var newList, lastIndex;
        lastIndex = currentChain.size - 1;
        newList = currentChain.copy;
        newList[lastIndex] = key;
        if(currentChain === chainAList) {
            chainAList = newList; currentChain = chainAList;
        }{
            chainBList = newList; currentChain = chainBList;
        };
        this.rebuild(currentChain);
        if(display.notNil) { display.showMutation(\setSourceCurrent, [key], currentChain) };
    }

    // ---- diagnostics helpers -------------------------------------------------

    effectiveCurrent { ^this.effectiveListForInternal(currentChain) }
    effectiveNext    { ^this.effectiveListForInternal(nextChain) }
    bypassKeysCurrent { ^this.bypassKeysForListInternal(currentChain) }
    bypassKeysNext    { ^this.bypassKeysForListInternal(nextChain) }

    reset {
        var sinkAKey, sinkBKey;

        sinkAKey = \chainA;
        sinkBKey = \chainB;

        chainAList = [sinkAKey, defaultSource];
        chainBList = [sinkBKey, defaultSource];

        bypassA.clear;
        bypassB.clear;

        currentChain = chainAList;
        nextChain = chainBList;

        Server.default.bind({
            this.rebuildUnbound(nextChain);
            this.rebuildUnbound(currentChain);
            Ndef(sinkBKey).stop;
            Ndef(sinkAKey).play(numChannels: defaultNumChannels);
        });

        if(display.notNil) { display.showReset(currentChain, nextChain) };
    }

    // ───────────────────────────────────────────────────────────────
    // internal helpers (lowercase, no leading underscore)
    // ───────────────────────────────────────────────────────────────

    setNextListInternal { | newList |
        if(nextChain === chainAList) {
            chainAList = newList; nextChain = chainAList;
        }{
            chainBList = newList; nextChain = chainBList;
        }
    }

    bypassDictForListInternal { | listRef |
        ^if(listRef === chainAList) { bypassA } { bypassB }
    }

    bypassKeysForListInternal { | listRef |
        var dict, keysBypassed;

        dict = this.bypassDictForListInternal(listRef);
        keysBypassed = Array.new;

        dict.keysValuesDo { |key, state|
            if(state == true) { keysBypassed = keysBypassed.add(key) };
        };

        ^keysBypassed
    }

    ensureStereoInternal { | key |
        var proxyBus;
        proxyBus = Ndef(key).bus;
        if(proxyBus.isNil or: { proxyBus.rate != \audio } or: { proxyBus.numChannels != defaultNumChannels }) {
            Ndef(key).ar(defaultNumChannels);
        };
    }

    ensureServerTree {
        if(Server.default.serverRunning) {
            Server.default.initTree;
        };
    }

    effectiveListForInternal { | listRef |
        var dict, resultList, lastIndex;

        dict = this.bypassDictForListInternal(listRef);
        resultList = Array.new;
        lastIndex = listRef.size - 1;

        listRef.do { |key, indexPosition|
            var isProcessor, isBypassed;
            isProcessor = (indexPosition > 0) and: (indexPosition < lastIndex);
            isBypassed = isProcessor and: { dict[key] == true };
            if((indexPosition == 0) or: { indexPosition == lastIndex }) {
                resultList = resultList.add(key);
            }{
                if(isBypassed.not) { resultList = resultList.add(key) };
            };
        };

        ^resultList
    }

    // Public rebuild: bundles server ops
    rebuild { | listRef |
        var whichChain;
        whichChain = if(listRef === currentChain) { \current } { \next };

        Server.default.bind({
            this.rebuildUnbound(listRef);
        });

        if(display.notNil) {
            display.showRebuild(whichChain, listRef, this.effectiveListForInternal(listRef));
        };
    }

    // Internal rebuild that assumes we are already inside a server bind
    rebuildUnbound { | listRef |
        var effective, indexCounter, leftKey, rightKey, sinkKey;

        if(listRef.size < 2) { ^this };

        this.ensureServerTree;

        effective = this.effectiveListForInternal(listRef);

        effective.do { |keySymbol|
            this.ensureStereoInternal(keySymbol)
        };

        indexCounter = 0;
        while { indexCounter < (effective.size - 1) } {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        };

        sinkKey = effective[0];

        if(listRef === currentChain) {
            Ndef(sinkKey).play(numChannels: defaultNumChannels);
        }{
            Ndef(sinkKey).stop;
        };
    }
}
// Test_MagicPedalboardNew_v0_13_QA_PauseResume_GUI.scd // WORKING right at 13:41
// MD 20250912-1325

(
// Run only after the server is booted.
s.waitForBoot({

    // ─────────────────────────────────────────────────────────────
    // var-first: declare everything used in this block up front
    // ─────────────────────────────────────────────────────────────
    var preflightCleanup;
    var m, setCurrent, setNext, forceSilentBaseline;
    var qa;
    var win, infoText, noteField, btnReport, btnSubmit, btnResume;
    var say, countdown, show, snapshot, setActiveStep, pushStep, absorbPending, waitIfPaused;
    var runRoutine;
    var before, after;

    // ─────────────────────────────────────────────────────────────
    // 0) Preflight: clear old JITLib state; keep the default group
    // ─────────────────────────────────────────────────────────────
    preflightCleanup = {
        "[QA] Preflight: clearing Ndefs & ProxySpaces…".postln;

        // Stop & clear any lingering Ndefs from older sessions
        Ndef.all.keysValuesDo { |key, proxy|
            if(proxy.isPlaying) { ("[CLEAN] stop " ++ key).postln; proxy.stop };
            proxy.clear;
        };

        // Clear any ProxySpaces we can see (class may not expose .all on some builds)
        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo { |srv, ps|
                if(ps.notNil) { ("[CLEAN] ProxySpace on " ++ srv).postln; ps.clear };
            };
        };

        // If the *current* environment is a ProxySpace, pop it
        if(currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" }) {
            "[CLEAN] Pop current ProxySpace env".postln;
            currentEnvironment.pop;
        };

        // Safe server-tree reset (no s.freeAll): keep Group 1 so Ndef/JITLib can attach
        s.initTree;
        s.defaultGroup.freeAll;

        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // ─────────────────────────────────────────────────────────────
    // 1) Minimal test sources / processors
    // ─────────────────────────────────────────────────────────────
    Ndef(\ts0,   { Silent.ar(2) });
    Ndef(\tsDust,{ Dust.ar(2000) ! 2 });
    Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });
    Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });

    Ndef(\tremolo, { |rate = 4, depth = 0.9|
        var x;
        x = \in.ar(2);
        x * SinOsc.kr(rate).range(1 - depth, 1)
    });

    Ndef(\lofi, { |bits = 4, rate = 4000|
        var x;
        x = \in.ar(2);
        Decimator.ar(x, rate, bits)
    });

    Ndef(\atten, { |gain = 0.25|
        var x;
        x = \in.ar(2);
        x * gain
    });

    // ─────────────────────────────────────────────────────────────
    // 2) Pedalboard + hard silent baseline
    // ─────────────────────────────────────────────────────────────
    m = MagicPedalboardNew.new;
    m.reset;

    setCurrent = { |key|
        if(m.respondsTo(\setSourceCurrent)) { m.setSourceCurrent(key) }
        { "ERROR: setSourceCurrent missing".warn };
    };
    setNext = { |key|
        if(m.respondsTo(\setSource)) { m.setSource(key) }
        { "ERROR: setSource missing".warn };
    };

    forceSilentBaseline = {
        "[QA] Force silent baseline…".postln;
        m.reset;
        setCurrent.(\ts0);
        setNext.(\ts0);

        m.clearChain;            // clear NEXT
        m.switchChain;
        m.clearChain;            // clear previous CURRENT (now NEXT)
        m.switchChain;

        Ndef(\chainA).play(numChannels: 2);
        Ndef(\chainB).stop;

        "[QA] Baseline set. Expect: silence now.".postln;
    };
    forceSilentBaseline.();

    // ─────────────────────────────────────────────────────────────
    // 3) QA state (pause controller, steps, issues)
    // ─────────────────────────────────────────────────────────────
    qa = (
        steps: Array.new,
        issues: Array.new,
        currentStep: nil,
        pendingIssues: IdentityDictionary.new,   // stepId -> (reason:, note:)
        pauseRequested: false,
        pauseCondition: Condition.new
    );

    // ─────────────────────────────────────────────────────────────
    // 4) GUI (AppClock). Window shows PAUSED state & toggles buttons.
    // ─────────────────────────────────────────────────────────────
    win = Window("MPBNew QA – press X to pause; Enter to submit; Esc to resume",
                 Rect(100, 100, 740, 230)).front.alwaysOnTop_(true);
    infoText = StaticText(win, Rect(10, 10, 720, 44)).string_("Step: (pending)");
    noteField = TextField(win, Rect(10, 60, 720, 24)).string_("Type your note here…");

    btnReport = Button(win, Rect(10, 100, 230, 30))
        .states_([["Report Issue (Pause)", Color.white, Color.red]])
        .action_({
            qa[\pauseRequested] = true; "[QA] pause requested".postln;
            AppClock.sched(0, {
                infoText.string = "PAUSED: type a note, then Submit or Resume.";
                win.name = "MPBNew QA – PAUSED";
                btnReport.enabled = false; btnSubmit.enabled = true; btnResume.enabled = true; nil
            });
        });

    btnSubmit = Button(win, Rect(250, 100, 230, 30))
        .states_([["Submit Issue & Resume", Color.white, Color(0, 0.5, 0)]])
        .action_({
            var noteTxt, stepIdLocal, reasonTxt;
            noteTxt = noteField.string;
            reasonTxt = "user report (paused)";
            stepIdLocal = qa[\currentStep].notNil.if({ qa[\currentStep][\id] }, { "unknown-" ++ Main.elapsedTime.round(0.01) });
            qa[\pendingIssues][stepIdLocal] = (reason: reasonTxt, note: noteTxt);
            ("[QA] issue submitted for " ++ stepIdLocal).postln;
            if(noteTxt.notNil and: { noteTxt != "" }) { ("[QA] note: " ++ noteTxt).postln };
            qa[\pauseRequested] = false; qa[\pauseCondition].signal;
            AppClock.sched(0, {
                infoText.string = "Captured issue for " ++ stepIdLocal ++ ". Resuming…";
                win.name = "MPBNew QA";
                btnReport.enabled = true; btnSubmit.enabled = false; btnResume.enabled = false; nil
            });
        })
        .enabled_(false);

    btnResume = Button(win, Rect(490, 100, 230, 30))
        .states_([["Resume (No Issue)", Color.white, Color.gray]])
        .action_({
            "[QA] resume (no issue)".postln;
            qa[\pauseRequested] = false; qa[\pauseCondition].signal;
            AppClock.sched(0, {
                infoText.string = "Resuming without logging an issue…";
                win.name = "MPBNew QA";
                btnReport.enabled = true; btnSubmit.enabled = false; btnResume.enabled = false; nil
            });
        })
        .enabled_(false);

    // keyboard shortcuts
    win.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
        if(char == $x or: { char == $X }) { btnReport.action.value };
        if(keycode == 36 or: { keycode == 52 }) { btnSubmit.action.value }; // Enter / keypad Enter
        if(keycode == 53) { btnResume.action.value };                       // Esc
    };

    // ─────────────────────────────────────────────────────────────
    // 5) Helpers (SystemClock-safe)
    // ─────────────────────────────────────────────────────────────
    say = { |txt| txt.asString.postln };

    countdown = { |n = 3|
        var i;
        i = n;
        while { i > 0 } {
            waitIfPaused.();
            (i.asString ++ "...").postln;
            1.wait;  // SystemClock wait
            i = i - 1;
        };
        waitIfPaused.();
        "Now.".postln;
    };

    waitIfPaused = {
        var t0;
        if(qa[\pauseRequested]) { "[QA] waiting (paused)".postln };
        t0 = Main.elapsedTime;
        while { qa[\pauseRequested] } {
            qa[\pauseCondition].wait;   // signalled by AppClock (GUI buttons)
            if(qa[\pauseRequested] and: { Main.elapsedTime - t0 > 30 }) {
                "[QA] timeout → auto-resume".warn;
                qa[\pauseRequested] = false;
                qa[\pauseCondition].signal;
            };
        };
        if(qa[\pauseRequested].not) { "[QA] resumed".postln };
    };

    show = {
        "— Chains —".postln;
        m.printChains;
        "".postln;
    };

    snapshot = {
        (
            time: Main.elapsedTime,
            current: m.currentChain.copy,
            next: m.nextChain.copy,
            effCurrent: m.effectiveCurrent,
            effNext: m.effectiveNext,
            bypassCurrent: m.bypassKeysCurrent,
            bypassNext: m.bypassKeysNext
        )
    };

    setActiveStep = { |id, title, expected|
        qa[\currentStep] = nil;  // will set when pushing the step
        AppClock.sched(0, {
            infoText.string = "Step: " ++ id ++ " — " ++ title ++ "\nExpect: " ++ expected;
            win.name = "MPBNew QA";
            nil
        });
    };

    absorbPending = { |id, entry|
        var p;
        p = qa[\pendingIssues][id];
        if(p.notNil) {
            entry[\userFlagged] = true;
            entry[\userReason] = p[\reason];
            entry[\userNote] = p[\note];
            if(qa[\issues].includes(id).not) { qa[\issues] = qa[\issues].add(id) };
            qa[\pendingIssues].removeAt(id);
        };
    };

    pushStep = { |id, title, expected, beforeSnap, afterSnap|
        var e;
        e = (id: id, title: title, expected: expected, before: beforeSnap,
             after: afterSnap, userFlagged: false, userReason: nil, userNote: nil);
        qa[\steps] = qa[\steps].add(e);
        qa[\currentStep] = e;
        absorbPending.(id, e);
    };

    // ─────────────────────────────────────────────────────────────
    // 6) Narrative Routine (RUN ON SystemClock)
    // ─────────────────────────────────────────────────────────────
    runRoutine = Routine({

        // A) Start silent
        setActiveStep.("A1", "Start silent \\ts0 on CURRENT", "Silence");
        say.("Starting with a silent CURRENT chain. Starting in");
        countdown.(3);
        before = snapshot.();
        setCurrent.(\ts0);
        m.playCurrent;
        show.();
        say.("You should hear nothing.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("A1", "silent on CURRENT", "You should hear nothing.", before, after);

        // B) CURRENT → Dust
        setActiveStep.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
        say.("Change CURRENT source to Dust(2000). Starting in");
        countdown.(3);
        before = snapshot.();
        setCurrent.(\tsDust);
        show.();
        say.("You should hear irregular noise bursts in stereo.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("B1", "dust on CURRENT", "Irregular noise bursts", before, after);

        // C) NEXT: Saw + Tremolo → switch
        setActiveStep.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
        say.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
        say.("Setting NEXT source to Saw in");
        countdown.(2);
        before = snapshot.();
        setNext.(\tsSaw);
        m.add(\tremolo);
        show.();
        say.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
        countdown.(3);
        m.switchChain; show.();
        say.("You should hear a saw tone with strong amplitude modulation (tremolo).");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", before, after);

        // D1) Bypass tremolo
        setActiveStep.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
        say.("Bypass CURRENT tremolo. Starting in");
        countdown.(2);
        before = snapshot.();
        m.bypassCurrent(\tremolo, true); show.();
        say.("You should hear plain Saw (no tremolo).");
        waitIfPaused.(); 1.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("D1", "bypass tremolo", "Plain Saw", before, after);

        // D2) Un-bypass tremolo
        setActiveStep.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
        say.("Un-bypass CURRENT tremolo. Starting in");
        countdown.(2);
        before = snapshot.();
        m.bypassCurrent(\tremolo, false); show.();
        say.("Tremolo should be back.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("D2", "un-bypass tremolo", "Saw with tremolo", before, after);

        // E) Prepare NEXT: atten + lofi + swap → switch
        setActiveStep.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
        say.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
        say.("Adding \\atten at index 1 in");
        countdown.(2);
        before = snapshot.();
        m.addAt(\atten, 1); show.();

        say.("Adding \\lofi at index 2 in");
        countdown.(2);
        m.addAt(\lofi, 2); show.();

        say.("Swap NEXT indices 1 and 2 in");
        countdown.(2);
        m.swap(1, 2); show.();

        say.("Switch to NEXT in");
        countdown.(3);
        m.switchChain; show.();
        say.("You should hear Saw with lower level and obvious bitcrush/decimation.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", before, after);

        // F) On NEXT: remove @1, then clear
        setActiveStep.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
        say.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
        say.("Removing at index 1 on NEXT in");
        countdown.(2);
        before = snapshot.();
        m.removeAt(1); show.();
        say.("Clear NEXT back to [sink, source] in");
        countdown.(2);
        m.clearChain; show.();
        waitIfPaused.(); 1.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("F1", "remove + clear NEXT", "[sink, source]", before, after);

        // G) NEXT → ts0, then switch (silent again)
        setActiveStep.("G1", "Set NEXT source to ts0, then switch", "Silence");
        say.("Set NEXT source to \\ts0 and then switch.");
        say.("Starting in");
        countdown.(3);
        before = snapshot.();
        setNext.(\ts0);
        m.switchChain; show.();
        say.("You should now hear silence.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("G1", "switch to ts0", "Silence", before, after);

        // Done
        say.("Done. Stopping."); m.stopCurrent;
    }).play(SystemClock);   // Routine on SystemClock; GUI on AppClock
});
)
