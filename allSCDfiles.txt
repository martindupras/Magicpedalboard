// acceptanceStepsTest.scd
// v0.1
// MD 20250916

// [1] Add delay to NEXT (B while A is current)
~mpb.add(\delay);
~mpb.printChains;

// [2] Switch (A -> B) with a short fade
~mpb.switchChain(0.12);
("After switch: A.playing=" ++ Ndef(\chainA).isPlaying ++ "  B.playing=" ++ Ndef(\chainB).isPlaying).postln;
~mpb.printChains;

// [3] Bypass ON (CURRENT)
~mpb.bypassCurrent(\delay, true);
~mpb.printChains;

// [4] Bypass OFF (CURRENT)
~mpb.bypassCurrent(\delay, false);
~mpb.printChains;

// [5] Switch back (B -> A)
~mpb.switchChain(0.12);
("Final: A.playing=" ++ Ndef(\chainA).isPlaying
 ++ "  B.playing=" ++ Ndef(\chainB).isPlaying).postln;
~mpb.printChains;
// adapter_commandtree_to_magicpedalboard.scd
// v0.3.1
// MD 20250916-14:49

(

var alreadyWrapped;

~ct_knownVerbs = #[\add, \bypass, \removeAt, \swap, \clear, \setSource, \switch];
~ct_knownProcs = #[\delay, \chorus, \tremolo, \reverb, \drive, \transpose, \hex, \audio, \filters, \delays, \noise, \oscillators];
~ct_log = { arg messageString; ("[CT->MPB] " ++ messageString).postln };

~ct_normalizeTokens = { arg oscPathString;
    var rawTokens, tokens;
    rawTokens = oscPathString.asString.split($/).reject({ arg one; one.isEmpty });
    tokens = if(rawTokens.size > 0 and: { rawTokens[0].asSymbol == \commands }) {
        rawTokens.copyRange(1, rawTokens.size - 1)
    }{
        rawTokens
    };
    tokens.collect({ arg one; one.asSymbol })
};

~ct_applyOneVerb = { arg tokens, pedalboard, gui;
    var consumed, verb, params, indexCount;
    consumed = 0;
    if(tokens.isEmpty) { ^0 };
    verb = tokens[0];
    params = tokens.copyRange(1, tokens.size - 1);

    switch(verb,

/*        \add, {
            if(params.size >= 1) { pedalboard.add(params[0]); ~ct_log.("add " ++ params[0]); consumed = 2; }
            { ~ct_log.("add: missing processor"); consumed = 1; };
        },*/
\add, {
    if(params.size >= 1) {
        var procSym;
        procSym = params[0].asSymbol;
        ~ct_ensureProcessor.(procSym);        // <-- ensure Ndef exists and is stereo
        pedalboard.add(procSym);
        ~ct_log.("add " ++ procSym);
        consumed = 2;
    }{
        ~ct_log.("add: missing processor"); consumed = 1;
    };
},

		\bypass, {
            if(params.size >= 2) {
                var procSym, stateBool;
                procSym = params[0];
                stateBool = (params[1] == \on);
                pedalboard.bypass(procSym, stateBool);
                ~ct_log.("bypass " ++ procSym ++ " -> " ++ stateBool);
                consumed = 3;
            }{ ~ct_log.("bypass: need proc and on/off"); consumed = 1; };
        },
        \removeAt, {
            if(params.size >= 1) {
                var indexInteger;
                indexInteger = params[0].asString.asInteger;
                pedalboard.removeAt(indexInteger);
                ~ct_log.("removeAt " ++ indexInteger);
                consumed = 2;
            }{ ~ct_log.("removeAt: need index"); consumed = 1; };
        },
        \swap, {
            if(params.size >= 2) {
                var aIndex, bIndex;
                aIndex = params[0].asString.asInteger;
                bIndex = params[1].asString.asInteger;
                pedalboard.swap(aIndex, bIndex);
                ~ct_log.("swap " ++ aIndex ++ " <-> " ++ bIndex);
                consumed = 3;
            }{ ~ct_log.("swap: need two indices"); consumed = 1; };
        },
        \clear, { pedalboard.clearChain; ~ct_log.("clear NEXT"); consumed = 1; },
        \setSource, {
            if(params.size >= 1) { pedalboard.setSource(params[0]); ~ct_log.("setSource " ++ params[0]); consumed = 2; }
            { ~ct_log.("setSource: missing symbol"); consumed = 1; };
        },
        \switch, { pedalboard.switchChain(0.12); ~ct_log.("switch crossfade"); consumed = 1; },
        {
            if(~ct_knownProcs.includes(verb)) {
                pedalboard.add(verb); ~ct_log.("add (fallback) " ++ verb); consumed = 1;
            }{ ~ct_log.("unknown verb: " ++ verb); consumed = 1; };
        }
    );
    consumed
};

~ct_applyOSCPathToMPB = { arg oscPathString, pedalboard, gui;
    var tokens, tokenIndex, consumedNow, appliedCount, tailTokens;
    tokens = ~ct_normalizeTokens.(oscPathString);
    if(tokens.isEmpty) { ~ct_log.("empty OSC path"); ^false };
    ~ct_log.("path=" ++ oscPathString ++ "  tokens=" ++ tokens);
    tokenIndex = 0; appliedCount = 0;
    while({ tokenIndex < tokens.size }, {
        tailTokens = tokens.copyRange(tokenIndex, tokens.size - 1);
        consumedNow = ~ct_applyOneVerb.(tailTokens, pedalboard, gui);
        if(consumedNow <= 0) { consumedNow = 1 };
        tokenIndex = tokenIndex + consumedNow;
        appliedCount = appliedCount + 1;
    });
    appliedCount > 0
};

~ct_applyQueueToMPBFromCM = { arg commandManager, pedalboard, gui;
    var oscPathString, listSnapshot;
    listSnapshot = commandManager.midiManager.queue.commandList;
    ~ct_log.("queue snapshot: " ++ listSnapshot);
    oscPathString = commandManager.midiManager.queue.exportAsOSCPath;
    ~ct_log.("exported path: " ++ oscPathString);
    ~ct_applyOSCPathToMPB.(oscPathString, pedalboard, gui);
    commandManager.midiManager.queue.clear;
    true
};

~ct_sendAndApply = { arg commandManager, pedalboard, gui;
    ~ct_applyQueueToMPBFromCM.(commandManager, pedalboard, gui);
};



// 0) Capture the original adapter exactly once so we can delegate non-switch paths safely.
alreadyWrapped = (~ct_applyOSCPathToMPB_raw.notNil);
if(alreadyWrapped.not) {
    ~ct_applyOSCPathToMPB_raw = ~ct_applyOSCPathToMPB;
};

// 1) Helper: guard NEXT tail before switch, then audit after fade and recover if needed.

~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal, myGen;

    // initialize state vars once
    if(~ct_switchBusy.isNil) { ~ct_switchBusy = false };
    if(~ct_switchGen.isNil)  { ~ct_switchGen  = 0     };

    // prevent overlapping switches (re-entrant safe)
    if(~ct_switchBusy == true) {
        "[CT->MPB] switch ignored (busy)".postln;
        ^nil;
    };

    ~ct_switchBusy = true;
    ~ct_switchGen  = ~ct_switchGen + 1;
    myGen          = ~ct_switchGen;

    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last    = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            // Use the original adapter to avoid wrapping recursion
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    auditAndFix = {
        var a, b;
        // ignore stale audits from older generations
        if(~ct_switchGen != myGen) { ^nil };

        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;

        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

        // release busy flag only after our generation’s audit runs
        ~ct_switchBusy = false;
    };

    fadeLocal = fade ? 0.12;

    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);

    // schedule audit a bit after the fade completes; protect with generation check
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};


/*~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal;

    // Ensure NEXT ends with an audible source before switching.
    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    // After the crossfade, check A/B; if both false, make CURRENT audible and re-enforce Option A.
    auditAndFix = {
        var a, b;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    };

    fadeLocal = fade ? 0.12;
    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};*/

// 2) Wrapper adapter: intercept ONLY "/switch"; delegate all other paths to the original.
~ct_applyOSCPathToMPB = { arg path, mpb, gui;
    var p, f;
    p = path.asString;
    if(p == "/switch") {
        f = 0.12; // keep your usual fade; adjust if you use a different default
        ~ct_switchWithRecovery.(mpb, gui, f);
    }{
        ~ct_applyOSCPathToMPB_raw.(p, mpb, gui);
    };
};


~ct_ensureProcessor = { arg keySym;
    var k;
    k = keySym.asSymbol;

    Server.default.bind({
        var defineDelay, defineBypass, defineIdentity;

        defineIdentity = {
            var make;
            make = {
                // pass-through “processor” that keeps stereo and \in.ar(2)
                // used as a safe fallback for unknown keys
                Ndef(k, { var sig; sig = \in.ar(2); sig });
                Ndef(k).ar(2);
            };
            if(Ndef(k).source.isNil) { make.value } { Ndef(k).ar(2) };
        };

        defineDelay = {
            var make;
            make = {
                // simple stereo delay: read from \in.ar(2) → short delay → mix
                Ndef(\delay, {
                    var sig, del, time, fb, mix;
                    sig  = \in.ar(2);
                    time = 0.25;   // s
                    fb   = 0.25;
                    mix  = 0.5;
                    del  = DelayC.ar(sig + (LocalIn.ar(2) * fb), 1.0, time);
                    LocalOut.ar(del);
                    XFade2.ar(sig, del, (mix * 2 - 1).clip(-1, 1))
                });
                Ndef(\delay).ar(2);
            };
            if(Ndef(\delay).source.isNil) { make.value } { Ndef(\delay).ar(2) };
        };

        defineBypass = {
            // A named pass-through “processor” you might use in test chains
            var make;
            make = {
                Ndef(\bypass, { \in.ar(2) });
                Ndef(\bypass).ar(2);
            };
            if(Ndef(\bypass).source.isNil) { make.value } { Ndef(\bypass).ar(2) };
        };

        // choose per key
        if(k == \delay) { defineDelay.value }
        { if(k == \bypass) { defineBypass.value } { defineIdentity.value } };
    });
};


)
// audibleSanity.scd
// v0.2
// MD 20250916

(
// --- A) Boot and define an internal source (stereo) ---
var ensureAudio, defineTestSource, overrideTs0, ensureGuiAndPedalboard, startCurrent, verify;

ensureAudio = {
    Server.default.boot;
};

defineTestSource = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);
    });
};

// --- B) Force ts0 to be internal (NOT SoundIn) for all tests today ---
overrideTs0 = {
    Server.default.bind({
        Ndef(\ts0, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.0);
            seq  = Dseq([196, 246.94, 329.63, 261.63, 329.63, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.40);
            tone = Pulse.ar(f, 0.5) * env * 0.20;
            panPos = LFTri.kr(0.1).linlin(-1, 1, -0.5, 0.5);
            Pan2.ar(tone, panPos)
        });
        Ndef(\ts0).ar(2);
    });
};

// --- C) GUI + Pedalboard, sinks ar(2), meters on ---
ensureGuiAndPedalboard = {
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };

    Server.default.bind({
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });

    // toggle meters cleanly once (your enableMeters now guards for audio-rate + server)
    ~gui.enableMeters(false);
    ~gui.enableMeters(true);
};

// --- D) Set CURRENT source to internal generator and play ---
startCurrent = {
    ~mpb.setSourceCurrent(\testmelody); // generated source
    ~mpb.playCurrent;
};

// --- E) Verify status ---
verify = {
    ~mpb.printChains;
    ("[sanity] chainA.isPlaying=% chainB.isPlaying=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
};

ensureAudio.value;
defineTestSource.value;
overrideTs0.value;
ensureGuiAndPedalboard.value;
startCurrent.value;
verify.value;
)
// bootstrap_audio_and_fx_min.scd
// v0.1

(
Server.default.boot;
Server.default.bind({
    // Musical test source (stereo) – guaranteed audibility
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f    = Demand.kr(trig, 0, seq);
        var env  = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
        Pan2.ar(tone, pan)
    });
    Ndef(\testmelody).ar(2);

    // Minimal \delay (stereo) – matches your style using \in.ar
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig    = \in.ar(2);
        var delayed= CombC.ar(sig, 2.0, time.clip(0.01, 2.0),
                              time * (fb.clip(0.0, 0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\delay).ar(2);
});
)
// CT_SafeSmoke_NoDupes.scd
// v0.1.1
// MD 2025-09-18 11:30 BST

// Purpose:
// - Safe CommandTree-mimic smoke: add exactly one \delay to NEXT, ensure NEXT source is \testmelody,
//   then switch once and verify exclusivity with audio.
// Style:
// - tilde vars; var-first in functions/closures; lowercase names; no server.sync;
// - server ops inside Server.default.bind only when creating/updating Ndefs.

(
var log, countKey, assertOnce, printChainsShort, ensureAdapterOnce, ensureSource;
log = { arg s; ("[CT] " ++ s).postln };
countKey = { arg array, key; var c=0; array.do({ arg k; if(k == key) { c = c + 1 } }); c };
assertOnce = { arg list, key, label;
    var n; n = countKey.(list, key);
    ("[ASSERT] " ++ label ++ " — '" ++ key.asString ++ "' count=" ++ n).postln;
    if(n != 1) { ("[ASSERT] expected exactly 1; got " ++ n).warn };
};
printChainsShort = {
    var cur = ~mpb.effectiveCurrent, nxt = ~mpb.effectiveNext;
    ("[CHAINS] CURRENT=" ++ cur).postln;
    ("[CHAINS] NEXT   =" ++ nxt).postln;
};
ensureAdapterOnce = {
    if(~ct_applyOSCPathToMPB.isNil) {
        "adapter_commandtree_to_magicpedalboard.scd".loadRelative;
        log.("adapter loaded");
    }{
        log.("adapter already present");
    };
};
ensureSource = {
    // Ensure \testmelody exists (stereo). Cheap and idempotent.
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig = Impulse.kr(3.2);
                var seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                var f = Demand.kr(trig, 0, seq);
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
    });
};

// --- run the safe smoke ---
ensureAdapterOnce.();
ensureSource.();

// 0) Baseline visibility
~mpb.printChains;

// 1) Clean NEXT
~mpb.clearChain;
~mpb.printChains;

// 2) Add exactly one delay to NEXT via adapter
~ct_applyOSCPathToMPB.("/add/delay", ~mpb, ~gui);

// 3) Ensure NEXT source is audible BEFORE switching  <<—— added fix
~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);

// Inspect NEXT; assert only one 'delay'
printChainsShort.();
assertOnce.(~mpb.effectiveNext, \delay, "after /add/delay + /setSource/testmelody");


//fix
~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);

// 4) Switch once with a short fade; CURRENT should now include \delay and end with \testmelody
~mpb.switchChain(0.12);

// 5) Post-switch checks
AppClock.sched(0.40, {
    printChainsShort.();
    ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    nil
});
)
// CT_TokenQueue_Manual_Milestone.scd
// v0.1.1
// MD 2025-09-18 15:19 BST

// Purpose:
// - Prove that MagicPedalboardNew responds to CommandTree-like *tokens* today,
//   without any Routine/Task runners (no chance of resume errors).
// - Steps: ensure sources (idempotent) -> apply tokens in order -> single tail verify.
// Style:
// - var-first in every function/closure; lowercase names; no server.sync;
// - server ops inside Server.default.bind only where needed; GUI on AppClock.

(
var log, ensureSources, guardSwitchAudible, applyPath, verifyTail, ok;

log = { arg s; var t; t = "[TOKENS] " ++ s; t.postln };

// quick guards
ok = (~mpb.isNil.not) and: { ~gui.isNil.not } and: { ~ct_applyOSCPathToMPB.notNil };
if(ok.not) {
    "[TOKENS] Missing ~mpb/~gui or adapter. Run StartHere... and adapter_*.scd first.".warn;
    ^nil;
};

// define generated sources if needed (no SoundIn)
ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) });  Ndef(\ts0).ar(2);
    });
};

// ensure NEXT isn’t silent before switching
guardSwitchAudible = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    if(last == \ts0) {
        log.("guard: NEXT tail \\ts0 -> injecting /setSource/testmelody before /switch");
        ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
    };
};

// tiny wrapper around your adapter path applier (for logging)
applyPath = { arg path;
    var p;
    p = path;
    log.("apply -> " ++ p);
    ~ct_applyOSCPathToMPB.(p, ~mpb, ~gui);
};

// verify once after fades
verifyTail = {
    AppClock.sched(0.8, {
        ("[PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        ~mpb.printChains;
        nil
    });
};

// ---- run steps synchronously (no Routine/Task) ----
ensureSources.();

// 1) Make both chains end with \testmelody once (idempotent), and keep Option A:
if(~mpb.effectiveCurrent.last != \testmelody) { ~mpb.setSourceCurrent(\testmelody) };
if(~mpb.effectiveNext   .last != \testmelody) { ~mpb.setSource(\testmelody) };
~mpb.enforceExclusiveCurrentOptionA(0.1);

// 2) Mimic CommandTree tokens via canonical adapter paths:

// ["insert","delay"]  -> "/add/delay"  (applies to NEXT)
applyPath.("/add/delay");

// ["switch"] -> "/switch"  (guard ensures audible NEXT)
guardSwitchAudible.();
applyPath.("/switch");

// ["bypass","delay","on"]  -> "/bypass/delay/on"  (acts on NEXT chain in your adapter semantics)
applyPath.("/bypass/delay/on");

// ["bypass","delay","off"] -> "/bypass/delay/off"
applyPath.("/bypass/delay/off");

// ["switch"] -> "/switch" (again)
guardSwitchAudible.();
applyPath.("/switch");

// 3) One final verification print (PLAY flags + chains)
verifyTail.();
)
// CT_TokenQueue_Milestone_ClockChain.scd
// v0.3.0
// MD 2025-09-18 15:08 BST

// Purpose:
// - Demonstrate (audibly & with logs) that MagicPedalboardNew responds to CommandTree-like
//   *token* queues today, sequenced without Routine/Task (AppClock-only, chain scheduling).
// - Flow: ensure sources -> load adapter via absolute path -> prime sources -> token playlist -> verify.
// Style:
// - var-first in every function/closure; lowercase names; no server.sync;
// - all server ops inside Server.default.bind; GUI ops on AppClock;
// - NodeProxy connections remain inside class rebuilds using the exact <<> operator.

(
var here, loadLocal, log, need, ensureSources, tokensToPath, isNextSilent, guardSwitchAudible;
var applyOneTokens, startClockChain, stopClockChain, verifyAtEnd, startDemo;
var playlist, gap, gen;

// --- path helper: load sibling files from this script's folder ---
here = PathName(thisProcess.nowExecutingPath).pathOnly;
loadLocal = { arg leafName;
    var full;
    full = here +/+ leafName;
    full.load;
};

// --- logging helper ---
log = { arg s;
    var str;
    str = "[TOKENS] " ++ s;
    str.postln;
};

// --- precondition guard (requires bring-up so ~mpb / ~gui exist) ---
need = {
    var ok;
    ok = (~mpb.isNil.not) and: { ~gui.isNil.not };
    if(ok.not) {
        "[TOKENS] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
    };
    ok
};

// --- ensure generated sources exist (no SoundIn) ---
ensureSources = {
    var define;
    define = {
        var made;
        made = false;
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
            made = true;
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) });  Ndef(\ts0).ar(2);
        made
    };
    Server.default.bind({ define.value; });
};

// --- load adapter robustly (absolute path) ---
if(~ct_applyOSCPathToMPB.isNil) {
    loadLocal.value("adapter_CommandTree_to_MagicPedalboard.scd");
    log.("adapter loaded");
} {
    log.("adapter already present");
};

// --- token -> canonical path mapping (what the adapter expects) ---
tokensToPath = { arg tokensIn;
    var tokens, verb, args, result, onOff;
    tokens = tokensIn.collect({ arg t; t.asString });
    if(tokens.size <= 0) { ^nil };
    verb = tokens[0].toLower;
    args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
    result = nil;

    if(verb == "insert" or: { verb == "add" }) {
        if(args.size >= 1) { result = "/add/" ++ args[0] };
    }{
        if(verb == "bypass") {
            onOff = if(args.size >= 2) { args[1].toLower } { "on" };
            onOff = if(#["on","off","true","false","1","0"].includes(onOff)) {
                if((onOff == "true") or: { onOff == "1" }) { "on" } { onOff }
            } { "on" };
            if(args.size >= 1) { result = "/bypass/" ++ args[0] ++ "/" ++ onOff };
        }{
            if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                if(args.size >= 1) { result = "/setSource/" ++ args[0] };
            }{
                if(verb == "removeat") {
                    if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                }{
                    if(verb == "swap") {
                        if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                    }{
                        if(verb == "switch" or: { verb == "commit" }) {
                            result = "/switch";
                        }{
                            result = nil;
                        };
                    };
                };
            };
        };
    };
    ^result
};

// --- guard so /switch never lands on a silent NEXT (\ts0 tail) ---
isNextSilent = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    ^(last == \ts0)
};

guardSwitchAudible = {
    var needed;
    needed = isNextSilent.value;
    if(needed) {
        log.("NEXT ends with \\ts0; injecting /setSource/testmelody before /switch");
        ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
    };
};

// --- apply one token step via the adapter ---
applyOneTokens = { arg tokens;
    var path;
    path = tokensToPath.value(tokens);
    if(path.isNil) {
        log.("unmapped tokens: " ++ tokens.asString);
        ^nil;
    };
    if(path == "/switch") { guardSwitchAudible.value };
    log.("apply " ++ tokens.asString ++ "  -> " ++ path);
    ~ct_applyOSCPathToMPB.(path, ~mpb, ~gui);
};

// --- STOP any previous chain by bumping a generation counter ---
stopClockChain = {
    var old;
    old = ~ctq_gen ? 0;
    ~ctq_gen = old + 1;
    log.("chain stopped (gen=" ++ ~ctq_gen ++ ")");
};

// --- Start a playlist using AppClock chaining; no Routine/Task involved ---
startClockChain = { arg listOfTokenLists, gapSeconds = 0.6;
    var startGen, total, stepFn, scheduleNext, index;

    // bump generation to cancel older scheduled callbacks
    stopClockChain.value;

    startGen = ~ctq_gen;
    total = listOfTokenLists.size;
    index = 0;

    stepFn = {
        var tokens, stillMine;
        tokens = listOfTokenLists[index];
        stillMine = (~ctq_gen == startGen);
        if(stillMine.not) { ^nil }; // cancelled

        applyOneTokens.value(tokens);

        index = index + 1;
        if(index < total) {
            scheduleNext.value;
        }{
            log.("done.");
        };
    };

    scheduleNext = {
        var delay;
        delay = gapSeconds ? 0.6;
        AppClock.sched(delay, {
            var stillMine;
            stillMine = (~ctq_gen == startGen);
            if(stillMine) { stepFn.value } { nil };
        });
    };

    // kick off immediately
    AppClock.sched(0.0, {
        var stillMine;
        stillMine = (~ctq_gen == startGen);
        if(stillMine) { stepFn.value } { nil };
    });

    ^startGen
};

// --- verify tail ---
verifyAtEnd = {
    var a, b;
    a = Ndef(\chainA).isPlaying;
    b = Ndef(\chainB).isPlaying;
    ("[PLAY] A=% B=%".format(a, b)).postln;
    ~mpb.printChains;
};

// --- end-to-end run ---
startDemo = {
    var ok, runGen, tailDelay;
    ok = need.value;
    if(ok.not) { ^nil };

    ensureSources.value;

    // For today: both chains end with \testmelody; NEXT remains silent at sink (Option A).
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);

    // Example playlist
    playlist = [
        ["insert","delay"],
        ["switch"],
        ["bypass","delay","on"],
        ["bypass","delay","off"],
        ["switch"]
    ];
    gap = 0.60;

    runGen = startClockChain.value(playlist, gap);

    // verify near the end; computed tail = steps * gap + small margin
    tailDelay = playlist.size * gap + 0.9;
    AppClock.sched(tailDelay, {
        var stillMine;
        stillMine = (~ctq_gen == runGen);
        if(stillMine) { verifyAtEnd.value };
        nil
    });
};

// --- go ---
startDemo.value;
)
// CT_TokenQueueHarness.scd
// v0.1.1
// MD 2025-09-18 13:56 BST

/*
Purpose
- Minimal harness that accepts CommandTree-like token arrays (e.g. ["insert","delay"])
  and maps them to canonical OSC-style paths understood by your existing adapter
  (~ct_applyOSCPathToMPB). Adds a guard so "/switch" never lands on a silent NEXT.

Style
- tilde vars allowed at top level.
- var-first in every function/closure; lowercase method names.
- no server.sync; all server ops inside Server.default.bind.
- This file does not manipulate Ndefs directly; MagicPedalboardNew handles audio and <<>.
*/

(
// Public factory: ~ctq_makeHarness.(mpb, gui, secondsBetween)
// Returns an IdentityDictionary with keys:
//  - \applyOneTokens : { |tokens| ... }         // tokens = ["insert","delay"] etc.
//  - \runPlaylist    : { |listOfTokenLists, gapSeconds| ... }
//  - \tokensToPath   : { |tokens| ... }         // mapping only
//  - \stop           : { ... }                  // stop current run (if any)

var makeHarness;
makeHarness = { arg mpb, gui, secondsBetween = 0.5;
    var state, log, ensureAdapter, tokensToPath, isNextSilent, guardSwitchAudible;
    var applyOneTokens, runPlaylist, stop, runner;

    log = { arg s;
        var msg;
        msg = "[CTQ] " ++ s;
        msg.postln;
    };

    ensureAdapter = {
        var loadedAlready;
        loadedAlready = (~ct_applyOSCPathToMPB.notNil);
        if(loadedAlready.not) {
            "adapter_CommandTree_to_MagicPedalboard.scd".loadRelative;
            log.("adapter loaded");
        }{
            log.("adapter already present");
        };
    };

    tokensToPath = { arg tokensIn;
        var tokens, verb, args, result, lowerOnOff;
        tokens = tokensIn.collect({ arg t; t.asString });
        if(tokens.size <= 0) { ^nil };
        verb = tokens[0].toLower;
        args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
        result = nil;

        if(verb == "insert" or: { verb == "add" }) {
            if(args.size >= 1) { result = "/add/" ++ args[0] };
        }{
            if(verb == "bypass") {
                if(args.size >= 1) {
                    lowerOnOff = if(args.size >= 2) { args[1].toLower } { "on" };
                    lowerOnOff = (["on","off","true","false","1","0"].includes(lowerOnOff)).if({
                        if((lowerOnOff == "true") or: { lowerOnOff == "1" }) { "on" } { lowerOnOff }
                    },{
                        "on"
                    });
                    result = "/bypass/" ++ args[0] ++ "/" ++ lowerOnOff;
                };
            }{
                if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                    if(args.size >= 1) { result = "/setSource/" ++ args[0] };
                }{
                    if(verb == "switch" or: { verb == "commit" }) {
                        result = "/switch";
                    }{
                        if(verb == "removeat") {
                            if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                        }{
                            if(verb == "swap") {
                                if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                            }{
                                result = nil;
                            };
                        };
                    };
                };
            };
        };
        ^result;
    };

    isNextSilent = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last = effNext[effNext.size - 1];
        ^(last == \ts0);
    };

    guardSwitchAudible = {
        var needed;
        needed = isNextSilent.();
        if(needed) {
            log.("NEXT ends with \\ts0; injecting /setSource/testmelody before /switch");
            ~ct_applyOSCPathToMPB.("/setSource/testmelody", mpb, gui);
        };
    };

    applyOneTokens = { arg tokens;
        var path;
        path = tokensToPath.(tokens);
        if(path.isNil) {
            log.("unmapped tokens: " ++ tokens.asString);
            ^nil;
        };
        if(path == "/switch") { guardSwitchAudible.() };
        ~ct_applyOSCPathToMPB.(path, mpb, gui);
    };

    runPlaylist = { arg listOfTokenLists, gapSeconds;
        var gapLocal, routineLocal;
        gapLocal = gapSeconds ? secondsBetween;
        routineLocal = Routine({
            var i, step;
            i = 0;
            while({ i < listOfTokenLists.size }, {
                step = listOfTokenLists[i];
                log.("apply " ++ step.asString);
                applyOneTokens.(step);
                gapLocal.wait;
                i = i + 1;
            });
            log.("done.");
        });
        runner = routineLocal.play(AppClock);
        ^runner;
    };

    stop = {
        if(runner.notNil) { runner.stop; runner = nil };
        log.("stopped.");
    };

    ensureAdapter.();
    state = IdentityDictionary[
        \applyOneTokens -> applyOneTokens,
        \runPlaylist    -> runPlaylist,
        \tokensToPath   -> tokensToPath,
        \stop           -> stop
    ];
    ^state;
};

~ctq_makeHarness = makeHarness;
)
// CTQ_HardStop_All_Runners.scd
// v0.1.1
// MD 2025-09-18 15:18 BST

// Purpose:
// - Stop any leftover Routine/Task and cancel any pending AppClock chain (generation bump).
// Style:
// - var-first; lowercase; no server.sync.

(
var hadRunner, hadTask, oldGen;
hadRunner = (~ctq_runner.notNil) and: { ~ctq_runner.isPlaying };
hadTask   = (~ctq_task.notNil)   and: { ~ctq_task.isPlaying };

if(hadRunner) { ~ctq_runner.stop };
if(hadTask)   { ~ctq_task.stop };

~ctq_runner = nil;
~ctq_task   = nil;

oldGen = ~ctq_gen ? 0;
~ctq_gen = oldGen + 1;

("[TOKENS] HARD STOP — runner=% task=% gen=%"
    .format(hadRunner, hadTask, ~ctq_gen)).postln;
)
// CTQ_MinHarness_Inline.scd
// v0.1.0
// MD 2025-09-18 14:05 BST

/*Purpose
- Minimal, reliable inline harness to drive MagicPedalboardNew from CommandTree-like token queues
  without relying on a returned dictionary. Good for today's milestone demo.
Style
- tilde vars; var-first in every function/closure; lowercase method names; no server.sync;
  GUI on AppClock; Ndef connections happen inside class code with exact <<> operator.*/


(
// 0) Preconditions and adapter
var need;

need = {
    if(~mpb.isNil or: { ~gui.isNil }) {
        "[CTQ] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
        ^false
    }; ^true
};

if(need.().not) { ^nil };

// load adapter once (defines ~ct_applyOSCPathToMPB)
if(~ct_applyOSCPathToMPB.isNil) {
    "adapter_CommandTree_to_MagicPedalboard.scd".loadRelative;
    "[CTQ] adapter loaded".postln;
} {
    "[CTQ] adapter already present".postln;
};

// 1) Token → path mapper (safe subset for today)
~ctq_tokensToPath = { arg tokensIn;
    var tokens, verb, args, lowerOnOff, result;
    tokens = tokensIn.collect({ arg t; t.asString });
    if(tokens.size <= 0) { ^nil };
    verb = tokens[0].toLower;
    args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
    result = nil;

    if(verb == "insert" or: { verb == "add" }) {
        if(args.size >= 1) { result = "/add/" ++ args[0] };
    } {
        if(verb == "bypass") {
            if(args.size >= 1) {
                lowerOnOff = if(args.size >= 2) { args[1].toLower } { "on" };
                lowerOnOff = (["on","off","true","false","1","0"].includes(lowerOnOff)).if({
                    if((lowerOnOff == "true") or: { lowerOnOff == "1" }) { "on" } { lowerOnOff }
                }, { "on" });
                result = "/bypass/" ++ args[0] ++ "/" ++ lowerOnOff;
            };
        } {
            if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                if(args.size >= 1) { result = "/setSource/" ++ args[0] };
            } {
                if(verb == "switch" or: { verb == "commit" }) {
                    result = "/switch";
                } {
                    if(verb == "removeat") {
                        if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                    } {
                        if(verb == "swap") {
                            if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                        } {
                            result = nil; // unmapped today
                        };
                    };
                };
            };
        };
    };
    ^result;
};

// 2) Guard so /switch never lands on \ts0
~ctq_guardSwitchAudible = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    if(last == \ts0) {
        "[CTQ] NEXT ends with \\ts0; injecting /setSource/testmelody before /switch".postln;
        ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
    };
};

// 3) Apply a single token array
~ctq_applyOneTokens = { arg tokens;
    var path;
    path = ~ctq_tokensToPath.(tokens);
    if(path.isNil) {
        ("[CTQ] unmapped tokens: " ++ tokens.asString).postln; ^nil
    };
    if(path == "/switch") { ~ctq_guardSwitchAudible.() };
    ("[CTQ] apply " ++ tokens.asString ++ " -> " ++ path).postln;
    ~ct_applyOSCPathToMPB.(path, ~mpb, ~gui);
};

// 4) Run a playlist of token arrays with a gap (Routine on AppClock)
~ctq_runPlaylist = { arg listOfTokenLists, gapSeconds = 0.6;
    var routineLocal, gap;
    gap = gapSeconds ? 0.6;
    routineLocal = Routine({
        var i;
        i = 0;
        while({ i < listOfTokenLists.size }, {
            ~ctq_applyOneTokens.( listOfTokenLists[i] );
            gap.wait;
            i = i + 1;
        });
        "[CTQ] done.".postln;
    });
    routineLocal.play(AppClock);
    ^routineLocal
};

// 5) Quick prime (today we want audible switches using \testmelody)
~ctq_primeSources = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    ~mpb.printChains;
    AppClock.sched(0.25, {
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

"[CTQ] inline harness ready".postln;
)
// demo_apply_after_fix.scd
// v0.1
// MD 20250916-1031

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Adapter must be present
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your JSON with payloads/verbs)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// Sequence: add delay -> switch -> bypass on -> bypass off -> switch
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)
// demo_commandtree_apply_hotfix.scd
// v0.1
// MD 20250916-1020

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Ensure adapter is loaded; if not, evaluate adapter_commandtree_to_magicpedalboard.scd
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your updated JSON with payloads)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// 1) add delay on NEXT
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch to hear delay on CURRENT
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON → OFF → final switch
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)
// demo_commandtree_apply_now.scd
// v0.2
// MD 20250916-1003

(
var ensureAudio, ensureGui, ensurePedalboard, ensureAdapter, log;

// simple logger
log = { arg messageString; ("[DEMO] " ++ messageString).postln };

// A) Audio: boot + musical internal source (stereo)
ensureAudio = {
    Server.default.boot;
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);

        // lightweight FX (safe to re-run)
        Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
            var sig = \in.ar(2);
            var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
            XFade2.ar(sig, delayed, (mix.clip(0,1) * 2 - 1))
        });
        Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
            var sig = \in.ar(2);
            var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
            DelayC.ar(sig, 0.1, mod)
        });
    });
};

// B) GUI: your runner guarantees one window + PROBE FRAME
ensureGui = {
    ~md_bootProbeScenario.();
};

// C) Pedalboard + GUI binding (reuse if present)
ensurePedalboard = {
    if(~gui.isNil) { ~gui = MagicDisplayGUI.new() };
    if(~pedalboard.isNil) { ~pedalboard = MagicPedalboardNew.new(~gui) };
    ~pedalboard.setSource(\testmelody);
    ~pedalboard.switchChain(0.12);
};

// D) Adapter presence
ensureAdapter = {
    if(~ct_sendAndApply.isNil) {
        "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
    };
};

// ---- run prep ----
ensureAudio.value;
ensureGui.value;
ensurePedalboard.value;
ensureAdapter.value;

// E) Reload CommandManager (imports updated myTree.json automatically)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// F) Drive actions via queue + SEND + adapter

// 1) add delay
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch (make it CURRENT, audible)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON, then OFF, then switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Inspect (also drives GUI detailed view)
~pedalboard.printChains;
)
// demo_commandtree_milestone.scd
// v0.1
// MD 20250916-0852

(
// ---- A) Audio source + basic FX (no server.sync, safe to re-run) ----
Server.default.boot;  // boot if not already

// Ensure an internal musical test source (stereo) as \testmelody
Server.default.bind({
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f  = Demand.kr(trig, 0, seq);
        var env = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        Pan2.ar(tone, ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6))
    });
    Ndef(\testmelody).ar(2);
});

// Optional: simple FX defaults (if not already defined elsewhere)
Server.default.bind({
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig = \in.ar(2);
        var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
        var sig = \in.ar(2);
        var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
        DelayC.ar(sig, 0.1, mod)
    });
});

// ---- B) Bring up your single GUI window (runner you already have) ----
~md_bootProbeScenario.();   // ensures one MagicDisplayGUI window + PROBE FRAME
// ---- C) Ensure pedalboard & bind GUI as display if not already done ----
~gui = ~gui ?? { MagicDisplayGUI.new() };         // class builds window on AppClock internally
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
~pedalboard.setSource(\testmelody);               // audible source
~pedalboard.switchChain(0.12);                    // fade in CURRENT

// ---- D) CommandManager (imports ~/CommandTreeSavefiles/myTree.json) ----
~cm = ~cm ?? { CommandManager.new };              // uses your importer path
// If you edited myTree.xml, convert to JSON now (uncomment):
// ~ct_convertXmlToJson.("~/myTree.xml", "~/CommandTreeSavefiles/myTree.json");
// ~cm = CommandManager.new;  // reinit to re-import
// ---- E) Demo sequence using your queue + SEND and the adapter ----
// 1) Add delay to NEXT (your current XML tokens may just be "delay"; adapter maps it to add/delay)
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) Switch to hear it (CURRENT <- NEXT)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) Bypass delay ON (then OFF), then switch again
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Optional: turn bypass OFF and switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;   // posts and drives GUI detail view
)
// demo_commandtree_preformed_queues.scd
// v0.2
// MD 20250916-1048

(
var log, makeCMIfNeeded, enqueueTokensFromPath, playlist, indexCounter, totalCount;

log = { arg msg; ("[DEMO] " ++ msg).postln };

makeCMIfNeeded = {
    if(~cm.isNil) { ~cm = CommandManager.new; log.("CommandManager created and JSON imported."); };
};

enqueueTokensFromPath = { arg cm, pathString;
    var tokens, tokenCounter, tokenTotal, one;
    // convert "/verb/arg1/arg2" into a token list on the cm queue
    tokens = pathString.asString.split($/).reject({ arg oneToken; oneToken.isEmpty }).collect({ arg s; s.asSymbol });
    cm.midiManager.queue.clear;
    tokenCounter = 0; tokenTotal = tokens.size;
    while({ tokenCounter < tokenTotal }, {
        one = tokens[tokenCounter];
        cm.midiManager.queue.enqueueCommand(one);
        tokenCounter = tokenCounter + 1;
    });
    log.("enqueued: " ++ tokens);
};

// A small playlist of fully-formed queues, like the tree would send
// (You can add "/commands/..." variants too; adapter strips the prefix.)

playlist = [
    "/setSource/testmelody",  // <— Ensure NEXT isn't Silent
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

/*playlist = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];*/

indexCounter = 0; totalCount = playlist.size;

~demo_next = {
    var path;
    makeCMIfNeeded.value;
    if(indexCounter >= totalCount) {
        log.("playlist complete.");
    }{
        path = playlist[indexCounter];
        enqueueTokensFromPath.(~cm, path);
        ~ct_sendAndApply.(~cm, ~pedalboard, ~gui);
        log.("applied: " ++ path);
        indexCounter = indexCounter + 1;
        ~pedalboard.printChains;
    };
};

~demo_restart = {
    indexCounter = 0;
    log.("playlist reset.");
};
)
// Demo_CommandTree_TokenQueues.scd
// v0.1.1
// MD 2025-09-18 13:56 BST

/*
Purpose
- Demonstrate MagicPedalboardNew responding to CommandTree-like token queues, via
  CT_TokenQueueHarness (tokens -> adapter paths -> pedalboard).

Style
- Requires that StartHere_CleanBoot_OneWindow_BringUp.scd has run (so ~mpb, ~gui exist).
- var-first; lowercase; no server.sync; server ops inside Server.default.bind; GUI on AppClock.
*/

(
var ensureSources, primeSources, gap, h, playlistA, playlistB, after;

if(~mpb.isNil or: { ~gui.isNil }) {
    "[DEMO] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
    ^nil;
};

ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

primeSources = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    ~mpb.printChains;
};

gap = 0.60;
"CT_TokenQueueHarness.scd".loadRelative;
h = ~ctq_makeHarness.(~mpb, ~gui, gap);

// Example token playlists
playlistA = [
    ["insert","delay"],
    ["switch"]
];

playlistB = [
    ["bypass","delay","on"],
    ["bypass","delay","off"],
    ["switch"]
];

ensureSources.();
primeSources.();

h[\runPlaylist].(playlistA, gap);
after = (playlistA.size * gap + 1.0).max(1.0);
AppClock.sched(after, {
    h[\runPlaylist].(playlistB, gap);
    nil
});
)
// Demo_Install_MinProcessors.scd
// v0.1.0
// MD 2025-09-18 11:58 BST

/* Purpose
   - Install a minimal, safe stereo \delay processor so chains like
     [chainX, delay, testmelody] are AUDIBLE.
   - Generated audio only; processors read from \in.ar(2); no SoundIn.
   - Idempotent; safe to re-run.

   Style
   - var-first in every function/closure; lowercase method names.
   - No server.sync; wrap server ops in Server.default.bind.
   - JITLib connections elsewhere MUST use Ndef(left) <<> Ndef(right).
*/

(
var installDelay;
installDelay = {
    Server.default.bind({
        // Simple feedback delay. Reads from \in.ar(2) per project policy.
        Ndef(\delay, {
            var inSig, maxDelay, time, fb, mix, wet;
            inSig    = \in.ar(2);              // <- policy: processors read from \in.ar(defaultNumChannels)
            maxDelay = 1.0;
            time     = (\time.kr(0.25)).clip(0.0, maxDelay);
            fb       = (\fb.kr(0.25)).clip(0.0, 0.95);
            mix      = (\mix.kr(0.35)).clip(0.0, 1.0);
            wet      = DelayC.ar(inSig + (LocalIn.ar(2) * fb), maxDelay, time);
            LocalOut.ar(wet);
            XFade2.ar(inSig, wet, (mix * 2) - 1) * 0.9
        });
        // Pin stereo/audio-rate bus shape (authoritative shape)
        Ndef(\delay).mold(2, \audio);
    });
    "[MINPROC] Installed \\delay (stereo)".postln;
};
installDelay.();
)
// Diag_BusChannel_Map.scd
// v0.1
// MD 20250917-1154
//
// Purpose: Post bus rate + channel count for every Ndef in CURRENT and NEXT
//          effective lists; helps catch mono nodes causing "2→1 wrap".
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, reportList;

log = { arg s; ("[BUS]" ++ " " ++ s).postln };

reportList = { arg label, listSyms;
    var rows;
    rows = listSyms.collect({ arg k;
        var b = Ndef(k).bus;
        var rate = (b.notNil).if({ b.rate }, { \unknown });
        var ch   = (b.notNil).if({ b.numChannels }, { -1 });
        var play = Ndef(k).isPlaying;
        [k, rate, ch, play]
    });
    (label ++ " = " ++ rows.asString).postln;
};

~mpb.printChains;  // also drives your GUI detail view
reportList.("CURRENT", ~mpb.effectiveCurrent);
reportList.("NEXT   ", ~mpb.effectiveNext);
)
// diag_dump_effective_state.scd
// v0.1
// MD 20250916

(


var aPlaying, bPlaying, line;

~mpb.printChains;

aPlaying = Ndef(\chainA).isPlaying;
bPlaying = Ndef(\chainB).isPlaying;
line = "[diag] A.isPlaying=%  B.isPlaying=%".format(aPlaying, bPlaying);
line.postln;
)
// diag_fix_current_source_now.scd
// v0.1
// MD 20250916-1030

(
var log, ensureSource;

log = { arg msg; ("[FIX] " ++ msg).postln };

// Ensure a musical internal source exists (reuse if already defined)
ensureSource = {
    Server.default.boot;
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);
    });
};

ensureSource.value;

// One GUI window (runner)
~md_bootProbeScenario.();

// Ensure GUI + Pedalboard, then set CURRENT source and start it
~gui = ~gui ?? { MagicDisplayGUI.new() };
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };

~pedalboard.reset;
~pedalboard.setSourceCurrent(\testmelody);   // <-- CURRENT, not NEXT
~pedalboard.playCurrent;                     // <-- start CURRENT so you hear it
~pedalboard.printChains;

log.("CURRENT should now be audible from \\testmelody.");
)
// diag_list_playing_ndefs.scd
// v0.1
// MD 20250916-1016

(
var names, reportRows, indexCounter, totalCount;

names = [\toneTest, \testmelody, \chainA, \chainB, \delay, \chorus];
reportRows = names.collect({ arg oneName; [oneName, Ndef(oneName).isPlaying] });

indexCounter = 0;
totalCount = reportRows.size;
while({ indexCounter < totalCount }, {
    var row;
    row = reportRows[indexCounter];
    ("[PLAY] " ++ row[0] ++ " = " ++ row[1]).postln;
    indexCounter = indexCounter + 1;
});
)
// diag_manual_chain_patch.scd
// v0.2 fixes <<>
// v0.1
// MD 20250916-1018

(
var log;

log = { arg msg; ("[DIAG] " ++ msg).postln };

Server.default.bind({
    // ensure a sink for chainA that passes its input
    Ndef(\chainA, { \in.ar(2) });

    // patch toneTest -> chainA and play chainA
    Ndef(\chainA) <<> Ndef(\toneTest);
    Ndef(\chainA).play;
});

log.("Manual patch: chainA <<> toneTest; chainA.play — you should hear steady tone now.");
)
// diag_more_state.scd
// v0.1

(
~mpb.printChains;

[
    [\testmelody,  Ndef(\testmelody).source.notNil,  Ndef(\testmelody).isPlaying],
    [\delay,       Ndef(\delay).source.notNil,       Ndef(\delay).isPlaying],
    [\chainA,      Ndef(\chainA).source.notNil,      Ndef(\chainA).isPlaying],
    [\chainB,      Ndef(\chainB).source.notNil,      Ndef(\chainB).isPlaying]
].do({ arg row;
    ("[NODE] " ++ row[0] ++ " source?=" ++ row[1] ++ " playing?=" ++ row[2]).postln;
});
)
// diag_mpb_audio_path.scd
// v0.1
// MD 20250916-1012

(
var log, ensureAudio, playDirect, patchChainManually, patchViaPedalboard;

log = { arg msg; ("[DIAG] " ++ msg).postln };

// A) Boot audio + define a clearly audible test source (stereo)
ensureAudio = {
    Server.default.boot;
    Server.default.bind({
        Ndef(\toneTest, {
            var sig;
            sig = Saw.ar([120, 180]) * 0.15; // steady tone, obvious
            sig
        });
        Ndef(\toneTest).ar(2);
    });
    log.("Audio booted and \\toneTest defined.");
};

// B) Direct play (bypass chain) — you MUST hear a steady tone
playDirect = {
    Ndef(\toneTest).play;
    log.("Direct play \\toneTest — you should hear steady tone now.");
};

// C) Manual chain patch: route \\toneTest -> \\chainA (no pedalboard API)
// Expectation: you still hear tone via \\chainA after .play
patchChainManually = {
    // ensure chainA exists
    Ndef(\chainA, { \in.ar(2) });
    Ndef(\chainA) <<> Ndef(\toneTest);
    Ndef(\chainA).play;
    log.("Manual patch: chainA <<> toneTest; chainA.play — you should still hear tone.");
};

// D) Pedalboard flow: reset -> setSource -> **playCurrent** (explicit) -> print
patchViaPedalboard = {
    ~gui = ~gui ?? { MagicDisplayGUI.new() };
    ~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
    ~pedalboard.reset;              // clean chains
    ~pedalboard.setSource(\toneTest);
    ~pedalboard.playCurrent;        // explicit start of CURRENT
    ~pedalboard.printChains;
    log.("Pedalboard: reset -> setSource toneTest -> playCurrent — you should hear tone.");
};

// --- run steps ---
ensureAudio.value;
playDirect.value;

// comment out the direct play once you confirm sound, then test the next steps:
// Ndef(\toneTest).stop;  // uncomment to stop direct play

// patchChainManually.value;  // uncomment to test manual chain route
// Ndef(\chainA).stop;        // stop manual chain when done

// patchViaPedalboard.value;  // uncomment to test pedalboard path (preferred for demo)
)
// diag_pedalboard_current_play.scd
// v0.1
// MD 20250916-1019

(
var log;

log = { arg msg; ("[DIAG] " ++ msg).postln };

// Bring up a single GUI window (your runner), then ensure pedalboard exists
~md_bootProbeScenario.();   // one window + PROBE FRAME (GUI ops on AppClock)

// Create or reuse GUI + Pedalboard
~gui = ~gui ?? { MagicDisplayGUI.new() };
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };

// Clean and start CURRENT audibly
~pedalboard.reset;
~pedalboard.setSource(\toneTest);
~pedalboard.playCurrent;    // <-- critical for immediate audibility
~pedalboard.printChains;

log.("Pedalboard: reset -> setSource toneTest -> playCurrent — you should hear steady tone now.");
)
// Diag_Probe_Sinks_A_B.scd
// v0.1
// MD 20250917-1146
//
// Purpose: Inspect both sinks safely: source object/class, playing/paused,
// monitor present? Helps detect if NEXT is still monitored or sourcing non-silent audio.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var probe;

probe = { arg key;
    var nx = Ndef(key), srcObj, srcClass, srcCode, mon, playing, paused;
    srcObj  = nx.source;
    srcClass= srcObj.class;
    srcCode = srcObj.tryPerform(\asCompileString);
    mon     = nx.monitor;
    playing = nx.isPlaying;
    paused  = nx.paused ? false;
    ("[PROBE] key=% class=% playing=% paused=% hasMonitor=%"
        .format(key, srcClass, playing, paused, mon.notNil)).postln;
    if(srcCode.notNil) {
        "[PROBE] source asCompileString:".postln;
        srcCode.postln;
    }{
        "[PROBE] (no asCompileString) printing .source:".postln;
        srcObj.postln;
    };
};

probe.(\chainA);
probe.(\chainB);
)
// diag_verify_chain_and_defs.scd
// v0.1

(
var listOne, listTwo, lastIndex, checkList, report;

if(~mpb.isNil) { "[DIAG] ~mpb is nil".warn; ^nil };

checkList = { arg label, chainList;
    var idx, last, missing;
    if(chainList.isNil) { ("[DIAG] " ++ label ++ ": chain is nil").postln; ^nil };
    last = chainList.size - 1;
    missing = Array.new;
    idx = 1; // processors are 1 .. last-1
    while({ idx < last }, {
        var key = chainList[idx];
        var hasDef = Ndef(key).source.notNil;  // <- definition present?
        if(hasDef.not) { missing = missing.add(key) };
        idx = idx + 1;
    });
    ("[DIAG] " ++ label ++ " = " ++ chainList).postln;
    if(missing.isEmpty) { "[DIAG] all processors have sources".postln }
    { ("[DIAG] missing sources for: " ++ missing).warn };
};

listOne = ~mpb.effectiveCurrent;
listTwo = ~mpb.effectiveNext;

checkList.("CURRENT", listOne);
checkList.("NEXT   ", listTwo);

"[[PLAY]] A=%  B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying).postln;
)
// editor_commandtree_add_demo_verbs.scd
// v0.3
// MD 20250916-0957

(
var jsonPath, saveFolder, savePrefix;
var ensureChildUnder, ensurePath, rootNode, commandsNode;

// paths
jsonPath   = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

// load
~tree = MDCommandTree.new;
if (~tree.importJSONFile(jsonPath)) {
    "✅ Loaded tree for editing.".postln;
} {
    "❌ Failed to load tree JSON".warn; ^nil;
};

// helpers
ensureChildUnder = { arg parentNode, childName, fretNumber;
    var existingNode, createdNode;
    existingNode = parentNode.getChildByName(childName);
    if (existingNode.notNil) {
        existingNode
    } {
        createdNode = ~tree.addNode(parentNode.id, childName, fretNumber);
        if (createdNode.isNil) { ("⚠️ addNode failed for " ++ childName).postln };
        createdNode
    }
};

ensurePath = { arg pathArray, fretArray;
    var currentNode, stepIndex, childName, fretNumber, pathSize;
    currentNode = ~tree.root;
    pathSize = pathArray.size;
    stepIndex = 0;
    while({ stepIndex < pathSize }, {
        childName = pathArray[stepIndex];
        fretNumber = fretArray[stepIndex] ? 1;
        currentNode = ensureChildUnder.(currentNode, childName, fretNumber);
        stepIndex = stepIndex + 1;
    });
    currentNode
};

// ---- add demo verbs (idempotent) ----
rootNode = ~tree.root;
commandsNode = ensureChildUnder.(rootNode, "commands", 10);

// commands/add/<proc>
ensurePath.(["commands","add","delay"],   [10,1,1]);
ensurePath.(["commands","add","chorus"],  [10,1,2]);
ensurePath.(["commands","add","reverb"],  [10,1,3]);
ensurePath.(["commands","add","tremolo"], [10,1,4]);

// commands/bypass/<proc>/<on|off>
ensurePath.(["commands","bypass","delay","on"],  [10,2,1,2]);
ensurePath.(["commands","bypass","delay","off"], [10,2,1,3]);

// commands/switch
ensurePath.(["commands","switch"], [10,3]);

// commands/setSource/<src>
ensurePath.(["commands","setSource","testmelody"], [10,4,1]);

// set payloads == names (simple, visible)
~tree.assignPayloads;
~tree.printTreePretty;

// save using custom exporter (preserves payloads in JSON)
~ct_writeJsonWithPayloads.(~tree, jsonPath, true, saveFolder, savePrefix);
)
// Enforce_ExclusiveBySilencingNext.scd
// v0.2
// MD 20250916-1714

//
// Purpose: Guarantee audible exclusivity immediately by silencing the NEXT sink’s source.
//          CURRENT remains { \in.ar(2) } and audible; NEXT is set to Silent.ar(2). This avoids
//          NodeProxy monitor tail/race issues where isPlaying may remain true on NEXT.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, getCurrentNextSinks, silenceNextSink, ensureCurrentAudible, retargetMeters, verify, sinks;

log = { arg messageString; ("[XONLY] " ++ messageString).postln; };

// Identify sink symbols for CURRENT and NEXT from ~mpb
getCurrentNextSinks = {
    if(~mpb.isNil) {
        "[XONLY] ~mpb is nil".warn;
        ^nil
    };
    ^(
        current: ~mpb.effectiveCurrent[0],   // \chainA or \chainB
        next:    ~mpb.effectiveNext[0]       // the other one
    )
};

// Replace NEXT sink source with silence; keep bus AR so meters won’t warn
silenceNextSink = { arg nextSinkSym;
    Server.default.bind({
        Ndef(nextSinkSym, { Silent.ar(2) });  // hard silence at the sink
        Ndef(nextSinkSym).ar(2);
        Ndef(nextSinkSym).fadeTime_(0.01);
        Ndef(nextSinkSym).stop;               // stop its monitor quickly (optional)
    });
    log.("NEXT " ++ nextSinkSym.asString ++ " silenced");
};

// Ensure CURRENT uses robust sink source and is playing
ensureCurrentAudible = { arg currentSinkSym;
    Server.default.bind({
        Ndef(currentSinkSym, { \in.ar(2) });
        Ndef(currentSinkSym).ar(2);
        Ndef(currentSinkSym).fadeTime_(0.05);
        if(Ndef(currentSinkSym).isPlaying.not) {
            Ndef(currentSinkSym).play(numChannels: 2);
        };
    });
    log.("CURRENT " ++ currentSinkSym.asString ++ " robust+playing");
};

// Reattach meters safely after AR guarantee
retargetMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(false);
        ~gui.enableMeters(true);
    };
};

// Post final state a moment later
verify = {
    ~mpb.printChains;
    AppClock.sched(0.25, {
        var aPlaying, bPlaying, lineText;
        aPlaying = Ndef(\chainA).isPlaying;
        bPlaying = Ndef(\chainB).isPlaying;
        lineText = "[PLAY] A=%  B=%".format(aPlaying, bPlaying);
        lineText.postln;
        nil
    });
};

// --- run ---
sinks = getCurrentNextSinks.value;
if(sinks.notNil) {
    ensureCurrentAudible.(sinks[\current]);
    silenceNextSink.(sinks[\next]);
    retargetMeters.value;
    verify.value;
};
)
// Enforce_OptionA_PauseFlagNow.scd
// v0.3
// MD 20250917-1216
//
// Purpose: Deterministic exclusivity for both audio *and* flags.
//          - mold sinks to stereo
//          - set NEXT source to Silent.ar(2)
//          - stop + pause NEXT to drop monitor flag
//          - small retry loop (max 6) with short waits
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, curSink, nextSink, tries, maxTries, waitS, dropFlag;

log = { arg s; ("[X-ENFORCE] " ++ s).postln };

if(~mpb.isNil) { "[X-ENFORCE] ~mpb is nil".warn; ^nil };

curSink  = ~mpb.currentChain[0];
nextSink = ~mpb.nextChain[0];
tries    = 0; maxTries = 6; waitS = 0.08;

log.("meters off (if GUI present)");
if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
    AppClock.sched(0.00, { ~gui.enableMeters(false); nil });
    AppClock.sched(0.05, { ~gui.enableMeters(false); nil });
};

// pin stereo + enforce Option A once
Server.default.bind({
    // shape first
    Ndef(curSink ).mold(2, \audio); Ndef(nextSink).mold(2, \audio);

    // robust CURRENT
    Ndef(curSink,  { \in.ar(2) }); Ndef(curSink ).ar(2); Ndef(curSink ).fadeTime_(0.10);
    if(Ndef(curSink).isPlaying.not) { Ndef(curSink).play(numChannels: 2) };

    // NEXT: hard silence at source + stop
    Ndef(nextSink, { Silent.ar(2) }); Ndef(nextSink).ar(2); Ndef(nextSink).fadeTime_(0.01);
    Ndef(nextSink).stop;
});

// retry loop: if NEXT still reports playing, clear->reset Silent, pause, re-check
Routine({
    var still;
    dropFlag = {
        Server.default.bind({
            Ndef(nextSink).clear(0);            // drop any lingering node
            Ndef(nextSink, { Silent.ar(2) });   // re-assert Silent source
            Ndef(nextSink).ar(2);
            Ndef(nextSink).pause;               // ensure monitor flag false
        });
    };
    while({
        still = Ndef(nextSink).isPlaying;
        (still and: { tries < maxTries })
    }, {
        tries = tries + 1;
        dropFlag.();
        waitS.wait;
    });

    // meters back on
    AppClock.sched(0.00, {
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(true) };
        ("[X-ENFORCE] [PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
}).play(SystemClock);
)
// Enforce_OptionA_Strict_KillNextMonitor.scd
// v0.1
// MD 20250917-1155
//
// Purpose: Deterministically silence NEXT and drop its monitor (pause+stop+end),
// while keeping CURRENT audible. Avoids GUI/server races by disabling meters first.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, disableMeters, getSinks, killNextHard, ensureCurrent, enableMeters, verify, sinks;

log = { arg s; ("[X-ENFORCE] " ++ s).postln };

disableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        AppClock.sched(0.0, { ~gui.enableMeters(false); nil });
        AppClock.sched(0.05, { ~gui.enableMeters(false); nil });
        log.("meters disabled");
    };
};

getSinks = {
    // Use effective lists so we match CURRENT/NEXT after any recent switch
    sinks = ( current: ~mpb.effectiveCurrent[0], next: ~mpb.effectiveNext[0] );
    log.("current=" ++ sinks[\current].asString ++ " next=" ++ sinks[\next].asString);
};

killNextHard = {
    var nextSink = sinks[\next];
    Server.default.bind({
        // Source = hard silence, stereo bus; then kill monitor with pause+stop+end
        Ndef(nextSink, { Silent.ar(2) });
        Ndef(nextSink).ar(2);
        Ndef(nextSink).fadeTime_(0.01);
        // Kill monitor by every legal means; safe even if not playing
        Ndef(nextSink).pause;
        Ndef(nextSink).stop;
        Ndef(nextSink).end(0.01);   // fades/ends any residual monitor synth
    });
    log.("NEXT " ++ nextSink.asString ++ " silenced and monitor ended");
};

ensureCurrent = {
    var cur = sinks[\current];
    Server.default.bind({
        Ndef(cur, { \in.ar(2) });
        Ndef(cur).ar(2);
        Ndef(cur).fadeTime_(0.08);
        if(Ndef(cur).isPlaying.not) { Ndef(cur).play(numChannels: 2) };
    });
    log.("CURRENT " ++ cur.asString ++ " robust+playing");
};

enableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(true);   // re-sends meter SynthDefs and guards AR buses
        log.("meters re-enabled");
    };
};

verify = {
    AppClock.sched(0.35, {
        var a = Ndef(\chainA).isPlaying;
        var b = Ndef(\chainB).isPlaying;
        ("[X-ENFORCE] [PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

// run
disableMeters.value;
getSinks.value;
killNextHard.value;
ensureCurrent.value;
enableMeters.value;
verify.value;
)
// enforceExclusiveCurrentNow.scd
// v0.2
// MD 20250916


(

var listCurrent, listNext, currentSink, nextSink, postStatus, numCh;

if(~mpb.isNil) { "[enforceExclusive] ~mpb is nil".warn; ^nil };

listCurrent = ~mpb.currentChain;
listNext    = ~mpb.nextChain;

currentSink = listCurrent[0];
nextSink    = listNext[0];

numCh = (~mpb.respondsTo(\defaultNumChannels) ? ~mpb.defaultNumChannels) ?? { 2 };

Server.default.bind({
    // Rebuild both chains without resets; wiring via <<>
    ~mpb.rebuildUnbound(listNext);     // should stop NEXT sink
    ~mpb.rebuildUnbound(listCurrent);  // should play CURRENT sink

    // Belt-and-braces: explicitly enforce state
    if(Ndef(nextSink).isPlaying) { Ndef(nextSink).stop };
    if(Ndef(currentSink).isPlaying.not) { Ndef(currentSink).play(numChannels: numCh) };
});

// Print status a short moment later (no server.sync)
postStatus = {
    AppClock.sched(0.20, {
        var aPlaying, bPlaying, line;
        aPlaying = Ndef(\chainA).isPlaying;
        bPlaying = Ndef(\chainB).isPlaying;
        line = "[status] A.playing=%  B.playing=%".format(aPlaying, bPlaying);
        line.postln;
        nil
    });
};
postStatus.();
)
// fix_chain_current_exclusive.scd
// v0.1
// MD 20250916-1103

(
var log, ensureStereo, stopSinks, connectEffectiveCurrent;

log = { arg m; ("[FIX] " ++ m).postln };

ensureStereo = { arg keySym;
    // Make sure every Ndef we will touch has a stereo bus
    Ndef(keySym).ar(2);
};

stopSinks = {
    // Stop both sinks so we can relaunch CURRENT cleanly
    if(Ndef(\chainA).isPlaying) { Ndef(\chainA).stop };
    if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
    log.("stopped sinks chainA/chainB");
};

connectEffectiveCurrent = {
    var eff, indexCounter, lastIndex, leftKey, rightKey, sinkKey;

    // Compute CURRENT effective list from your pedalboard
    eff = ~pedalboard.effectiveCurrent;

    // Ensure stereo busses for all nodes involved
    eff.do({ arg k; ensureStereo.(k) });

    // Connect pairwise using the correct JITLib operator you use in this project
    indexCounter = 0;
    lastIndex = eff.size - 1;
    while({ indexCounter < lastIndex }, {
        leftKey  = eff[indexCounter];
        rightKey = eff[indexCounter + 1];
        Server.default.bind({
            Ndef(leftKey) <<> Ndef(rightKey);
        });
        indexCounter = indexCounter + 1;
    });

    // Launch CURRENT sink only
    sinkKey = eff[0];
    Server.default.bind({
        Ndef(sinkKey).play(numChannels: 2);
    });

    log.("reconnected CURRENT: " ++ eff);
};

// --- run the steps ---
stopSinks.();
connectEffectiveCurrent.();
)
// fix_current_exclusive_now.scd
// v0.3
// MD 20250916-1132

(
// 0) Stop any direct-to-out and both sinks first (clean slate)
if(Ndef(\testmelody).isPlaying) { Ndef(\testmelody).stop; "[FIX] stopped \\testmelody direct".postln; };
if(Ndef(\chainA).isPlaying)     { Ndef(\chainA).stop;     "[FIX] stopped \\chainA".postln; };
if(Ndef(\chainB).isPlaying)     { Ndef(\chainB).stop;     "[FIX] stopped \\chainB".postln; };

// 1) Ensure stereo busses (cheap no-op if already set)
Ndef(\testmelody).ar(2);
Ndef(\chainA).ar(2);

// 2) Wire CURRENT explicitly with the correct JITLib operator you use in this project,
//    and play CURRENT only (no chainB)
Server.default.bind({
    Ndef(\chainA) <<> Ndef(\testmelody);
    Ndef(\chainA).play(numChannels: 2);
});

// 3) Quick status (target: testmelody=false, chainA=true, chainB=false)
[\testmelody, \chainA, \chainB, \delay, \chorus].do({ arg nm;
    ("[PLAY] " ++ nm ++ " = " ++ Ndef(nm).isPlaying).postln;
});
)
// Fix_ExclusiveCurrent_EnforceNow.scd
// v0.3
// MD 20250916-1700

//
// Purpose: Force “CURRENT=A playing, NEXT=B stopped” deterministically, even if a prior crossfade
//          or monitor tail keeps B reporting ‘playing’. Handles stop→pause→(last‑resort) clear+restore.
// Style:   tilde vars, var-first, lowercase names, no server.sync, Server.default.bind for server ops.

(
var log, phase1_stopWithShortFade, phase2_pauseIfStill, phase3_lastResort, startAIfNeeded, verifyFinal;

log = { arg s; ("[FIX] " ++ s).postln; };

// Phase 1: small fades, stop B (start fade-down)
phase1_stopWithShortFade = {
    Server.default.bind({
        Ndef(\chainA).fadeTime_(0.05);
        Ndef(\chainB).fadeTime_(0.01);
        Ndef(\chainB).stop;
    });
    log.("phase1: set fade A=0.05 B=0.01; B.stop");
};

// Phase 2: after short wait, pause B (hard drop of monitor) and ensure A is playing
phase2_pauseIfStill = {
    AppClock.sched(0.12, {
        Server.default.bind({
            if(Ndef(\chainB).isPlaying) { Ndef(\chainB).pause };  // kills monitor immediately
            if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
        });
        log.("phase2: B.pause (if needed), A.play (if needed)");
        nil
    });
};

// Phase 3: last resort — if B still reports playing, clear + restore robust sink source
phase3_lastResort = {
    AppClock.sched(0.26, {
        if(Ndef(\chainB).isPlaying) {
            log.("phase3: B still playing -> clear+restore sink");
            Server.default.bind({
                // Replace B’s source with robust \in.ar(2) and reassert AR bus
                Ndef(\chainB).clear(0);
                Ndef(\chainB, { \in.ar(2) });
                Ndef(\chainB).ar(2);
            });
        };
        nil
    });
};

// Safety: if A not playing after everything, start it
startAIfNeeded = {
    AppClock.sched(0.30, {
        Server.default.bind({
            if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
            // ensure B is not audible
            if(Ndef(\chainB).isPlaying) { Ndef(\chainB).pause };
        });
        nil
    });
};

// Final verification
verifyFinal = {
    AppClock.sched(0.35, {
        var a, b;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        ("[PLAY] A=%  B=%".format(a, b)).postln;
        nil
    });
};

// Run the phases
phase1_stopWithShortFade.value;
phase2_pauseIfStill.value;
phase3_lastResort.value;
startAIfNeeded.value;
verifyFinal.value;
)
// Fix_ForceStereo_And_Rebuild.scd
// v0.1
// MD 20250917-1155
//
// Purpose: Force ar(2) on every Ndef in CURRENT and NEXT effective lists,
//          then rebuild both chains (uses <<> internally in your class).
//          Lightweight, no rewiring here beyond your rebuildUnbound.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var ensureStereo, touchAll, rebuildBoth, curEff, nxtEff;

ensureStereo = { arg keySym; Ndef(keySym).ar(2) };

curEff = ~mpb.effectiveCurrent;
nxtEff = ~mpb.effectiveNext;

Server.default.bind({
    curEff.do({ arg k; ensureStereo.(k) });
    nxtEff.do({ arg k; ensureStereo.(k) });
    ~mpb.rebuildUnbound(~mpb.currentChain);  // uses Ndef(left) <<> Ndef(right)
    ~mpb.rebuildUnbound(~mpb.nextChain);
});

// Post quick status afterwards
AppClock.sched(0.25, {
    ("[PLAY] A=% B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    nil
});
)
// Fix_Now_BringUp_Recovery.scd
// v0.1
// MD 20250917-1136
//
// Purpose: Recover from early meter attach + channel wraps: disable meters,
// ensure stereo sinks, define stereo ts0 (silent), ensure testmelody, re‑enforce
// Option A exclusivity, then cleanly re‑enable meters.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, ensureServer, disableMetersNow, ensureStereoSinks, defineTs0StereoSilent,
    defineTestMelody, reassertExclusive, enableMetersClean, verify;

log = { arg s; ("[RECOVER] " ++ s).postln };

ensureServer = {
    if(Server.default.serverRunning.not, { Server.default.boot });
};

disableMetersNow = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        // do it twice on AppClock to beat any queued auto-enable
        AppClock.sched(0.0, { ~gui.enableMeters(false); nil });
        AppClock.sched(0.05, { ~gui.enableMeters(false); nil });
        log.("meters disabled");
    };
};

ensureStereoSinks = {
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) }); Ndef(\chainA).ar(2);
        Ndef(\chainB, { \in.ar(2) }); Ndef(\chainB).ar(2);
    });
    log.("sinks set to robust stereo (\\in.ar)");
};

defineTs0StereoSilent = {
    // make NEXT's default source unambiguously stereo to avoid 2→1 wraps
    Server.default.bind({
        Ndef(\ts0, { Silent.ar(2) });
        Ndef(\ts0).ar(2);
    });
    log.("\\ts0 defined as stereo Silent");
};

defineTestMelody = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(3.2);
            var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            var f    = Demand.kr(trig, 0, seq);
            var env  = Decay2.kr(trig, 0.01, 0.35);
            var tone = SinOsc.ar(f) * env * 0.25;
            var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
    log.("\\testmelody (stereo) ensured");
};

reassertExclusive = {
    // Use class-level Option A (CURRENT audible; NEXT hard-silenced)
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    log.("class-level exclusivity reasserted (Option A)");
};

enableMetersClean = {
    // Your GUI’s enableMeters() re-sends SynthDefs each time
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(true);
        log.("meters re-enabled");
    };
};

verify = {
    AppClock.sched(0.25, {
        var a = Ndef(\chainA).isPlaying;
        var b = Ndef(\chainB).isPlaying;
        ("[PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

// run
ensureServer.value;
disableMetersNow.value;
ensureStereoSinks.value;
defineTs0StereoSilent.value;
defineTestMelody.value;
reassertExclusive.value;
enableMetersClean.value;
verify.value;
)
// fixChainBSource.scd
// v0.1
// MD 20250917-1241

~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
~ct_applyOSCPathToMPB.("/add/delay", ~mpb, ~gui);  // optional FX on NEXT
~ct_applyOSCPathToMPB.("/switch",    ~mpb, ~gui);
// ForceStereoMold_Now.scd
// v0.1
// MD 20250917-1215
//
// Purpose: Pin sinks to 2ch audio using .mold (stronger than .ar)
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
Server.default.bind({
    Ndef(\chainA).mold(2, \audio);
    Ndef(\chainB).mold(2, \audio);
});
)
// helper_recover_if_silent.scd
// v0.2

(
~recoverLog = ~recoverLog ?? { arg messageString;
    ("[RECOVER] " ++ messageString).postln;
};

~recoverIfSilent = {
    var ensureStereo, connectPair, connectList, currentEff, nextEff;
    var currentSink, nextSink, indexCounter, lastIndex;

    if(~mpb.isNil) { ~recoverLog.("~mpb is nil"); ^false };

    // Temporarily disable meters to avoid control-rate warnings during repair
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false) };

    // Ensure sinks are audio-rate
    Server.default.bind({
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });

    // Effective lists from pedalboard
    currentEff = ~mpb.effectiveCurrent;
    nextEff    = ~mpb.effectiveNext;

    ensureStereo = { arg keySymbol; Ndef(keySymbol).ar(2) };

    connectPair = { arg leftKey, rightKey;
        // matches project operator direction: left receives right
        Server.default.bind({ Ndef(leftKey) <<> Ndef(rightKey) });
    };

    connectList = { arg listSymbols;
        indexCounter = 0;
        lastIndex = listSymbols.size - 1;
        while({ indexCounter < lastIndex }, {
            var leftKey, rightKey;
            leftKey  = listSymbols[indexCounter];
            rightKey = listSymbols[indexCounter + 1];
            ensureStereo.(leftKey);
            ensureStereo.(rightKey);
            connectPair.(leftKey, rightKey);
            indexCounter = indexCounter + 1;
        });
    };

    // Rebuild both chains end-to-end
    connectList.(currentEff);
    connectList.(nextEff);

    // Enforce: CURRENT plays, NEXT stopped
    currentSink = currentEff[0];
    nextSink    = nextEff[0];
    Server.default.bind({
        if(Ndef(nextSink).isPlaying)        { Ndef(nextSink).stop };
        if(Ndef(currentSink).isPlaying.not) { Ndef(currentSink).play(numChannels: 2) };
    });

    // Re-enable meters (after AR is guaranteed)
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(true) };

    ~recoverLog.("reconnected. currentEff=" ++ currentEff ++ " nextEff=" ++ nextEff);

    // Status a moment later (no server.sync)
    AppClock.sched(0.20, {
        var aPlaying, bPlaying, line;
        aPlaying = Ndef(\chainA).isPlaying;
        bPlaying = Ndef(\chainB).isPlaying;
        line = "[status] A.playing=% B.playing=%".format(aPlaying, bPlaying);
        line.postln; nil
    });

    true
};
)
// Inline_CT_TokenSmoke.scd
// v0.1.2
// MD 2025-09-18 14:12 BST

// Purpose:
// - Demonstrate that MagicPedalboardNew responds to CommandTree-shaped *token* queues today
//   without external file loads (audible and logged).
// - Flow: ensure sources -> tiny token-harness -> prime sources -> apply tokens -> verify.
// Style:
// - var-first in every function/closure; lowercase names; no server.sync;
// - all server ops inside Server.default.bind; GUI ops on AppClock; NodeProxy connections
//   remain inside class rebuilds using the exact <<> operator.

(
var log, need, ensureSources, tokensToPath, isNextSilent, guardSwitchAudible,
    applyOneTokens, runPlaylist, doRun, playlist, gap;

// --- logging helper (var-first inside) ---
log = { arg s;
    var str;
    str = "[TOKENS] " ++ s;
    str.postln;
};

// --- precondition guard (var-first inside) ---
need = {
    var ok;
    ok = (~mpb.isNil.not) and: { ~gui.isNil.not };
    if(ok.not) {
        "[TOKENS] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
    };
    ok
};

// --- ensure generated sources exist (no SoundIn) ---
ensureSources = {
    var define;
    define = {
        var made;
        made = false;
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
            made = true;
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) });  Ndef(\ts0).ar(2);
        made
    };
    Server.default.bind({ define.value; });
};

// --- token -> canonical path mapping understood by the adapter ---
tokensToPath = { arg tokensIn;
    var tokens, verb, args, result, onOff;
    tokens = tokensIn.collect({ arg t; t.asString });
    if(tokens.size <= 0) { ^nil };
    verb = tokens[0].toLower;
    args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
    result = nil;

    if(verb == "insert" or: { verb == "add" }) {
        if(args.size >= 1) { result = "/add/" ++ args[0] };
    }{
        if(verb == "bypass") {
            onOff = if(args.size >= 2) { args[1].toLower } { "on" };
            onOff = if(#["on","off","true","false","1","0"].includes(onOff)) {
                if((onOff == "true") or: { onOff == "1" }) { "on" } { onOff }
            } { "on" };
            if(args.size >= 1) { result = "/bypass/" ++ args[0] ++ "/" ++ onOff };
        }{
            if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                if(args.size >= 1) { result = "/setSource/" ++ args[0] };
            }{
                if(verb == "removeat") {
                    if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                }{
                    if(verb == "swap") {
                        if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                    }{
                        if(verb == "switch" or: { verb == "commit" }) {
                            result = "/switch";
                        }{
                            result = nil;
                        };
                    };
                };
            };
        };
    };
    ^result
};

// --- guard so /switch never lands on a silent NEXT (\ts0 tail) ---
isNextSilent = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    ^(last == \ts0)
};

guardSwitchAudible = {
    var needed;
    needed = isNextSilent.value;
    if(needed) {
        log.("NEXT ends with \\ts0; injecting /setSource/testmelody before /switch");
        if(~ct_applyOSCPathToMPB.notNil) {
            ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
        }{
            "[TOKENS] adapter missing; cannot auto-fix source".warn;
        };
    };
};

// --- apply one token step via your existing adapter ---
applyOneTokens = { arg tokens;
    var path;
    path = tokensToPath.value(tokens);
    if(path.isNil) {
        log.("unmapped tokens: " ++ tokens.asString);
        ^nil;
    };
    if(path == "/switch") { guardSwitchAudible.value };
    if(~ct_applyOSCPathToMPB.notNil) {
        log.("apply " ++ tokens.asString ++ "  -> " ++ path);
        ~ct_applyOSCPathToMPB.(path, ~mpb, ~gui);
    }{
        ("[TOKENS] adapter missing; would apply " ++ path).warn;
    };
};

// --- run a playlist of token steps with a gap (AppClock) ---
runPlaylist = { arg listOfTokenLists, gapSeconds = 0.6;
    var rt;
    rt = Routine({
        var i;
        i = 0;
        while({ i < listOfTokenLists.size }, {
            applyOneTokens.value(listOfTokenLists[i]);
            gapSeconds.wait;
            i = i + 1;
        });
        log.("done.");
    }).play(AppClock);
    ^rt
};

// --- end-to-end demo: prime sources (today), run, verify ---
doRun = {
    var verify;
    gap = 0.60;

    // For today: both chains end with \testmelody; NEXT stays silent at sink (Option A).
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);

    // Example playlist: insert delay -> switch -> bypass on -> bypass off -> switch back
    playlist = [
        ["insert","delay"],
        ["switch"],
        ["bypass","delay","on"],
        ["bypass","delay","off"],
        ["switch"]
    ];

    runPlaylist.value(playlist, gap);

    verify = {
        var a, b;
        a = Ndef(\chainA).isPlaying; b = Ndef(\chainB).isPlaying;
        ("[PLAY] A=% B=%".format(a, b)).postln;
        ~mpb.printChains;
    };

    AppClock.sched(playlist.size * gap + 0.9, { verify.value; nil });
};

// --- go ---
if(need.value) {
    ensureSources.value;
    doRun.value;
};
)
// fix_current_only_now.scd
// v0.1
// MD 20250916-1007

(
var log;

log = { arg m; ("[FIX] " ++ m).postln };

// stop NEXT sink explicitly
if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop; log.("stopped \\chainB"); };

// re-wire CURRENT effective list with the correct operator and play only CURRENT
Server.default.bind({
    // ensure stereo busses (cheap no-op if already set)
    Ndef(\chainA).ar(2);
    Ndef(\testmelody).ar(2);

    // correct embed operator you use in this project:
    Ndef(\chainA) <<> Ndef(\testmelody);

    // play CURRENT sink only
    Ndef(\chainA).play(numChannels: 2);
});

~pedalboard.printChains;
"[FIX] chainA <<> testmelody; chainA.play done.".postln;
)
/* MagicProcessorLibrary_defs.scd
   Register a few defaults. Keep this file small and readable.
*/
(
var lib, define;

lib = MagicProcessorLibrary.new;

define = { arg key, func; lib.register(key, func) };

// Sources
define.(\ts0, {
    var inputSignal;
    inputSignal = Silent.ar((0..1));
    inputSignal * 1.0
});

// Effects – same as in bootstrap, or your refined versions
define.(\delay, {
    var inputSignal, time, fb, mix, delayed;
    inputSignal = \in.ar;
    time = \time.kr(0.35).clip(0.01, 2.0);
    fb   = \fb.kr(0.35).clip(0.0, 0.95);
    mix  = \mix.kr(0.25).clip(0.0, 1.0);
    delayed = CombC.ar(inputSignal, 2.0, time, time * (fb * 6 + 0.1));
    XFade2.ar(inputSignal, delayed, (mix * 2 - 1))
});

define.(\tremolo, {
    var inputSignal, rate, depth;
    inputSignal = \in.ar;
    rate  = \rate.kr(5).clip(0.1, 20);
    depth = \depth.kr(0.5).clip(0, 1);
    inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
});

define.(\reverb, {
    var inputSignal, mix, room, damp;
    inputSignal = \in.ar;
    mix  = \mix.kr(0.25).clip(0, 1);
    room = \room.kr(0.5).clip(0, 1);
    damp = \damp.kr(0.3).clip(0, 1);
    XFade2.ar(inputSignal, FreeVerb2.ar(inputSignal[0], inputSignal[1], mix, room, damp), 0)
});

define.(\chorus, {
    var inputSignal, rate, depth, baseDelay, modDelay;
    inputSignal = \in.ar;
    rate      = \rate.kr(0.8).clip(0.1, 5);
    depth     = \depth.kr(0.008).clip(0.0, 0.02);
    baseDelay = \base.kr(0.020).clip(0.0, 0.05);
    modDelay  = baseDelay + (SinOsc.kr(rate, 0, depth));
    DelayC.ar(inputSignal, 0.1, modDelay)
});

define.(\drive, {
    var inputSignal, gain;
    inputSignal = \in.ar;
    gain = \gain.kr(2.5).clip(1, 10);
    (inputSignal * gain).tanh
});

// Expose the library in a tilde var for convenience
~procLib = lib;

// Ensure a basic set now (optional; you can call ensureFromChain later)
~procLib.ensureMany(~procLib.keys, 2);
)
// MagicStart_Prelude_SelfRun
// v0.4.9
// 2025-09-17 14:48 BST (MD)
//
// Purpose:
// - Self-running top-of-file prelude to start from a known-good state.
// - Avoid quit/boot races by reusing a healthy server + init tree + clear default group.
// - Define busMeterA / busMeterB with a COMPILE-TIME channel count to prevent In.ar errors.
// - Mix meters to mono internally to avoid language-level max comparisons on UGens.
// Style:
// - tilde vars only, var-first inside functions, no server.sync,
//   Server.default.bind for server ops, GUI-safe (AppClock), your SC coding rules respected.

(
var numChannelsConst;

// --- Decide a compile-time channel count for the meter synths ----------------
// If you already set ~defaultNumChannels elsewhere (Integer > 0), we use it; otherwise fall back to 2.
numChannelsConst = (
    ~defaultNumChannels.isKindOf(Integer) and: { ~defaultNumChannels > 0 }
).if({ ~defaultNumChannels }, { 2 });

// --- Helpers -----------------------------------------------------------------
~closeMagicDisplayGUIWindows = {
    var windows;
    windows = Window.allWindows.select { |w|
        var name;
        name = w.tryPerform(\name);
        name.notNil and: { name.asString.beginsWith("MagicDisplayGUI") }
    };
    windows.do { |w| w.close };
    "[START] closed any existing MagicDisplayGUI windows".postln;
};

~ensureServerReady = {
    var s;
    s = Server.default;

    if (s.serverRunning) {
        "[START] server already running → reusing".postln;
    } {
        if (s.booting) {
            "[START] server already booting → waiting…".postln;
        } {
            "[START] booting server…".postln;
            s.boot;
        };
        s.waitForBoot;
    };

    Server.default.bind({
        s.initTree;
        s.defaultGroup.freeAll;
    });
    "[START] tree inited + default group cleared".postln;
};

~ensureMeterDefs = {
    var needA, needB;
    needA = SynthDescLib.global.at(\busMeterA).isNil;
    needB = SynthDescLib.global.at(\busMeterB).isNil;

    if (needA or: { needB }) {
        ("[START] (re)defining meter synths with numChannelsConst=" ++ numChannelsConst).postln;

        // Capture numChannelsConst at SynthDef build time (literal inside the UGen graph).
        Server.default.bind({
            SynthDef(\busMeterA, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                // choose an index: \bus if >=0 else \in (control-rate comparator is fine for Select)
                useBus = Select.kr(bus >= 0, [in, bus]);
                // read exactly numChannelsConst channels (compile-time integer)
                sig    = In.ar(useBus, numChannelsConst);
                // mix to mono to avoid language-level max across arrays of UGens
                mono   = Mix(sig);
                // meters
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterA", [rms, peak]);
            }).add;

            SynthDef(\busMeterB, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                useBus = Select.kr(bus >= 0, [in, bus]);
                sig    = In.ar(useBus, numChannelsConst);
                mono   = Mix(sig);
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterB", [rms, peak]);
            }).add;
        });
    };
};

// Optional: quick chain channel sanity check (posted if chains already exist)
~checkChainChannels = {
    var a, b;
    a = Ndef(\chainA).tryPerform(\numChannels);
    b = Ndef(\chainB).tryPerform(\numChannels);
    if(a.notNil or: { b.notNil }) {
        "[CHECK] Ndef chain channels → A:% , B:%".format(a, b).postln;
    };
};

// --- Execute preflight now (self-running) ------------------------------------
~closeMagicDisplayGUIWindows.value;
~ensureServerReady.value;
~ensureMeterDefs.value;
~checkChainChannels.value;   // harmless if chains don't exist yet
"[READY] MagicStart prelude complete — continue with your runner code below.".postln;
)
// Manage_MagicDisplayGUI_Singleton.scd
// v0.1
// MD 20250917-1230
//
// Purpose: Close any existing MagicDisplayGUI windows and spawn one fresh GUI,
//          then (optionally) create/recreate ~mpb bound to that GUI.
// Style: tilde vars, var-first, lowercase names, AppClock for GUI ops.
//        no server.sync; server ops should happen elsewhere.

(
var closeExisting, createNew;

closeExisting = {
    AppClock.sched(0.0, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            (w.name ? "").asString.beginsWith("MagicDisplayGUI")
        });
        wins.do({ arg w; w.close });
        nil
    });
};

createNew = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI.new;
        ~mpb = MagicPedalboardNew.new(~gui);
        nil
    });
};

closeExisting.value;
createNew.value;
)
// Milestone_QueueResponse.scd
// v0.1.1
// MD 2025-09-18 13:56 BST
/*
Purpose
- One-button milestone demo: build the token-harness, run a short token playlist,
  and print concise checks. Use after bring-up.

Style
- var-first; lowercase; no server.sync; GUI on AppClock; audio graph owned by class code.
*/

(
var log, need, ensureSources, verify, run;

log = { arg s; ("[MILESTONE] " ++ s).postln };

need = {
    var ok;
    ok = (~mpb.notNil and: { ~gui.notNil });
    if(ok.not) { "[MILESTONE] ~mpb/~gui are nil. Run the bring-up script first.".warn };
    ^ok;
};

ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

verify = { arg tag = "now";
    var aPlaying, bPlaying;
    aPlaying = Ndef(\chainA).isPlaying;
    bPlaying = Ndef(\chainB).isPlaying;
    ("[PLAY] A=% B=%".format(aPlaying, bPlaying)).postln;
    ~mpb.printChains;
    ("[CHECK] " ++ tag).postln;
};

run = {
    var gap, h, playlist;
    gap = 0.60;

    "CT_TokenQueueHarness.scd".loadRelative;
    ~ctq = ~ctq_makeHarness.(~mpb, ~gui, gap);

    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    verify.("after prime");

    playlist = [
        ["insert","delay"],
        ["switch"],
        ["bypass","delay","on"],
        ["bypass","delay","off"],
        ["switch"]
    ];

    ~ctq[\runPlaylist].(playlist, gap);
    AppClock.sched(playlist.size * gap + 0.8, { verify.("after playlist"); nil });
};

if(need.()) {
    ensureSources.();
    run.();
};
)
(
// mpb_exclusiveReset_now.scd
// v0.1
// MD 20250916

var reportStatus;

reportStatus = {
    var aPlaying, bPlaying, textOut;
    aPlaying = Ndef(\chainA).isPlaying;
    bPlaying = Ndef(\chainB).isPlaying;
    textOut = "[status] A.playing=%  B.playing=%".format(aPlaying, bPlaying);
    textOut.postln;
};

// Reset MPB: leaves CURRENT playing and NEXT stopped
~mpb.reset;
reportStatus.();
)
// OneShot_Acceptance_CommandDriven.scd
// v0.2.3
// MD 20250917-1312
//
// Purpose: Robust, non-intrusive acceptance using your adapter.
//          - Waits for server + ~mpb + adapter
//          - Disables meters only during ops (to avoid attach races)
//          - Pins stereo shape with mold(2,\audio) (does NOT overwrite sink sources)
//          - Enforces Option A at source level; hard-drops NEXT monitor with .end
//            (does NOT replace NEXT’s source), so flags match audio
//          - Drives: /add/delay → /switch → /bypass/delay/on → /bypass/delay/off → /switch
//          - Asserts A XOR B after each step and prints a summary
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind. GUI AppClock only; one window.

(
var log, step, t,
    ready, disableMeters, enableMeters,
    pinStereoSinks, ensureSources, baselineExclusive,
    enforceOptionA_EndNext, assertXor, apply, runScenario;

var passCount, failCount;
passCount = 0; failCount = 0;

// helpers
log  = { arg s; ("[ACCEPT] " ++ s).postln };
step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

// timings
t = ( prep:0.00, baseline:0.25, add:0.45, sw1:0.75, byOn:1.05, byOff:1.30, sw2:1.60, meters:1.90, sum:2.10 );

// readiness
ready = {
    if(Server.default.serverRunning.not) { Server.default.boot };
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
    if(~ct_applyOSCPathToMPB.isNil) {
        "[ACCEPT] adapter missing: eval adapter_commandtree_to_magicpedalboard.scd, then rerun.".warn;
        ^false
    };
    true
};

// meters control (non-intrusive)
disableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(false);
        log.("meters disabled");
    };
};
enableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(true);
        log.("meters enabled");
    };
};

// non-destructive stereo pin (NO source overwrite)
pinStereoSinks = {
    Server.default.bind({
        Ndef(\chainA).mold(2, \audio);
        Ndef(\chainB).mold(2, \audio);
        // NOTE: no Ndef(\chainX, { \in.ar(2) }) here; class manages sources.
    });
    log.("sinks pinned: mold(2,audio) (non-destructive)");
};

// sources (safe to define)
ensureSources = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(3.2);
            var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            var f    = Demand.kr(trig, 0, seq);
            var env  = Decay2.kr(trig, 0.01, 0.35);
            var tone = SinOsc.ar(f) * env * 0.25;
            var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        }); Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
    log.("sources ensured (\\testmelody, \\ts0)");
};

// enforce Option A at source level + drop NEXT monitor only (NO source overwrite)
enforceOptionA_EndNext = {
    var nextSink = ~mpb.nextChain[0];
    ~mpb.enforceExclusiveCurrentOptionA(0.1);    // class silences NEXT at source
    Server.default.bind({
        Ndef(nextSink).end;                      // drop monitor/flag
        // do NOT change next sink’s source here; class manages it
        Ndef(nextSink).mold(2, \audio);         // keep shape pinned
    });
    log.("Option A enforced + NEXT ended (monitor dropped)");
};

// baseline: CURRENT <- \testmelody
baselineExclusive = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
    enforceOptionA_EndNext.value;
};

// A XOR B assert
assertXor = { arg expectA, expectB, label;
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying, ok;
    ok = (a == expectA) and: { b == expectB };
    ((ok.if({"PASS"},{"FAIL"})) ++ " — " ++ label ++ " (A=" ++ a ++ " B=" ++ b ++ ")").postln;
    if(ok) { passCount = passCount + 1 } { failCount = failCount + 1 };
    ok
};

// adapter apply
apply = { arg pathString; ~ct_applyOSCPathToMPB.(pathString, ~mpb, ~gui) };

// scenario
runScenario = {
    if(ready.value.not) { ^nil };

    disableMeters.value;
    pinStereoSinks.value;
    ensureSources.value;

    baselineExclusive.value;
    ~mpb.printChains;
    assertXor.value(true, false, "baseline: CURRENT audible; NEXT silent");

    apply.value("/add/delay");
    ~mpb.printChains;
    assertXor.value(true, false, "after add/delay (NEXT) — exclusivity holds");

    apply.value("/switch");               // A->B
    step.value(0.35, {
        enforceOptionA_EndNext.value;     // drop NEXT flag only (no source changes)
        ~mpb.printChains;
        assertXor.value(false, true, "after first switch — NEXT→CURRENT");

        apply.value("/bypass/delay/on");
        ~mpb.printChains;
        assertXor.value(false, true, "after bypass on (CURRENT)");

        apply.value("/bypass/delay/off");
        ~mpb.printChains;
        assertXor.value(false, true, "after bypass off (CURRENT)");

        apply.value("/switch");           // B->A
        step.value(0.35, {
            enforceOptionA_EndNext.value;
            ~mpb.printChains;
            assertXor.value(true, false, "after second switch — back to A");

            enableMeters.value;
            ("[ACCEPT] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount).postln;
            nil
        });
        nil
    });
};

// run
runScenario.value;
)
// OneShot_Acceptance_SwitchDelay.scd
// v0.1
// MD 20250916-1618

// Purpose: Automated acceptance: baseline -> add \delay to NEXT -> switch (0.12s) -> verify exclusive playback and chain contents; includes basic PASS/FAIL counting and GUI meter retarget.
// Style: tilde vars, var-first, lowercase names, no server.sync, Server.default.bind for server ops.

(
var log, passCount, failCount, assertTrue, step, timePlan, ensureSinks, ensureGuiMpb, ensureSource, ensureDelayProc, verifyExclusive, runScenario;

log = { arg s; ("[ACCEPT] " ++ s).postln };

passCount = 0; failCount = 0;
assertTrue = { arg cond, label;
    var text;
    text = if(cond) { "PASS" } { "FAIL" };
    ("[ACCEPT] " ++ text ++ " — " ++ label).postln;
    if(cond) { passCount = passCount + 1 } { failCount = failCount + 1 };
};

step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

timePlan = ( sinks:0.05, gui:0.10, source:0.20, meters:0.30, baseline:0.45, add:0.60, switch:0.80, verify2:1.10, bypassOn:1.30, bypassOff:1.50, switchBack:1.70, summary:1.95 );

// 1) Robust sinks (consumes \in) + AR buses
ensureSinks = {
    log.("ensure sinks robust + audio-rate");
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) });
        Ndef(\chainB, { \in.ar(2) });
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
};

// 2) GUI + MPB
ensureGuiMpb = {
    log.("ensure GUI + MPB");
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};

// 3) Known-good internal source
ensureSource = {
    log.("define \\testmelody");
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);
    });
};

// 4) Ensure proc (\delay) exists (stereo)
ensureDelayProc = {
    log.("ensure \\delay processor exists");
    Server.default.bind({
        Ndef(\delay, { |time=0.45, fb=0.35, mix=0.5|
            var sig = \in.ar(2);
            var delayed = CombC.ar(sig, 2.0, time.clip(0.01,2.0), time * (fb.clip(0,0.95)*6 + 0.1));
            XFade2.ar(sig, delayed, (mix.clip(0,1) * 2 - 1))
        });
        Ndef(\delay).ar(2);
    });
};

// helper: verify exclusive CURRENT (A XOR B playing)
verifyExclusive = { arg expectAPlaying, expectBPlaying, label;
    var a, b, match;
    a = Ndef(\chainA).isPlaying;
    b = Ndef(\chainB).isPlaying;
    match = (a == expectAPlaying) and: { b == expectBPlaying };
    assertTrue.(match, label ++ " (A=" ++ a ++ " B=" ++ b ++ ")");
};

// 5) Scenario: baseline -> add \delay (NEXT) -> switch -> verify -> bypass current on/off -> switch back
runScenario = {
    log.("baseline: CURRENT <- \\testmelody; play A, stop B; meters reattach");
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
    Server.default.bind({
        if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
        if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
    });
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false); ~gui.enableMeters(true) };

    ~mpb.printChains;
    verifyExclusive.(true, false, "baseline exclusive: A=true, B=false");

    log.("add \\delay to NEXT, then switch (0.12s)");
    ~mpb.add(\delay);
    ~mpb.printChains;
    ~mpb.switchChain(0.12);

    // verify after fade
    step.(0.25, {
        verifyExclusive.(false, true, "after switch: A=false, B=true");
        ~mpb.printChains;

        log.("bypassCurrent(\\delay, true) then false");
        ~mpb.bypassCurrent(\delay, true);
        ~mpb.printChains;
        ~mpb.bypassCurrent(\delay, false);
        ~mpb.printChains;

        log.("switch back to A");
        ~mpb.switchChain(0.12);

        step.(0.25, {
            verifyExclusive.(true, false, "after switch-back: A=true, B=false");
            ("[ACCEPT] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount).postln;
        });
    });
};

// --- run sequence (no server.sync; AppClock timing) ---
Server.default.boot;
step.(timePlan[\sinks], { ensureSinks.value });
step.(timePlan[\gui],   { ensureGuiMpb.value });
step.(timePlan[\source],{ ensureSource.value });
step.(timePlan[\meters],{ if(~gui.notNil, { ~gui.enableMeters(false); ~gui.enableMeters(true) }) });
step.(timePlan[\baseline], { runScenario.value });

)
// OneShot_BringUp_MagicPedalboardNew_GUI_Meters.scd
// v0.2.1
// MD 20250917-1208
//
// Purpose: Deterministic bring-up: disable meters early; stereo sinks (\in.ar(2)); \ts0 stereo Silent;
//          define \testmelody; play CURRENT; enforce Option A; then explicitly pause NEXT so
//          isPlaying=B=false; enable meters; verify A XOR B.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind. GUI on AppClock only; one window.

(
var log, step, t,
    doBoot, ensureGuiMpb_disableMetersEarly, ensureSinksStereo, ensureTs0SilentStereo,
    ensureTestMelody, startCurrent_enforceExclusive, forceNextPauseFlag, enableMetersClean, verifyState;

log  = { arg s; ("[BRINGUP] " ++ s).postln };
step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

// timings (seconds)
t = (
    boot:     0.00,
    guiMpb:   0.35,
    sinks:    0.50,
    ts0:      0.65,
    source:   0.80,
    current:  1.00,
    nextPause:1.05,   // tiny step after Option A
    meters:   1.20,
    verify:   1.40
);

doBoot = {
    log.("boot audio");
    Server.default.boot;
};

ensureGuiMpb_disableMetersEarly = {
    log.("ensure GUI + pedalboard; disable meters early");
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    // proactively disable meters twice (beats any queued enable)
    AppClock.sched(0.00, { ~gui.enableMeters(false); nil });
    AppClock.sched(0.05, { ~gui.enableMeters(false); nil });

    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};

ensureSinksStereo = {
    log.("robust sinks: \\in.ar(2) + ar(2)");
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) }); Ndef(\chainA).ar(2);
        Ndef(\chainB, { \in.ar(2) }); Ndef(\chainB).ar(2);
    });
};

ensureTs0SilentStereo = {
    log.("define \\ts0 as stereo Silent (for NEXT)");
    Server.default.bind({
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

ensureTestMelody = {
    log.("define \\testmelody (stereo)");
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(3.2);
            var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            var f    = Demand.kr(trig, 0, seq);
            var env  = Decay2.kr(trig, 0.01, 0.35);
            var tone = SinOsc.ar(f) * env * 0.25;
            var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
};

startCurrent_enforceExclusive = {
    log.("CURRENT <- \\testmelody; play + enforce Option A");
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;                         // MPB enforces Option A after play
    ~mpb.enforceExclusiveCurrentOptionA(0.1); // belt-and-braces: NEXT hard-silenced + stop
};

forceNextPauseFlag = {
    // Ensure NEXT.isPlaying == false (state aligns with Option A audio silence)
    var nextSink;
    nextSink = ~mpb.nextChain[0];             // sink symbol (chainB if A is current)
    Server.default.bind({ Ndef(nextSink).pause });
    log.("NEXT paused (flag B=false)");
};

enableMetersClean = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        log.("enable meters (guards + re-sends SynthDefs)");
        ~gui.enableMeters(true);
    };
};

verifyState = {
    log.("verify");
    ~mpb.printChains;
    AppClock.sched(0.25, {
        var a = Ndef(\chainA).isPlaying;
        var b = Ndef(\chainB).isPlaying;
        ("[PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

log.("start deterministic bring-up");
step.(t[\boot],     { doBoot.value });
step.(t[\guiMpb],   { ensureGuiMpb_disableMetersEarly.value });
step.(t[\sinks],    { ensureSinksStereo.value });
step.(t[\ts0],      { ensureTs0SilentStereo.value });
step.(t[\source],   { ensureTestMelody.value });
step.(t[\current],  { startCurrent_enforceExclusive.value });
step.(t[\nextPause],{ forceNextPauseFlag.value });   // <-- NEW tiny step
step.(t[\meters],   { enableMetersClean.value });
step.(t[\verify],   { verifyState.value });
)
// OneShot_BringUp_MinimalOnly.scd
// v0.1
// MD 20250916-1608

(
// =========================================================

// Purpose: bring up to a clean audible baseline (no FX demo);
//          robust sinks; retarget meters; verify.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

// =========================================================

var log, step, t, doBoot, ensureSinks, ensureGuiMpb, ensureSource,
    enforceExclusiveCurrent, ensureMetersOk, verifyState;

log = { arg s; ("[BRINGUP] " ++ s).postln };
step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

// timings
t = ( boot:0.00, sinks:0.40, guiMpb:0.55, source:0.75, current:0.95, meters:1.15, verify:1.35 );

doBoot = { log.("boot audio"); Server.default.boot; };

ensureSinks = {
    log.("ensure sinks robust + AR");
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) }); Ndef(\chainB, { \in.ar(2) });
        Ndef(\chainA).ar(2);          Ndef(\chainB).ar(2);
    });
};

ensureGuiMpb = {
    log.("ensure GUI + MPB");
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};

ensureSource = {
    log.("define \\testmelody (stereo)");
    Server.default.bind({
        Ndef(\testmelody, {
            var trig=Impulse.kr(3.2), seq=Dseq([220,277.18,329.63,392,329.63,277.18,246.94],inf);
            var f=Demand.kr(trig,0,seq), env=Decay2.kr(trig,0.01,0.35);
            var tone=SinOsc.ar(f)*env*0.25, pan=ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
};

enforceExclusiveCurrent = {
    log.("CURRENT <- \\testmelody; play A, stop B");
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
    Server.default.bind({
        if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
        if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
    });
};

ensureMetersOk = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        log.("meters retarget");
        ~gui.enableMeters(false); ~gui.enableMeters(true);
    };
};

verifyState = {
    log.("verify");
    ~mpb.printChains;
    AppClock.sched(0.15, {
        "[PLAY] A=%  B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)
        .postln; nil
    });
};

log.("starting bring‑up (minimal)");
step.(t[\boot],    { doBoot.value });
step.(t[\sinks],   { ensureSinks.value });
step.(t[\guiMpb],  { ensureGuiMpb.value });
step.(t[\source],  { ensureSource.value });
step.(t[\current], { enforceExclusiveCurrent.value });
step.(t[\meters],  { ensureMetersOk.value });
step.(t[\verify],  { verifyState.value });

)
// OneShot_ResetToCleanBaseline.scd
// v0.6
// MD 20250916-1708

//
// Purpose: Reset to a clean, audible baseline and GUARANTEE exclusivity by silencing NEXT.
//          Ensures robust sinks (\in.ar(2)), defines \testmelody, uses MPB.reset, then enforces
//          CURRENT-only by muting NEXT at the sink source; retargets meters and prints final state.
// Style:   tilde vars; var-first; lowercase names; no server.sync; Server.default.bind for server ops.

(
var log, ensureSinksRobust, ensureSource, ensureGuiMpb, doMpbReset,
    setCurrent, enforceExclusiveBySilence, retargetMeters, verify;

log = { arg s; ("[RESET] " ++ s).postln; };

// Robust sinks + AR
ensureSinksRobust = {
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) });
        Ndef(\chainB, { \in.ar(2) });
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
};

// Internal source
ensureSource = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, pan;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
            f    = Demand.kr(trig,0,seq);
            env  = Decay2.kr(trig,0.01,0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
};

// GUI + MPB and reset
ensureGuiMpb = {
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};
doMpbReset = { ~mpb.reset };

// CURRENT <- testmelody; play
setCurrent = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
};

// Silencing strategy: mute NEXT sink’s source (hard silence), keep CURRENT robust+playing
enforceExclusiveBySilence = {
    var currentSink, nextSink;
    currentSink = ~mpb.effectiveCurrent[0];
    nextSink    = ~mpb.effectiveNext[0];

    Server.default.bind({
        // CURRENT robust + playing
        Ndef(currentSink, { \in.ar(2) });
        Ndef(currentSink).ar(2);
        Ndef(currentSink).fadeTime_(0.05);
        if(Ndef(currentSink).isPlaying.not) { Ndef(currentSink).play(numChannels: 2) };

        // NEXT silenced at source (even if its monitor claims 'playing', it contributes 0 audio)
        Ndef(nextSink, { Silent.ar(2) });
        Ndef(nextSink).ar(2);
        Ndef(nextSink).fadeTime_(0.01);
        Ndef(nextSink).stop;
    });
    log.("exclusive enforced by silencing NEXT " ++ nextSink.asString);
};

// meters after AR
retargetMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(false);
        ~gui.enableMeters(true);
    };
};

// final print
verify = {
    ~mpb.printChains;
    AppClock.sched(0.25, {
        ("[PLAY] A=%  B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

log.("start");
Server.default.boot;

ensureSinksRobust.value;
ensureGuiMpb.value;
doMpbReset.value;
ensureSource.value;
setCurrent.value;
enforceExclusiveBySilence.value;
retargetMeters.value;
verify.value;
)
// prep_demo_audio_gui_current.scd
// v0.1
// MD 20250916-1046

(
var ensureSource;

Server.default.boot;

// ensure a musical internal source
ensureSource = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);
        // simple FX
        Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
            var sig, delayed, bal;
            sig = \in.ar(2);
            delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
            bal = (mix.clip(0,1) * 2 - 1);
            XFade2.ar(sig, delayed, bal)
        });
    });
};

// one GUI window via your runner
~md_bootProbeScenario.();

// ensure GUI + pedalboard, and make CURRENT audible
~gui = ~gui ?? { MagicDisplayGUI.new() };
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
~pedalboard.reset;
~pedalboard.setSourceCurrent(\testmelody);  // CURRENT, so it's audible immediately
~pedalboard.playCurrent;
~pedalboard.printChains;
)
// Probe_Ndef_SinkState.scd
// v0.1
// MD 20250916-1700

//
// Purpose: Safely inspect a sink Ndef’s current source object and playing/paused/monitor status.
//          Uses .source (not .sourceCode) and prints class + optional asCompileString if available.
// Style:   tilde vars, var-first, lowercase names, no server.sync, Server.default.bind for server ops.

(
var key, nx, srcObj, srcClass, srcCode, mon, playing, paused;

key = \chainA; // change to \chainA if you want to probe A

nx       = Ndef(key);
srcObj   = nx.source;                 // current source object (Function or other)
srcClass = srcObj.class;
srcCode  = srcObj.tryPerform(\asCompileString); // may be nil if not supported
mon      = nx.monitor;                // monitor object (if any)
playing  = nx.isPlaying;
paused   = nx.paused ? false;         // NodeProxy sometimes keeps paused flag internally

("[PROBE] key=%  class=%  playing=%  paused=%  hasMonitor=%"
    .format(key, srcClass, playing, paused, mon.notNil)).postln;

if(srcCode.notNil) {
    "[PROBE] source asCompileString:".postln;
    srcCode.postln;
} {
    "[PROBE] source does not implement asCompileString; printing .source:".postln;
    srcObj.postln;
};
)
// quick_start_audible.scd
// v0.1

(
// 0) Recompile classes first (Cmd+Shift+L) if you just edited them.
// 1) GUI + pedalboard
~gui = ~gui ?? { MagicDisplayGUI.new };
~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };

// 2) Make CURRENT use our internal melody, play it
~mpb.setSourceCurrent(\testmelody);
~mpb.playCurrent;

// 3) Add delay to NEXT and switch (should hear the echo)
~mpb.add(\delay);
~mpb.switchChain(0.12);

// 4) If you still hear nothing, run the recover helper:
~recoverIfSilent.();

// 5) Inspect
~mpb.printChains;
"[[PLAY]] A=%  B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying).postln;
)
// quickprep.scd
// v0.1
// MD 20250916


(
// ===== Acceptance Prep =====
var linkedDisplay, hasGui, chainAName, chainBName;

linkedDisplay = nil;
hasGui = (~gui.notNil) and: { ~gui.isKindOf(MagicDisplayGUI) };
if(hasGui) { linkedDisplay = ~gui };

if(~mpb.isNil) {
    ~mpb = MagicPedalboardNew.new(linkedDisplay);
} {
    if(linkedDisplay.notNil) { ~mpb.setDisplay(linkedDisplay) };
};

// create a simple stereo test melody (safe levels)
Ndef(\testmelody, {
    var freq, lfo, sig;
    lfo = LFTri.kr(0.13).range(0.5, 1.0);
    freq = [220, 330] * lfo;
    sig = SinOsc.ar(freq, 0, 0.08);  // quiet
    sig
});

// set source to \testmelody on both chains (explicit)
~mpb.setSourceCurrent(\testmelody);
~mpb.setSource(\testmelody);

// start CURRENT sink (A by default on fresh boot)
~mpb.playCurrent;

// convenience: names for readability
chainAName = \chainA;
chainBName = \chainB;

// status
"Prep done. CURRENT is playing. A.isPlaying=%, B.isPlaying=%"
    .format(Ndef(chainAName).isPlaying, Ndef(chainBName).isPlaying).postln;
)
// QuickRestore_AudioAndExclusive.scd
// v0.2
// MD 20250917-1338
//
// Purpose: If audio is quiet, rebuild class-managed wiring (uses Ndef(left) <<> Ndef(right))
//          and re-enforce Option A. No sink-source overwrites.

(
var log; log = { arg s; ("[RESTORE] " ++ s).postln };

if(~mpb.isNil) { "[RESTORE] ~mpb is nil".warn; ^nil };

Server.default.bind({
    ~mpb.rebuildUnbound(~mpb.currentChain);   // internally uses Ndef(left) <<> Ndef(right)
    ~mpb.rebuildUnbound(~mpb.nextChain);
});
~mpb.playCurrent;
~mpb.enforceExclusiveCurrentOptionA(0.1);

AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[RESTORE] [PLAY] A=% B=%".format(a, b)).postln;
    nil
});
)
// RebuildAndRestore_OptionA.scd
// v0.1
// MD 20250917-1230
//
// Purpose: Recover class-managed wiring and Option A without touching sink sources.
// Style: tilde vars, var-first, no server.sync, Server.default.bind.

(
var log;
log = { arg s; ("[RECOVER] " ++ s).postln };

if(~mpb.isNil) { "[RECOVER] ~mpb is nil".warn; ^nil };

Server.default.bind({
    ~mpb.rebuildUnbound(~mpb.currentChain);   // uses Ndef(left) <<> Ndef(right) internally
    ~mpb.rebuildUnbound(~mpb.nextChain);
});

~mpb.playCurrent;
~mpb.enforceExclusiveCurrentOptionA(0.1);

AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[RECOVER] [PLAY] A=% B=%".format(a, b)).postln;
    nil
});
)
(
// retargetMeters.scd
// v0.1
// MD 20250916

var ensureAudioRateAndReloadMeters, hasGui;

ensureAudioRateAndReloadMeters = {
    hasGui = (~gui.notNil) and: { ~gui.isKindOf(MagicDisplayGUI) };

    // Turn meters off to free Synths/OSCdefs cleanly
    if(hasGui) { ~gui.enableMeters(false) };

    // Ensure sinks are audio-rate proxies (2 channels)
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // Turn meters back on; will now bind to the audio buses
    if(hasGui) { ~gui.enableMeters(true) };

    "[meters] reattached to audio-rate buses".postln;
};

ensureAudioRateAndReloadMeters.();
)
// saveonly_commandtree_current_to_json.scd
// v0.2
// MD 20250916-0942

(
var saveFolder, savePrefix, jsonPath, jsonString;

saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";
jsonPath   = (saveFolder +/+ "myTree.json").standardizePath;

// Ensure a saver instance (if nil, create one)
~saver = ~saver ?? { CircularFileSave.new(savePrefix, saveFolder, 10) };

// Serialize current in‑memory tree to JSON text
jsonString = JSONlib.convertToJSON(~tree.root.asDictRecursively);

// Save a versioned copy and overwrite the live JSON file for CommandManager
~saver.saveVersion(jsonString);
~tree.exportJSONFile(jsonPath);

"💾 Saved versioned JSON and wrote current tree to: ".postln;
jsonPath.postln;
)
// StartHere_CleanBoot_OneWindow_BringUp.scd
// v0.6
// MD 20250917-1616
//
// Purpose:
//   Known-state bring-up with one MagicDisplayGUI window, CURRENT=\testmelody
//   audible, NEXT silent (Option A), meters on, and verify A=true B=false.
//   Handles the case where GUI/MPB init quits and reboots the server mid-sequence
//   by detecting the reboot, waiting for it, and re-publishing the graph afterward.
//
// Style:
//   - tilde vars only
//   - var-first in every block
//   - lowercase names
//   - no server.sync
//   - server ops inside Server.default.bind
//   - GUI via AppClock (single window named “MagicDisplayGUI…”)

(
var log, s, numChConst,
    closeGuiWindows, freshBoot, ensureMeterDefs, checkChainChannels,
    clearOldNdefs, buildAudio, makeGuiAndMpb,
    waitForServerDownThenUp, baselinePlayWithRetry, metersOn, verify,
    runSequence,waitOnMpbReady;

log = { arg msg; ("[START] " ++ msg).postln };
s   = Server.default;

// channel constant everywhere (respects your global default if set)
numChConst = (
    ~defaultNumChannels.isKindOf(Integer) and: { ~defaultNumChannels > 0 }
).if({ ~defaultNumChannels }, { 2 });

// 1) Close any MagicDisplayGUI windows (singleton)
closeGuiWindows = {
    var wins;
    wins = Window.allWindows
        .select({ arg w; (w.name ? "").asString.beginsWith("MagicDisplayGUI") });
    wins.do(_.close);
    log.("closed any existing MagicDisplayGUI windows");
};

// 2) Force a FRESH server (quit if running, then boot), then clean the tree
freshBoot = {
    var t0, timeout, keepWait;
    timeout = 5.0;

    if(s.serverRunning) {
        log.("server running → quitting for clean boot");
        s.quit;
        t0 = Main.elapsedTime;
        keepWait = true;
        while({ s.serverRunning and: { keepWait } }, {
            0.05.wait;
            if((Main.elapsedTime - t0) > timeout) {
                "[WARN] timeout waiting for server to quit".postln;
                keepWait = false;
            };
        });
    };

    log.("booting server…");
    s.boot;
    s.waitForBoot;

    Server.default.bind({
        s.initTree;
        s.defaultGroup.freeAll;
    });
    log.("tree inited + default group cleared");
};

// 3) Ensure meter SynthDefs exist (compile-time channel count; mono mix inside)
ensureMeterDefs = {
    var needA, needB, n;
    n = numChConst;
    needA = SynthDescLib.global.at(\busMeterA).isNil;
    needB = SynthDescLib.global.at(\busMeterB).isNil;

    if(needA or: { needB }) {
        ("[START] (re)defining meter synths with numChConst=" ++ n).postln;

        Server.default.bind({
            SynthDef(\busMeterA, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                useBus = Select.kr(bus >= 0, [in, bus]);  // prefer \bus if set; else \in
                sig    = In.ar(useBus, n);                // compile-time literal
                mono   = Mix(sig);                        // stable single-channel level
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterA", [rms, peak]);
            }).add;

            SynthDef(\busMeterB, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                useBus = Select.kr(bus >= 0, [in, bus]);
                sig    = In.ar(useBus, n);
                mono   = Mix(sig);
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterB", [rms, peak]);
            }).add;
        });
    };
};

// 4) Optional: print A/B channel counts if chains already exist
checkChainChannels = {
    var a, b;
    a = Ndef(\chainA).tryPerform(\numChannels);
    b = Ndef(\chainB).tryPerform(\numChannels);
    if(a.notNil or: { b.notNil }) {
        "[CHECK] Ndef chain channels → A:% , B:%".format(a, b).postln;
    };
};

// 5) Clear any previous proxies to avoid channel wrapping warnings
clearOldNdefs = {
    Server.default.bind({
        if(Ndef(\chainA).notNil) { Ndef(\chainA).clear(0) };
        if(Ndef(\chainB).notNil) { Ndef(\chainB).clear(0) };
        if(Ndef(\ts0).notNil)    { Ndef(\ts0).clear(0) };
        if(Ndef(\testmelody).notNil) { Ndef(\testmelody).clear(0) };
    });
};


// 6) Build sinks and sources (server ops)
buildAudio = {
    Server.default.bind({
        // Sinks: read \in.ar(defaultNumChannels)
        Ndef(\chainA, { \in.ar(numChConst) }); Ndef(\chainA).ar(numChConst);
        Ndef(\chainB, { \in.ar(numChConst) }); Ndef(\chainB).ar(numChConst);

        // Sources: NEXT-safe silent + generated test melody
        Ndef(\ts0, { Silent.ar(numChConst) }); Ndef(\ts0).ar(numChConst);

        Ndef(\testmelody, {
            var trig, seq, f, env, tone, pan;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(numChConst);
    });
    log.("sinks + sources defined");
};

// 7) Create GUI + MPB (meters OFF initially). (We call this inside AppClock Routine)
makeGuiAndMpb = {
    ~gui = MagicDisplayGUI.new;
    ~mpb = MagicPedalboardNew.new(~gui);
    if(~gui.respondsTo(\enableMeters)) { ~gui.enableMeters(false) };
    if(~pedalboard.isNil and: { ~mpb.notNil }) { ~pedalboard = ~mpb };
    log.("GUI + MPB created (meters off)");
};

// 8) Detect a **server restart** after MPB creation; wait for it and re-publish graph
waitForServerDownThenUp = {
    var sawDown, t0, timeout, bootKickSent, stableCount, stableNeeded;
    sawDown = false;
    t0 = Main.elapsedTime;
    timeout = 10.0;
    bootKickSent = false;
    stableCount = 0;
    stableNeeded = 5; // 5 * 0.2s = 1.0s of stable running

    // Observe the server for up to 10 seconds; if it goes down, wait until it comes back
    while({
        (Main.elapsedTime - t0) < timeout and: { stableCount < stableNeeded }
    }, {
        0.20.wait;

        if(s.serverRunning.not) {
            sawDown = true;
            stableCount = 0;

            // If it doesn't auto-boot within ~1s, kick a boot
            if((Main.elapsedTime - t0) > 1.0 and: { bootKickSent.not }) {
                "WARNING: server not running → booting server…".postln;
                s.boot;
                bootKickSent = true;
            };
        }{
            // server is running now
            stableCount = stableCount + 1;
        };
    });

    if(sawDown) {
        // If it was down during the window, make sure it's fully up
        if(s.serverRunning.not) {
            "WARNING: waiting for server to come up…".postln;
            s.boot;  // safe to call even if already booting
            s.waitForBoot;
        }{
            // give it a tiny settle and request notifications (optional but nice)
            0.20.wait;
            s.notify;
        };

        // Re-publish meter defs and audio graph after the reboot
        ensureMeterDefs.value;
        clearOldNdefs.value;
        buildAudio.value;

        // Give MPB a chance to rebuild its server tree if it does so lazily
        0.20.wait;
        if(~mpb.respondsTo(\rebuild)) { ~mpb.rebuild(\current) };
        0.20.wait;
    };
};


// 9) Baseline + robust play with retry (ensures MPB has built server groups)
baselinePlayWithRetry = {
    var attempts, ok;
    attempts = 0;
    ok = false;

    while({ (attempts < 4) and: { ok.not } }, {
        ~mpb.setSourceCurrent(\testmelody);
        ~mpb.playCurrent;
        ~mpb.enforceExclusiveCurrentOptionA(0.1);  // NEXT silenced at source (Option A)

        0.30.wait; // allow bundles to land
        ok = Ndef(\chainA).isPlaying;

        attempts = attempts + 1;
        if(ok) {
            log.("baseline set: CURRENT=\\testmelody (Option A)");
        }{
            ("[RETRY] playCurrent attempt % failed; retrying…".format(attempts)).postln;
            if(~mpb.respondsTo(\rebuild)) { ~mpb.rebuild(\current) };
            0.30.wait;
        };
    });

    if(ok.not) {
        "[WARN] playCurrent did not report Ndef(\\chainA).isPlaying=true after retries".postln;
    };
};

// 10) Meters ON (ensure defs just-in-time)
metersOn = {
    ensureMeterDefs.value; // idempotent safety
    if(~gui.respondsTo(\enableMeters)) { ~gui.enableMeters(true) };
    log.("meters enabled");
};

// 11) Verify final state
verify = {
    ~mpb.printChains;
    ("[PLAY] A=% B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    checkChainChannels.value;
};

// 11b) Wait for MPB "ready" and then do meters + verify (no fixed sleeps)
waitOnMpbReady = {
    var onReady;  // var-first in outer function

    onReady = {
        var a, b;  // var-first in inner function/closure

        // meters on only when sinks are AR and CURRENT is playing
        if(~gui.respondsTo(\enableMeters)) { ~gui.enableMeters(true) };

        ~mpb.printChains;

        ("[PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

        // channel sanity print
        a = Ndef(\chainA).tryPerform(\numChannels);
        b = Ndef(\chainB).tryPerform(\numChannels);
        ("[CHECK] Ndef chain channels → A:% , B:%".format(a, b)).postln;
    };

    // use the new class helper; no sleeps here
    ~mpb.waitUntilReady(2.5, 0.05, onReady);
};


// --- Execute clean sequence in one AppClock Routine --------------------------
runSequence = {
    var waitPreGUI, waitAfterMPB;
    waitPreGUI  = 0.05; // small settle between bundles
    waitAfterMPB = 0.15; // short window for GUI-created side effects

    Routine({
        // 0) Hygiene
        closeGuiWindows.value;

        // 1) Fresh boot + clean tree
        freshBoot.value;

        // 2) Predefine meter SynthDefs post-boot (safe re-add)
        // ensureMeterDefs.value;
		MagicDisplay.setMeterChannels(numChConst);

        // 3) Start clean, then build audio graph
        clearOldNdefs.value;
        buildAudio.value;

        // 4) Create GUI + MPB (this may quit the server in its init)
        waitPreGUI.wait;
        makeGuiAndMpb.value;

        // 5) Watch for server going down and coming back; then re-publish defs/graph
        waitAfterMPB.wait;    // allow immediate /quit to show up
        waitForServerDownThenUp.value;
// 6) Baseline + robust play (kept, since it launches CURRENT deterministically)
baselinePlayWithRetry.value;
// 7–8) Wait on a real MPB condition, then meters + verify (no fixed sleeps)
waitOnMpbReady.value;

    }).play(AppClock);
};

// Kick off the sequence
runSequence.value;
)
// Strict_Reset_To_Exclusive_Audible.scd
// v0.1
// MD 20250917-1145
//
// Purpose: Deterministic recovery: disable meters, hard-reset MPB to A=current/B=next,
// define stereo ts0 (Silent) and testmelody, enforce Option A, re-enable meters,
// verify A XOR B is true.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, disableMeters, defineStereoTs0, defineTestMelody, doReset, enforceExclusive, enableMeters, verify;

log = { arg s; ("[STRICT] " ++ s).postln };

disableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        AppClock.sched(0.0, { ~gui.enableMeters(false); nil });
        AppClock.sched(0.05, { ~gui.enableMeters(false); nil });
        log.("meters disabled");
    };
};

defineStereoTs0 = {
    Server.default.bind({
        Ndef(\ts0, { Silent.ar(2) });  // NEXT-safe, stereo
        Ndef(\ts0).ar(2);
    });
    log.("\\ts0 set to stereo Silent");
};

defineTestMelody = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(3.2);
            var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            var f    = Demand.kr(trig, 0, seq);
            var env  = Decay2.kr(trig, 0.01, 0.35);
            var tone = SinOsc.ar(f) * env * 0.25;
            var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
    log.("\\testmelody ensured (stereo)");
};

doReset = {
    // Reset reinitialises chainA/B lists and calls the class logic that enforces exclusivity at end.
    ~mpb.reset;
    log.("mpb.reset done");
};

enforceExclusive = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;                        // MPB already enforces Option A post-play
    ~mpb.enforceExclusiveCurrentOptionA(0.1); // belt-and-braces
    log.("Option A exclusivity asserted");
};

enableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(true);             // guards for AR buses and re-sends SynthDefs
        log.("meters re-enabled");
    };
};

verify = {
    AppClock.sched(0.30, {
        var a = Ndef(\chainA).isPlaying;
        var b = Ndef(\chainB).isPlaying;
        ("[STRICT] [PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

disableMeters.value;
defineStereoTs0.value;
defineTestMelody.value;
doReset.value;
enforceExclusive.value;
enableMeters.value;
verify.value;
)
// Switch_VerifyCurrentAudible_OptionA.scd
// v0.1
// MD 20250917-1320
//
// Purpose: After switching, ensure CURRENT sink is audibly playing and NEXT is ended,
//          without altering any sink sources. Non-intrusive.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, enforce;

log = { arg s; ("[SWCHK] " ++ s).postln };

enforce = {
    var cur = ~mpb.currentChain[0], nxt = ~mpb.nextChain[0];
    Server.default.bind({
        // Make CURRENT audible
        Ndef(cur).mold(2, \audio);
        if(Ndef(cur).isPlaying.not) { Ndef(cur).play(numChannels: 2) };

        // Make NEXT cleanly inactive (flag false), keep stereo shape
        Ndef(nxt).end;
        Ndef(nxt).mold(2, \audio);
    });
    AppClock.sched(0.25, {
        var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
        ("[SWCHK] [PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

enforce.value;
)
// switchDelayCheck.scd
// v0.1
// MD 20250916

(
// Goal: add \delay to NEXT, switch with a crossfade, and confirm audio continues on CURRENT.

// --- Preconditions: GUI + MPB exist; audibleSanity.scd already run today. ---

var log, cleanupDirectPlays, prepStatus, addDelayToNext, doSwitch, afterSwitchCheck, recoverIfSilent;

log = { arg m; ("[switchDelay] " ++ m).postln };

cleanupDirectPlays = {
    // ensure no direct-to-out play is active for the generator
    if(Ndef(\testmelody).isPlaying) { Ndef(\testmelody).stop; log.("stopped direct \\testmelody") };
};

prepStatus = {
    ~mpb.printChains;
    ("[before] A=%  B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
};

addDelayToNext = {
    ~mpb.clearChain;            // keep NEXT minimal before adding
    ~mpb.add(\delay);           // add to NEXT
    ~mpb.printChains;
};

doSwitch = {
    ~mpb.switchChain(0.12);     // short crossfade; CURRENT <-> NEXT
};

afterSwitchCheck = {
    AppClock.sched(0.35, {
        ~mpb.printChains;
        ("[after]  A=%  B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

// If for any reason we went silent, rebuild connections & enforce CURRENT-only play.
// (Equivalent to your enforceExclusiveCurrentNow utilities)
recoverIfSilent = {
    AppClock.sched(0.60, {
        var curEff, curSink;
        curEff = ~mpb.effectiveCurrent;
        curSink = curEff[0];
        Server.default.bind({
            ~mpb.rebuildUnbound(~mpb.currentChain);
            ~mpb.rebuildUnbound(~mpb.nextChain);
            // enforce exclusive current
            if(curSink == \chainA) {
                if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
                if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
            }{
                if(Ndef(\chainA).isPlaying) { Ndef(\chainA).stop };
                if(Ndef(\chainB).isPlaying.not) { Ndef(\chainB).play(numChannels: 2) };
            };
        });
        log.("reconnect enforced, currentEff=" ++ curEff);
        nil
    });
};

// --- run steps ---
cleanupDirectPlays.value;
prepStatus.value;
addDelayToNext.value;
doSwitch.value;
afterSwitchCheck.value;
recoverIfSilent.value;
)
// test_editor_commandtree_add_demo_verbs_part_a.scd
// v0.1
// MD 20250916-0919

(
var jsonPath, loadOk, tree, getNodeByPath, assert, expectPath, pathsToCheck, passCount, failCount, countAfter, summary;

jsonPath = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
passCount = 0;
failCount = 0;

assert = { arg condition, label;
    var statusText;
    statusText = if(condition) { "PASS" } { "FAIL" };
    ("[TEST] " ++ statusText ++ " — " ++ label).postln;
    if(condition) { passCount = passCount + 1 } { failCount = failCount + 1 };
};

getNodeByPath = { arg treeRef, nameList;
    var foundNode;
    foundNode = treeRef.getNodeByNamePath(nameList);
    foundNode
};

expectPath = { arg treeRef, nameList;
    var nodeRef, lastName, hasNode, payloadMatches;
    nodeRef = getNodeByPath.(treeRef, nameList);
    lastName = nameList.last;
    hasNode = nodeRef.notNil;
    assert.(hasNode, "exists: " ++ nameList.join(" → "));
    if(hasNode) {
        payloadMatches = (nodeRef.payload == lastName);
        assert.(payloadMatches, "payload==name for: " ++ nameList.join(" → "));
    };
};

// 1) Load tree
tree = MDCommandTree.new;
loadOk = tree.importJSONFile(jsonPath);
assert.(loadOk, "JSON loaded from " ++ jsonPath);

// 2) Expected paths created by the editor script
pathsToCheck = [
    ["commands"],
    ["commands","add","delay"],
    ["commands","add","chorus"],
    ["commands","add","reverb"],
    ["commands","add","tremolo"],
    ["commands","bypass","delay","on"],
    ["commands","bypass","delay","off"],
    ["commands","switch"],
    ["commands","setSource","testmelody"]
];

// 3) Check each path exists and payload==name
pathsToCheck.do({ arg nameList; expectPath.(tree, nameList) });

// 4) Record node map size (for idempotency comparison later)
countAfter = tree.nodeMap.size;
~ct_nodecount_after_first = countAfter;  // store globally for Part B
("[TEST] nodeMap.size after first run = " ++ countAfter).postln;

// 5) Summary
summary = "[TEST] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount;
summary.postln;
)
// test_editor_commandtree_add_demo_verbs_part_b.scd
// v0.1
// MD 20250916-0920

(
var jsonPath, loadOk, tree, countBefore, countAfter, assert, summary, passCount, failCount;

jsonPath = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
passCount = 0; failCount = 0;

assert = { arg condition, label;
    var statusText;
    statusText = if(condition) { "PASS" } { "FAIL" };
    ("[TEST] " ++ statusText ++ " — " ++ label).postln;
    if(condition) { passCount = passCount + 1 } { failCount = failCount + 1 };
};

// 0) Precondition: you just re-ran editor_commandtree_add_demo_verbs.scd
// 1) Reload tree
tree = MDCommandTree.new;
loadOk = tree.importJSONFile(jsonPath);
assert.(loadOk, "JSON reloaded");

// 2) Compare node counts
countBefore = ~ct_nodecount_after_first ? -1;
countAfter  = tree.nodeMap.size;

("[TEST] nodeMap.size first=" ++ countBefore ++ " second=" ++ countAfter).postln;

// Expectation: no new nodes created on second run (idempotent)
assert.(countBefore == countAfter, "idempotent: nodeMap size unchanged after second run");

// 3) Summary
summary = "[TEST] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount;
summary.postln;
)
/*
 * Test_MagicDisplayGUI_AllInOne_Monolithic.scd v0.10
 * Single top-level block = no "unexpected '('" parse issue.
 *
 * Contents
 *  - Section A: Test_MagicDisplayGUI_BootAndScenarios.scd v0.4 (verbatim)
 *  - Section B: Test_MagicDisplayGUI_Scenarios.scd v0.5 (verbatim)
 *  - Section C: Test_MagicDisplayGUI_InlineInstrument.scd v0.2 (verbatim)
 *  - Section D: Resilient UI-queue patch + v6 aliases + one-button runner
 *
 * Style respected:
 *  - tilde vars, var-first in each block, lowercase names
 *  - no server.sync, explicit AppClock scheduling for UI work (.defer)
 */

(
// ======================================================================
// Section A — Test_MagicDisplayGUI_BootAndScenarios.scd v0.4 (verbatim)
// ======================================================================

// ---------- shared helpers ------------------------------------------------
~postState = { |labelString|
    var curr, nxt;
    curr = ~mpb.tryPerform(\currentChain);
    nxt = ~mpb.tryPerform(\nextChain);
    ("[STATE] " ++ labelString ++ " → current=" ++ curr.asString
        ++ "  next=" ++ nxt.asString).postln;
};

~drawOnce = {
    var curr, nxt, bypassA, bypassB, effA, effB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    curr = ~mpb.currentChain;
    nxt = ~mpb.nextChain;
    bypassA = ~mpb.bypassKeysCurrent;
    bypassB = ~mpb.bypassKeysNext;
    effA = ~mpb.effectiveCurrent;
    effB = ~mpb.effectiveNext;
    // GUI method that actually updates the lists/labels
    ~gui.showChainsDetailed(curr, nxt, bypassA, bypassB, effA, effB);
};

~refreshView = { |labelString|
    ~postState.(labelString);
    // Console view via MPB (also calls showChainsDetailed under the hood)
    ~mpb.printChains;
    // Explicit GUI redraw (belt-and-braces)
    ~drawOnce.();
};

// ---------- robust boot: wait for window, then first draw ----------------
~bootGuiV4 = {
    var guiObj, board, maxPollCount, pollDelaySeconds, routine;
    // stop any previous tasks
    ~mdgTask.notNil.if { ~mdgTask.stop; ~mdgTask = nil };
    ~bootTask.notNil.if { ~bootTask.stop; ~bootTask = nil };

    // create GUI and disable meters (avoid server dependency)
    guiObj = MagicDisplayGUI.new;
    guiObj.enableMeters(false);

    // create pedalboard and attach display
    board = MagicPedalboardNew(guiObj);
    ~gui = guiObj;
    ~mpb = board;

    // poll for the window (it is built asynchronously on AppClock)
    maxPollCount = 200; // up to ~10 seconds
    pollDelaySeconds = 0.05;
    routine = Routine {
        var pollCount;
        pollCount = 0;
        while({ (~gui.window.isNil) and: { pollCount < maxPollCount } }, {
            pollCount = pollCount + 1;
            pollDelaySeconds.wait; // SystemClock here; avoids AppClock contention
        });
        defer({
            if(~gui.window.notNil) {
                "Window ready — fronting and drawing columns.".postln;
                ~gui.window.front;
            }{
                "Window did not appear in time (10 s).".warn;
            };
            ~refreshView.("boot");
        });
    };
    ~bootTask = Task(routine, SystemClock).play; // use SystemClock for the polling loop
    "Booting GUI (meters disabled). Waiting for window…".postln;
};

// bring GUI to front later if needed
~frontGui = {
    if(~gui.notNil and: { ~gui.window.notNil }) { ~gui.window.front };
};

// stop any running scenario
~stopScenarios = {
    var runningTask;
    runningTask = ~mdgTask;
    if(runningTask.notNil) { runningTask.stop; ~mdgTask = nil; };
    "Stopped scenario task (if any).".postln;
};

// ---------- Scenarios (run on SystemClock, post step labels) -------------
~scenario1v4 = {
    var routine, waitSeconds, steps, totalSteps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitSeconds = 0.8;
    steps = [
        { "[SC1] init".postln; ~refreshView.("SC1/init") },
        { "[SC1] add flanger".postln;
          ~mpb.add(\flanger);
          ~refreshView.("SC1/add flanger") },
        { "[SC1] bypass flanger → true".postln;
          ~mpb.bypass(\flanger, true);
          ~refreshView.("SC1/bypass flanger true") },
        { "[SC1] add delay".postln;
          ~mpb.add(\delay);
          ~refreshView.("SC1/add delay") },
        { "[SC1] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC1/clear NEXT") }
    ];
    totalSteps = steps.size;
    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };
    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play; // SystemClock: robust in headless/server-off
    ~mdgTask
};

~scenario2v4 = {
    var routine, waitSeconds, steps, totalSteps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitSeconds = 0.25;
    steps = [
        { "[SC2] init".postln; ~refreshView.("SC2/init") },
        { "[SC2] add chorus".postln; ~mpb.add(\chorus); ~refreshView.("SC2/add chorus") },
        { "[SC2] add reverb".postln; ~mpb.add(\reverb); ~refreshView.("SC2/add reverb") },
        { "[SC2] add tremolo".postln; ~mpb.add(\tremolo); ~refreshView.("SC2/add tremolo") },
        { "[SC2] removeAt 2".postln; ~mpb.removeAt(2); ~refreshView.("SC2/removeAt 2") },
        { "[SC2] add phaser".postln; ~mpb.add(\phaser); ~refreshView.("SC2/add phaser") },
        { "[SC2] clear NEXT".postln; ~mpb.clearChain; ~refreshView.("SC2/clear NEXT") }
    ];
    totalSteps = steps.size;
    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };
    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};

~scenario3v4 = {
    var routine, waitSeconds, steps, totalSteps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitSeconds = 0.6;
    steps = [
        { "[SC3] init".postln; ~refreshView.("SC3/init") },
        { "[SC3] add bitcrusher".postln;
          ~mpb.add(\bitcrusher);
          ~refreshView.("SC3/add bitcrusher") },
        { "[SC3] bypass bitcrusher → false".postln;
          ~mpb.bypass(\bitcrusher, false);
          ~refreshView.("SC3/bypass bitcrusher false") },
        { "[SC3] removeAt 1 (if exists)".postln;
          ~mpb.removeAt(1);
          ~refreshView.("SC3/removeAt 1") },
        { "[SC3] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC3/clear NEXT") }
    ];
    totalSteps = steps.size;
    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };
    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};


// ======================================================================
// Section B — Test_MagicDisplayGUI_Scenarios.scd v0.5 (verbatim)
// ======================================================================

~log = { |msg| ("[SC] " ++ msg).postln };

~refreshGuiFromMpb = {
    var curr, nxt, bA, bB, eA, eB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    curr = ~mpb.currentChain; nxt = ~mpb.nextChain;
    bA = ~mpb.bypassKeysCurrent; bB = ~mpb.bypassKeysNext;
    eA = ~mpb.effectiveCurrent; eB = ~mpb.effectiveNext;
    ~gui.showChainsDetailed(curr, nxt, bA, bB, eA, eB);
};

~scenario1v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.8;
    steps = [
        { ~log.("init"); ~gui.showExpectation("Command: init", 0); ~refreshGuiFromMpb.() },
        { ~log.("add flanger"); ~gui.showExpectation("Command: add flanger", 0); ~mpb.add(\flanger); ~refreshGuiFromMpb.() },
        { ~log.("bypass flanger true"); ~gui.showExpectation("Command: bypass flanger true", 0); ~mpb.bypass(\flanger, true); ~refreshGuiFromMpb.() },
        { ~log.("add delay"); ~gui.showExpectation("Command: add delay", 0); ~mpb.add(\delay); ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT"); ~gui.showExpectation("Command: clear NEXT", 0); ~mpb.clearChain; ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario2v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.25;
    steps = [
        { ~log.("init"); ~gui.showExpectation("Command: init", 0); ~refreshGuiFromMpb.() },
        { ~log.("add chorus"); ~gui.showExpectation("Command: add chorus", 0); ~mpb.add(\chorus); ~refreshGuiFromMpb.() },
        { ~log.("add reverb"); ~gui.showExpectation("Command: add reverb", 0); ~mpb.add(\reverb); ~refreshGuiFromMpb.() },
        { ~log.("add tremolo"); ~gui.showExpectation("Command: add tremolo", 0); ~mpb.add(\tremolo); ~refreshGuiFromMpb.() },
        { ~log.("removeAt 2"); ~gui.showExpectation("Command: removeAt 2", 0); ~mpb.removeAt(2); ~refreshGuiFromMpb.() },
        { ~log.("add phaser"); ~gui.showExpectation("Command: add phaser", 0); ~mpb.add(\phaser); ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT"); ~gui.showExpectation("Command: clear NEXT", 0); ~mpb.clearChain; ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario3v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.6;
    steps = [
        { ~log.("init"); ~gui.showExpectation("Command: init", 0); ~refreshGuiFromMpb.() },
        { ~log.("add bitcrusher"); ~gui.showExpectation("Command: add bitcrusher", 0); ~mpb.add(\bitcrusher); ~refreshGuiFromMpb.() },
        { ~log.("bypass bitcrusher false"); ~gui.showExpectation("Command: bypass bitcrusher false", 0); ~mpb.bypass(\bitcrusher, false); ~refreshGuiFromMpb.() },
        { ~log.("removeAt 1"); ~gui.showExpectation("Command: removeAt 1", 0); ~mpb.removeAt(1); ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT"); ~gui.showExpectation("Command: clear NEXT", 0); ~mpb.clearChain; ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};


// ======================================================================
// Section C — Test_MagicDisplayGUI_InlineInstrument.scd v0.2 (verbatim)
// ======================================================================

~probeGuiV2 = {
    var hasGui, hasWin, current, next, bypassA, bypassB, effA, effB;
    hasGui = ~gui.notNil;
    if(hasGui.not) { "No ~gui. Run ~bootGuiV4.() first.".warn; ^nil };
    hasWin = ~gui.tryPerform(\window).notNil;
    ["[PROBE] gui exists:", hasGui, "window exists:", hasWin].postln;

    // very distinctive frame so you can spot it instantly
    current = [\chainA, \AAA_debug_one, \BBB_debug_two, \ts0];
    next    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];
    bypassA = [\BBB_debug_two];
    bypassB = [];
    effA    = [\chainA, \AAA_debug_one, \ts0];
    effB    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];

    // make the "Command:" box change as well (immediate visible cue)
    ~gui.showExpectation("Command: PROBE FRAME", 0);

    // schedule list redraw on AppClock (same thread your GUI uses internally)
    AppClock.sched(0, {
        "[PROBE] Calling showChainsDetailed on AppClock…".postln;
        ~gui.showChainsDetailed(current, next, bypassA, bypassB, effA, effB);
        "[PROBE] showChainsDetailed returned.".postln;
        nil
    });

    "Probe queued. Expect 'PROBE FRAME' in the Command area and AAA/BBB/CCC/DDD items in the lists."
    .postln;
};


// ======================================================================
// Section D — Patch + v6 Aliases + One-button Runner
// ======================================================================

// Resilient UI-queue patch: make queued UI work run immediately on AppClock
~md_applyQueueUiPatch = {
    var displayCandidates, candidateIndex, candidate, patched, proofFun;

    patched = false;
    displayCandidates = [];

    // Prefer ~magicDisplay if present; fallback to ~gui
    if(~magicDisplay.notNil) { displayCandidates = displayCandidates.add(~magicDisplay) };
    if(~gui.notNil)          { displayCandidates = displayCandidates.add(~gui) };

    if(displayCandidates.isEmpty) {
        "[PATCH] No display object (~magicDisplay or ~gui) yet; run boot first.".postln;
        ^false
    };

    candidateIndex = 0;
    while({ candidateIndex < displayCandidates.size and: { patched.not } }, {
        candidate = displayCandidates[candidateIndex];

        // Try setter first (slot/property on an object)
        if(candidate.respondsTo(\queueUi_)) {
            candidate.queueUi = { |selfArg, fun| fun.defer };  // UI-safe immediate
            patched = true;
        }{
            // Try dictionary/event-like storage
            if(candidate.respondsTo(\atPut)) {
                candidate[\queueUi] = { |ignoredSelf, fun| fun.defer }; // UI-safe immediate
                patched = true;
            };
        };

        candidateIndex = candidateIndex + 1;
    });

    if(patched) {
        "[PATCH] queueUi patched to immediate (.defer)".postln;

        // Proof-of-life
        if(candidate.respondsTo(\queueUi)) {
            candidate.queueUi({ "[CHECK] queueUi immediate hit".postln });
        }{
            if(candidate.respondsTo(\at)) {
                proofFun = candidate[\queueUi];
                if(proofFun.isKindOf(Function)) {
                    proofFun.value(candidate, { "[CHECK] queueUi immediate hit".postln });
                };
            };
        };
        ^true
    }{
        "[PATCH] Display found but exposes neither queueUi_ nor atPut; not patched.".postln;
        ^false
    };
};

// Wait-and-patch helper: polls until a display is available, then applies patch
~md_waitAndPatchQueueUiImmediate = {
    var attempts, maxAttempts, stepSeconds, routineInstance;

    attempts = 0;
    maxAttempts = 200;     // ~10 seconds at 0.05s
    stepSeconds = 0.05;

    routineInstance = Routine({
        "[PATCH] Waiting for display (~magicDisplay or ~gui)…".postln;
        while({ attempts < maxAttempts }, {
            if(~magicDisplay.notNil or: { ~gui.notNil }) {
                if(~md_applyQueueUiPatch.()) {
                    thisThread.stop;
                };
            };
            attempts = attempts + 1;
            stepSeconds.wait;
        });
        "[PATCH] Timed out waiting for display; run ~md_waitAndPatchQueueUiImmediate.() again after boot."
        .postln;
    }).play(AppClock);

    routineInstance
};

// v6-style aliases wrapping your existing definitions
~bootGuiV6 = {
    var booted;
    booted = false;
    if(~bootGuiV4.notNil) {
        ~bootGuiV4.();
        booted = true;
    }{
        "Missing ~bootGuiV4; please check Section A definitions.".warn;
    };

    // Start the wait-and-patch watcher right after boot
    if(booted) {
        ~md_waitAndPatchQueueUiImmediate.();
    };
};

~scenario1v6 = { if(~scenario1v5.notNil) { ~scenario1v5.() }{ if(~scenario1v4.notNil) { ~scenario1v4.() }{ "No scenario1 function found.".warn }} };
~scenario2v6 = { if(~scenario2v5.notNil) { ~scenario2v5.() }{ if(~scenario2v4.notNil) { ~scenario2v4.() }{ "No scenario2 function found.".warn }} };
~scenario3v6 = { if(~scenario3v5.notNil) { ~scenario3v5.() }{ if(~scenario3v4.notNil) { ~scenario3v4.() }{ "No scenario3 function found.".warn }} };

~probeGuiV3 = { if(~probeGuiV2.notNil) { ~probeGuiV2.() }{ "No probe function (~probeGuiV2) found.".warn } };

// One-button runner: boot → patch → probe → scenario
~md_go = {
    var bootTask;
    bootTask = Task({
        "[ALL-IN-ONE] Booting GUI (v6 alias)…".postln;
        ~bootGuiV6.();

        // small wait for "Window ready…" to appear
        0.5.wait;

        if(~probeGuiV3.notNil) {
            "[ALL-IN-ONE] Running probe (~probeGuiV3)…".postln;
            ~probeGuiV3.();
        };

        0.2.wait;

        if(~scenario1v6.notNil) {
            "[ALL-IN-ONE] Running scenario (~scenario1v6)…".postln;
            ~scenario1v6.();
        };
    });
    bootTask.start;
    bootTask
};

// Session banner
"[ALL-IN-ONE] Ready. Typical flow:\n  1) ~bootGuiV6.();\n  2) ~md_waitAndPatchQueueUiImmediate.();\n  3) ~probeGuiV3.();\n  4) ~scenario1v6.();\nOr just run: ~md_go.();"
.postln;

) // <— single top-level block ends here
/* Test_MagicDisplayGUI_BootAndScenarios.scd v0.4
   Purpose: Deterministic boot (meters OFF), wait for window, then scenarios that
            clearly post progress AND force GUI redraws every step.

   Style: tilde vars, var-first, lowercase names, no server.sync, no single-letter locals.
*/

(
// ---------- shared helpers ----------------------------------------------------

~postState = { |labelString|
    var curr, nxt;
    curr = ~mpb.tryPerform(\currentChain);
    nxt  = ~mpb.tryPerform(\nextChain);
    ("[STATE] " ++ labelString ++ " → current=" ++ curr.asString
        ++ " | next=" ++ nxt.asString).postln;
};

~drawOnce = {
    var curr, nxt, bypassA, bypassB, effA, effB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    curr    = ~mpb.currentChain;
    nxt     = ~mpb.nextChain;
    bypassA = ~mpb.bypassKeysCurrent;
    bypassB = ~mpb.bypassKeysNext;
    effA    = ~mpb.effectiveCurrent;
    effB    = ~mpb.effectiveNext;

    // GUI method that actually updates the lists/labels
    ~gui.showChainsDetailed(curr, nxt, bypassA, bypassB, effA, effB);
};

~refreshView = { |labelString|
    ~postState.(labelString);
    // Console view via MPB (also calls showChainsDetailed under the hood)
    ~mpb.printChains;
    // Explicit GUI redraw (belt-and-braces)
    ~drawOnce.();
};

// ---------- robust boot: wait for window, then first draw --------------------

~bootGuiV4 = {
    var guiObj, board, maxPollCount, pollDelaySeconds, routine;

    // stop any previous tasks
    ~mdgTask.notNil.if { ~mdgTask.stop; ~mdgTask = nil };
    ~bootTask.notNil.if { ~bootTask.stop; ~bootTask = nil };

    // create GUI and disable meters (avoid server dependency)
    guiObj = MagicDisplayGUI.new;
    guiObj.enableMeters(false);

    // create pedalboard and attach display
    board = MagicPedalboardNew(guiObj);
    ~gui = guiObj;
    ~mpb = board;

    // poll for the window (it is built asynchronously on AppClock)
    maxPollCount = 200;          // up to ~10 seconds
    pollDelaySeconds = 0.05;

    routine = Routine {
        var pollCount;
        pollCount = 0;

        while({ (~gui.window.isNil) and: { pollCount < maxPollCount } }, {
            pollCount = pollCount + 1;
            pollDelaySeconds.wait;      // SystemClock here; avoids AppClock contention
        });

        defer({
            if(~gui.window.notNil) {
                "Window ready — fronting and drawing columns.".postln;
                ~gui.window.front;
            }{
                "Window did not appear in time (10 s).".warn;
            };
            ~refreshView.("boot");
        });
    };

    ~bootTask = Task(routine, SystemClock).play; // use SystemClock for the polling loop
    "Booting GUI (meters disabled). Waiting for window…".postln;
};

// bring GUI to front later if needed
~frontGui = {
    if(~gui.notNil and: { ~gui.window.notNil }) { ~gui.window.front };
};

// stop any running scenario
~stopScenarios = {
    var runningTask;
    runningTask = ~mdgTask;
    if(runningTask.notNil) { runningTask.stop; ~mdgTask = nil; };
    "Stopped scenario task (if any).".postln;
};

// ---------- Scenarios (run on SystemClock, post step labels) -----------------

~scenario1v4 = {
    var routine, waitSeconds, steps, totalSteps;

    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    waitSeconds = 0.8;

    steps = [
        { "[SC1] init".postln; ~refreshView.("SC1/init") },

        { "[SC1] add flanger".postln;
          ~mpb.add(\flanger);
          ~refreshView.("SC1/add flanger") },

        { "[SC1] bypass flanger → true".postln;
          ~mpb.bypass(\flanger, true);
          ~refreshView.("SC1/bypass flanger true") },

        { "[SC1] add delay".postln;
          ~mpb.add(\delay);
          ~refreshView.("SC1/add delay") },

        { "[SC1] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC1/clear NEXT") }
    ];

    totalSteps = steps.size;

    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;   // SystemClock: robust in headless/server-off
    ~mdgTask
};

~scenario2v4 = {
    var routine, waitSeconds, steps, totalSteps;

    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    waitSeconds = 0.25;

    steps = [
        { "[SC2] init".postln; ~refreshView.("SC2/init") },
        { "[SC2] add chorus".postln;  ~mpb.add(\chorus);  ~refreshView.("SC2/add chorus") },
        { "[SC2] add reverb".postln;  ~mpb.add(\reverb);  ~refreshView.("SC2/add reverb") },
        { "[SC2] add tremolo".postln; ~mpb.add(\tremolo); ~refreshView.("SC2/add tremolo") },
        { "[SC2] removeAt 2".postln;  ~mpb.removeAt(2);   ~refreshView.("SC2/removeAt 2") },
        { "[SC2] add phaser".postln;  ~mpb.add(\phaser);  ~refreshView.("SC2/add phaser") },
        { "[SC2] clear NEXT".postln;  ~mpb.clearChain;    ~refreshView.("SC2/clear NEXT") }
    ];

    totalSteps = steps.size;

    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};

~scenario3v4 = {
    var routine, waitSeconds, steps, totalSteps;

    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    waitSeconds = 0.6;

    steps = [
        { "[SC3] init".postln; ~refreshView.("SC3/init") },

        { "[SC3] add bitcrusher".postln;
          ~mpb.add(\bitcrusher);
          ~refreshView.("SC3/add bitcrusher") },

        { "[SC3] bypass bitcrusher → false".postln;
          ~mpb.bypass(\bitcrusher, false);
          ~refreshView.("SC3/bypass bitcrusher false") },

        { "[SC3] removeAt 1 (if exists)".postln;
          ~mpb.removeAt(1);
          ~refreshView.("SC3/removeAt 1") },

        { "[SC3] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC3/clear NEXT") }
    ];

    totalSteps = steps.size;

    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};
)
/* Test_MagicDisplayGUI_InlineInstrument.scd v0.2
   Goal: verify that MagicDisplayGUI executes UI updates on AppClock and
         that a single forced frame appears in the lists and "Command:" area.
*/

(
~probeGuiV2 = {
    var hasGui, hasWin, current, next, bypassA, bypassB, effA, effB;

    hasGui = ~gui.notNil;
    if(hasGui.not) { "No ~gui. Run ~bootGuiV4.() first.".warn; ^nil };

    hasWin = ~gui.tryPerform(\window).notNil;

    ["[PROBE] gui exists:", hasGui, "window exists:", hasWin].postln;

    // very distinctive frame so you can spot it instantly
    current = [\chainA, \AAA_debug_one, \BBB_debug_two, \ts0];
    next    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];
    bypassA = [\BBB_debug_two];
    bypassB = [];
    effA    = [\chainA, \AAA_debug_one, \ts0];
    effB    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];

    // make the "Command:" box change as well (immediate visible cue)
    ~gui.showExpectation("Command: PROBE FRAME", 0);

    // schedule list redraw on AppClock (same thread your GUI uses internally)
    AppClock.sched(0, {
        "[PROBE] Calling showChainsDetailed on AppClock…".postln;
        ~gui.showChainsDetailed(current, next, bypassA, bypassB, effA, effB);
        "[PROBE] showChainsDetailed returned.".postln;
        nil
    });

    "Probe queued. Expect 'PROBE FRAME' in the Command area and AAA/BBB/CCC/DDD items in the lists."
    .postln;
};
)
/* Test_MagicDisplayGUI_Scenarios.scd v0.5
   Very explicit scenarios: log each step, update "Command:", then force GUI redraw.
*/

(
~log = { |msg| ("[SC] " ++ msg).postln };

~refreshGuiFromMpb = {
    var curr, nxt, bA, bB, eA, eB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    curr = ~mpb.currentChain;  nxt = ~mpb.nextChain;
    bA = ~mpb.bypassKeysCurrent; bB = ~mpb.bypassKeysNext;
    eA = ~mpb.effectiveCurrent;  eB = ~mpb.effectiveNext;
    ~gui.showChainsDetailed(curr, nxt, bA, bB, eA, eB);
};

~scenario1v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.8;
    steps = [
        { ~log.("init");               ~gui.showExpectation("Command: init", 0);               ~refreshGuiFromMpb.() },
        { ~log.("add flanger");        ~gui.showExpectation("Command: add flanger", 0);        ~mpb.add(\flanger);       ~refreshGuiFromMpb.() },
        { ~log.("bypass flanger true");~gui.showExpectation("Command: bypass flanger true", 0);~mpb.bypass(\flanger, true);~refreshGuiFromMpb.() },
        { ~log.("add delay");          ~gui.showExpectation("Command: add delay", 0);          ~mpb.add(\delay);         ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT");         ~gui.showExpectation("Command: clear NEXT", 0);         ~mpb.clearChain;          ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario2v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.25;
    steps = [
        { ~log.("init");        ~gui.showExpectation("Command: init", 0);        ~refreshGuiFromMpb.() },
        { ~log.("add chorus");  ~gui.showExpectation("Command: add chorus", 0);  ~mpb.add(\chorus);     ~refreshGuiFromMpb.() },
        { ~log.("add reverb");  ~gui.showExpectation("Command: add reverb", 0);  ~mpb.add(\reverb);     ~refreshGuiFromMpb.() },
        { ~log.("add tremolo"); ~gui.showExpectation("Command: add tremolo", 0); ~mpb.add(\tremolo);    ~refreshGuiFromMpb.() },
        { ~log.("removeAt 2");  ~gui.showExpectation("Command: removeAt 2", 0);  ~mpb.removeAt(2);      ~refreshGuiFromMpb.() },
        { ~log.("add phaser");  ~gui.showExpectation("Command: add phaser", 0);  ~mpb.add(\phaser);     ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT");  ~gui.showExpectation("Command: clear NEXT", 0);  ~mpb.clearChain;       ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario3v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.6;
    steps = [
        { ~log.("init");                 ~gui.showExpectation("Command: init", 0);                 ~refreshGuiFromMpb.() },
        { ~log.("add bitcrusher");       ~gui.showExpectation("Command: add bitcrusher", 0);       ~mpb.add(\bitcrusher);  ~refreshGuiFromMpb.() },
        { ~log.("bypass bitcrusher false");~gui.showExpectation("Command: bypass bitcrusher false", 0); ~mpb.bypass(\bitcrusher, false); ~refreshGuiFromMpb.() },
        { ~log.("removeAt 1");          ~gui.showExpectation("Command: removeAt 1", 0);           ~mpb.removeAt(1);       ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT");           ~gui.showExpectation("Command: clear NEXT", 0);           ~mpb.clearChain;        ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};
)
// testAfterFix.scd
// v0.1
// MD 20250916

// PRE-RUN REQUIRED:
// 1. Recompile class library after editing MagicPedalboardNew.sc
// 2. Run MagicPedalboardNew.scd (if you have a setup/init script)
// 3. Run MagicDisplayGUI.scd to launch GUI
// 4. Run adapter_commandtree_to_magicpedalboard.scd v0.3

(
// Test sequence: add → switch → bypass → switch
~adapter.applyQueue([
    ["commands/add", "delay"],
    ["commands/switch", "chainB"],
    ["commands/bypass", "delay", true],
    ["commands/bypass", "delay", false],
    ["commands/switch", "chainA"]
]);

// Confirm:
// - Audio is audible at each step
// - GUI columns match chain state
// - chainB is stopped unless switching
)
// tool_export_commandtree_with_payloads.scd
// v0.1
// MD 20250916-0956

(
~ct_nodeToDictWithPayload = { arg nodeRef;
    var childDicts, outDict;
    childDicts = Array.new;
    nodeRef.children.do({ arg childNode;
        childDicts = childDicts.add(~ct_nodeToDictWithPayload.(childNode));
    });
    outDict = (
        id: nodeRef.id,
        name: nodeRef.name,
        fret: nodeRef.fret,
        payload: nodeRef.payload,   // <— keep payload
        children: childDicts
    );
    outDict
};

~ct_writeJsonWithPayloads = {
    arg treeRef,
        outPath = "/Users/martindupras/CommandTreeSavefiles/myTree.json",
        writeVersioned = true,
        saveFolder = "/Users/martindupras/CommandTreeSavefiles",
        savePrefix = "myTree";

    var topDict, jsonString;

    // Top-level object: include root payload and nodeLimit if available
    topDict = (
        name: treeRef.root.name,
        id: treeRef.root.id,
        nodeLimit: treeRef.nodeLimit ? 200,
        payload: treeRef.root.payload,
        children: treeRef.root.children.collect({ arg child; ~ct_nodeToDictWithPayload.(child) })
    );

    jsonString = JSONlib.convertToJSON(topDict);

    if(writeVersioned) {
        var saver;
        saver = CircularFileSave.new(savePrefix, saveFolder, 10);
        saver.saveVersion(jsonString);  // versioned copy with payloads preserved
    };

    File.use(outPath.standardizePath, "w", { arg f; f.write(jsonString) });
    ("[CT] Wrote JSON with payloads -> " ++ outPath).postln;
};
)
// tool_xml_to_json_commandtree.scd
// v0.1
// MD 20250916-0850

(
~ct_convertXmlToJson = { arg inPath = "~/myTree.xml", outPath = "~/CommandTreeSavefiles/myTree.json";
    var xmlText, lines, stack, rootDict, currentDict, parseOpen, parseClose, parseAttrs, toJSON;

    inPath = inPath.standardizePath;
    outPath = outPath.standardizePath;

    xmlText = File.readAllString(inPath);
    if(xmlText.isNil or: { xmlText.isEmpty }) { "XML empty or unreadable.".warn; ^false };

    // Helpers
    parseAttrs = { arg tagLine;
        var dict, pairs;
        dict = IdentityDictionary.new;
        // crude attribute parse: key="value"
        pairs = tagLine.findAllRegexp("\"([^\"]*)\"");
        // We walk the string: extract id, name, fret, payload if present
        // Better: regex for key="value" tuples
        tagLine.findAllRegexp("(\\w+)\\s*=\\s*\"([^\"]*)\"").do({ arg m;
            var key = m[1].asString.asSymbol;
            var val = m[2].asString;
            dict[key] = val;
        });
        dict
    };

    parseOpen = { arg line;
        var attrs, dict, idNum, fretNum;
        attrs = parseAttrs.(line);
        dict = (
            id: (attrs[\id] ?? { "0" }).asInteger,
            name: (attrs[\name] ?? { "unnamed" }).asString,
            fret: (attrs[\fret] ?? { "0" }).asInteger,
            payload: (attrs[\payload] ?? { nil }),
            children: Array.new
        );
        dict
    };

    parseClose = { arg stackRef;
        if(stackRef.size > 1, {
            var child = stackRef.pop;
            stackRef.last[\children] = stackRef.last[\children].add(child);
        });
    };

    stack = Array.new;

    // Tokenize lines and handle <node .../> self-close and </node>
    lines = xmlText.replace($\t, $ ).replace($\r, $ ).split($\n);
    lines.do({ arg raw;
        var line = raw.trim;
        if(line.isEmpty) { ^nil };

        if(line.beginsWith("<node") and: { line.endsWith("/>") }) {
            var dict = parseOpen.(line);
            if(stack.isEmpty) { stack.push(dict) } { stack.last[\children] = stack.last[\children].add(dict) };
        }{
            if(line.beginsWith("</node")) {
                parseClose.(stack);
            }{
                if(line.beginsWith("<node")) {
                    stack.push(parseOpen.(line));
                };
            };
        };
    });

    // Close remaining nodes
    while({ stack.size > 1 }, { parseClose.(stack) });

    rootDict = if(stack.size == 1) { stack[0] } { nil };
    if(rootDict.isNil) { "Parse failed (no root)".warn; ^false };

    // Build top-level tree dict for MDCommandTree.fromDict
    currentDict = (
        name: rootDict[\name],
        id: rootDict[\id],
        nodeLimit: 200,
        payload: rootDict[\payload],
        children: rootDict[\children]
    );

    // Write JSON (uses JSONlib from your environment)
    File.use(outPath, "w", { arg f; f.write(JSONlib.convertToJSON(currentDict)) });
    ("[CT] Wrote JSON -> " ++ outPath).postln;
    true
};
)
(
// =========================
// Utils_MagicDisplayGUI_Checks.scd  (single block)
// =========================

~md_checkEnv = {
    var gui_present, queue_ok, setter_ok, atput_ok, win_count, win_titles;
    gui_present = ~gui.notNil;
    queue_ok = gui_present and: { ~gui.respondsTo(\queueUi) };
    setter_ok = gui_present and: { ~gui.respondsTo(\queueUi_) };
    atput_ok = gui_present and: { ~gui.respondsTo(\atPut) };
    win_count = (~md_get_gui_windows.notNil).if({ ~md_get_gui_windows.().size }, { 0 });
    win_titles = (win_count > 0).if({ ~md_get_gui_windows.().collect({ |w| w.name.asString }) }, { [] });
    "[ENV] mpb:% gui:% queueUi:% queueUi_:% atPut:% windows:% titles:%"
        .format(~mpb.notNil, gui_present, queue_ok, setter_ok, atput_ok, win_count, win_titles)
        .postln;
};

~md_appclock_ping = {
    AppClock.sched(0.0, { "[AC] ping ok @ % s".format(Main.elapsedTime.round(0.001)).postln; nil });
};

) // end block
// utils_mpb_force_reconnect.scd
// v0.2
// MD 20250916-1057

(
~mpb_forceReconnect = { arg pedalboard;
    var log, connectPair, reconnectList, effCur, effNext, sinkCur, sinkNext, indexCounter, lastIndex;

    log = { arg txt; ("[FIX] " ++ txt).postln };

    connectPair = { arg leftKey, rightKey;
        Server.default.bind({
            // Correct JITLib embed operator used in your project:
            Ndef(leftKey) <<> Ndef(rightKey);
        });
    };

    reconnectList = { arg listSymbols;
        indexCounter = 0;
        lastIndex = listSymbols.size - 1;
        while({ indexCounter < lastIndex }, {
            connectPair.(listSymbols[indexCounter], listSymbols[indexCounter + 1]);
            indexCounter = indexCounter + 1;
        });
    };

    effCur = pedalboard.effectiveCurrent;
    effNext = pedalboard.effectiveNext;

    reconnectList.(effCur);
    reconnectList.(effNext);

    sinkCur = effCur[0];
    sinkNext = effNext[0];

    Server.default.bind({
        if(Ndef(sinkCur).isPlaying.not) { Ndef(sinkCur).play(numChannels: 2) };
        if(Ndef(sinkNext).isPlaying)    { Ndef(sinkNext).stop };
    });

    log.("forceReconnect done. current=" ++ effCur ++ "  next=" ++ effNext);
};
)
// Verify_SetSourcesBoth_Today.scd
// v0.2
// MD 2025-09-18 13:46 BST

// Purpose
// - Verify that both chains have \testmelody as their source symbol, without assuming ~mpb exists.
// Style
// - var-first; lowercase; no server.sync; server ops via class methods only.

(
var warn, ensureSources;
warn = { arg s; var msg; msg = "[VERIFY] " ++ s; msg.warn };

if(~mpb.isNil) {
    warn.("~mpb is nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.");
    ^nil;
};

ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

ensureSources.();
~mpb.setSourceCurrent(\testmelody);
~mpb.setSource(\testmelody);
~mpb.printChains;
"[VERIFY] Both chains point to \\testmelody (CURRENT and NEXT)".postln;
)
// XEnforce_EndAndRecreateSilent_Now.scd
// v0.1
// MD 20250917-1305
//
// Purpose: Deterministically enforce Option A for both audio *and* flags.
//          - CURRENT robust \in.ar(2), playing
//          - NEXT: .end (drops monitor + flag), then recreate Silent.ar(2) + mold(2,\audio)
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, curSink, nextSink;
log = { arg s; ("[XEND] " ++ s).postln };

if(~mpb.isNil) { "[XEND] ~mpb is nil".warn; ^nil };

curSink  = ~mpb.currentChain[0];
nextSink = ~mpb.nextChain[0];

if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false) };

Server.default.bind({
    // CURRENT: robust + stereo + playing
    Ndef(curSink,  { \in.ar(2) }); Ndef(curSink).mold(2, \audio);
    if(Ndef(curSink).isPlaying.not) { Ndef(curSink).play(numChannels: 2) };

    // NEXT: end monitor -> recreate as silent stereo (no play)
    Ndef(nextSink).end;                              // flag reliably drops
    Ndef(nextSink, { Silent.ar(2) });                // silent source
    Ndef(nextSink).mold(2, \audio);                  // stereo pin
});

log.("enforced; checking in 250ms…");
AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[XEND] [PLAY] A=% B=%".format(a, b)).postln;
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(true) };
    nil
});
)
