// acceptanceStepsTest.scd
// v0.1
// MD 20250916

// [1] Add delay to NEXT (B while A is current)
~mpb.add(\delay);
~mpb.printChains;

// [2] Switch (A -> B) with a short fade
~mpb.switchChain(0.12);
("After switch: A.playing=" ++ Ndef(\chainA).isPlaying ++ "  B.playing=" ++ Ndef(\chainB).isPlaying).postln;
~mpb.printChains;

// [3] Bypass ON (CURRENT)
~mpb.bypassCurrent(\delay, true);
~mpb.printChains;

// [4] Bypass OFF (CURRENT)
~mpb.bypassCurrent(\delay, false);
~mpb.printChains;

// [5] Switch back (B -> A)
~mpb.switchChain(0.12);
("Final: A.playing=" ++ Ndef(\chainA).isPlaying
 ++ "  B.playing=" ++ Ndef(\chainB).isPlaying).postln;
~mpb.printChains;
// adapter_commandtree_to_magicpedalboard.scd
// v0.3.1
// MD 20250916-14:49

(

var alreadyWrapped;

~ct_knownVerbs = #[\add, \bypass, \removeAt, \swap, \clear, \setSource, \switch];
~ct_knownProcs = #[\delay, \chorus, \tremolo, \reverb, \drive, \transpose, \hex, \audio, \filters, \delays, \noise, \oscillators];
~ct_log = { arg messageString; ("[CT->MPB] " ++ messageString).postln };

~ct_normalizeTokens = { arg oscPathString;
    var rawTokens, tokens;
    rawTokens = oscPathString.asString.split($/).reject({ arg one; one.isEmpty });
    tokens = if(rawTokens.size > 0 and: { rawTokens[0].asSymbol == \commands }) {
        rawTokens.copyRange(1, rawTokens.size - 1)
    }{
        rawTokens
    };
    tokens.collect({ arg one; one.asSymbol })
};

~ct_applyOneVerb = { arg tokens, pedalboard, gui;
    var consumed, verb, params, indexCount;
    consumed = 0;
    if(tokens.isEmpty) { ^0 };
    verb = tokens[0];
    params = tokens.copyRange(1, tokens.size - 1);

    switch(verb,

/*        \add, {
            if(params.size >= 1) { pedalboard.add(params[0]); ~ct_log.("add " ++ params[0]); consumed = 2; }
            { ~ct_log.("add: missing processor"); consumed = 1; };
        },*/
\add, {
    if(params.size >= 1) {
        var procSym;
        procSym = params[0].asSymbol;
        ~ct_ensureProcessor.(procSym);        // <-- ensure Ndef exists and is stereo
        pedalboard.add(procSym);
        ~ct_log.("add " ++ procSym);
        consumed = 2;
    }{
        ~ct_log.("add: missing processor"); consumed = 1;
    };
},

		\bypass, {
            if(params.size >= 2) {
                var procSym, stateBool;
                procSym = params[0];
                stateBool = (params[1] == \on);
                pedalboard.bypass(procSym, stateBool);
                ~ct_log.("bypass " ++ procSym ++ " -> " ++ stateBool);
                consumed = 3;
            }{ ~ct_log.("bypass: need proc and on/off"); consumed = 1; };
        },
        \removeAt, {
            if(params.size >= 1) {
                var indexInteger;
                indexInteger = params[0].asString.asInteger;
                pedalboard.removeAt(indexInteger);
                ~ct_log.("removeAt " ++ indexInteger);
                consumed = 2;
            }{ ~ct_log.("removeAt: need index"); consumed = 1; };
        },
        \swap, {
            if(params.size >= 2) {
                var aIndex, bIndex;
                aIndex = params[0].asString.asInteger;
                bIndex = params[1].asString.asInteger;
                pedalboard.swap(aIndex, bIndex);
                ~ct_log.("swap " ++ aIndex ++ " <-> " ++ bIndex);
                consumed = 3;
            }{ ~ct_log.("swap: need two indices"); consumed = 1; };
        },
        \clear, { pedalboard.clearChain; ~ct_log.("clear NEXT"); consumed = 1; },
        \setSource, {
            if(params.size >= 1) { pedalboard.setSource(params[0]); ~ct_log.("setSource " ++ params[0]); consumed = 2; }
            { ~ct_log.("setSource: missing symbol"); consumed = 1; };
        },
        \switch, { pedalboard.switchChain(0.12); ~ct_log.("switch crossfade"); consumed = 1; },
        {
            if(~ct_knownProcs.includes(verb)) {
                pedalboard.add(verb); ~ct_log.("add (fallback) " ++ verb); consumed = 1;
            }{ ~ct_log.("unknown verb: " ++ verb); consumed = 1; };
        }
    );
    consumed
};

~ct_applyOSCPathToMPB = { arg oscPathString, pedalboard, gui;
    var tokens, tokenIndex, consumedNow, appliedCount, tailTokens;
    tokens = ~ct_normalizeTokens.(oscPathString);
    if(tokens.isEmpty) { ~ct_log.("empty OSC path"); ^false };
    ~ct_log.("path=" ++ oscPathString ++ "  tokens=" ++ tokens);
    tokenIndex = 0; appliedCount = 0;
    while({ tokenIndex < tokens.size }, {
        tailTokens = tokens.copyRange(tokenIndex, tokens.size - 1);
        consumedNow = ~ct_applyOneVerb.(tailTokens, pedalboard, gui);
        if(consumedNow <= 0) { consumedNow = 1 };
        tokenIndex = tokenIndex + consumedNow;
        appliedCount = appliedCount + 1;
    });
    appliedCount > 0
};

~ct_applyQueueToMPBFromCM = { arg commandManager, pedalboard, gui;
    var oscPathString, listSnapshot;
    listSnapshot = commandManager.midiManager.queue.commandList;
    ~ct_log.("queue snapshot: " ++ listSnapshot);
    oscPathString = commandManager.midiManager.queue.exportAsOSCPath;
    ~ct_log.("exported path: " ++ oscPathString);
    ~ct_applyOSCPathToMPB.(oscPathString, pedalboard, gui);
    commandManager.midiManager.queue.clear;
    true
};

~ct_sendAndApply = { arg commandManager, pedalboard, gui;
    ~ct_applyQueueToMPBFromCM.(commandManager, pedalboard, gui);
};



// 0) Capture the original adapter exactly once so we can delegate non-switch paths safely.
alreadyWrapped = (~ct_applyOSCPathToMPB_raw.notNil);
if(alreadyWrapped.not) {
    ~ct_applyOSCPathToMPB_raw = ~ct_applyOSCPathToMPB;
};

// 1) Helper: guard NEXT tail before switch, then audit after fade and recover if needed.

~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal, myGen;

    // initialize state vars once
    if(~ct_switchBusy.isNil) { ~ct_switchBusy = false };
    if(~ct_switchGen.isNil)  { ~ct_switchGen  = 0     };

    // prevent overlapping switches (re-entrant safe)
    if(~ct_switchBusy == true) {
        "[CT->MPB] switch ignored (busy)".postln;
        ^nil;
    };

    ~ct_switchBusy = true;
    ~ct_switchGen  = ~ct_switchGen + 1;
    myGen          = ~ct_switchGen;

    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last    = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            // Use the original adapter to avoid wrapping recursion
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    auditAndFix = {
        var a, b;
        // ignore stale audits from older generations
        if(~ct_switchGen != myGen) { ^nil };

        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;

        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

        // release busy flag only after our generation’s audit runs
        ~ct_switchBusy = false;
    };

    fadeLocal = fade ? 0.12;

    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);

    // schedule audit a bit after the fade completes; protect with generation check
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};


/*~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal;

    // Ensure NEXT ends with an audible source before switching.
    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    // After the crossfade, check A/B; if both false, make CURRENT audible and re-enforce Option A.
    auditAndFix = {
        var a, b;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    };

    fadeLocal = fade ? 0.12;
    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};*/

// 2) Wrapper adapter: intercept ONLY "/switch"; delegate all other paths to the original.
~ct_applyOSCPathToMPB = { arg path, mpb, gui;
    var p, f;
    p = path.asString;
    if(p == "/switch") {
        f = 0.12; // keep your usual fade; adjust if you use a different default
        ~ct_switchWithRecovery.(mpb, gui, f);
    }{
        ~ct_applyOSCPathToMPB_raw.(p, mpb, gui);
    };
};


~ct_ensureProcessor = { arg keySym;
    var k;
    k = keySym.asSymbol;

    Server.default.bind({
        var defineDelay, defineBypass, defineIdentity;

        defineIdentity = {
            var make;
            make = {
                // pass-through “processor” that keeps stereo and \in.ar(2)
                // used as a safe fallback for unknown keys
                Ndef(k, { var sig; sig = \in.ar(2); sig });
                Ndef(k).ar(2);
            };
            if(Ndef(k).source.isNil) { make.value } { Ndef(k).ar(2) };
        };

        defineDelay = {
            var make;
            make = {
                // simple stereo delay: read from \in.ar(2) → short delay → mix
                Ndef(\delay, {
                    var sig, del, time, fb, mix;
                    sig  = \in.ar(2);
                    time = 0.25;   // s
                    fb   = 0.25;
                    mix  = 0.5;
                    del  = DelayC.ar(sig + (LocalIn.ar(2) * fb), 1.0, time);
                    LocalOut.ar(del);
                    XFade2.ar(sig, del, (mix * 2 - 1).clip(-1, 1))
                });
                Ndef(\delay).ar(2);
            };
            if(Ndef(\delay).source.isNil) { make.value } { Ndef(\delay).ar(2) };
        };

        defineBypass = {
            // A named pass-through “processor” you might use in test chains
            var make;
            make = {
                Ndef(\bypass, { \in.ar(2) });
                Ndef(\bypass).ar(2);
            };
            if(Ndef(\bypass).source.isNil) { make.value } { Ndef(\bypass).ar(2) };
        };

        // choose per key
        if(k == \delay) { defineDelay.value }
        { if(k == \bypass) { defineBypass.value } { defineIdentity.value } };
    });
};


)
// Adapter_UIHook_Install.scd
// v0.2.0
// MD 20250918-20:10 BST

/* Purpose
   - Wrap ~ct_applyOSCPathToMPB to call ~procHud_update after each token apply.
   - No behavior change to your adapter's logic.

   Style
   - var-first; lowercase; AppClock for UI calls; no server.sync.
*/

(
var wrap;

if(~ct_applyOSCPathToMPB.isNil) {
    "[UIHOOK] ~ct_applyOSCPathToMPB is nil; load the adapter file first.".warn;
    ^nil
};

if(~ct_applyOSCPathToMPB_orig.isNil) {
    ~ct_applyOSCPathToMPB_orig = ~ct_applyOSCPathToMPB;
};

wrap = { arg pathString, mpb, gui;
    var result;
    result = ~ct_applyOSCPathToMPB_orig.(pathString, mpb, gui);
    if(~procHud_update.notNil) {
        AppClock.sched(0.0, { ~procHud_update.(); nil });
    };
    result
};

~ct_applyOSCPathToMPB = wrap;
"[UIHOOK] adapter UI hook installed".postln;
)
// audibleSanity.scd
// v0.2
// MD 20250916

(
// --- A) Boot and define an internal source (stereo) ---
var ensureAudio, defineTestSource, overrideTs0, ensureGuiAndPedalboard, startCurrent, verify;

ensureAudio = {
    Server.default.boot;
};

defineTestSource = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);
    });
};

// --- B) Force ts0 to be internal (NOT SoundIn) for all tests today ---
overrideTs0 = {
    Server.default.bind({
        Ndef(\ts0, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.0);
            seq  = Dseq([196, 246.94, 329.63, 261.63, 329.63, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.40);
            tone = Pulse.ar(f, 0.5) * env * 0.20;
            panPos = LFTri.kr(0.1).linlin(-1, 1, -0.5, 0.5);
            Pan2.ar(tone, panPos)
        });
        Ndef(\ts0).ar(2);
    });
};

// --- C) GUI + Pedalboard, sinks ar(2), meters on ---
ensureGuiAndPedalboard = {
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };

    Server.default.bind({
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });

    // toggle meters cleanly once (your enableMeters now guards for audio-rate + server)
    ~gui.enableMeters(false);
    ~gui.enableMeters(true);
};

// --- D) Set CURRENT source to internal generator and play ---
startCurrent = {
    ~mpb.setSourceCurrent(\testmelody); // generated source
    ~mpb.playCurrent;
};

// --- E) Verify status ---
verify = {
    ~mpb.printChains;
    ("[sanity] chainA.isPlaying=% chainB.isPlaying=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
};

ensureAudio.value;
defineTestSource.value;
overrideTs0.value;
ensureGuiAndPedalboard.value;
startCurrent.value;
verify.value;
)
// quickpatch.scd
// Quick Patch — GUI/Audio sync + reliable GUI front
// v0.1.0
// MD 20250919-10:10 BST

(

/*
Purpose
- Keep MagicDisplayGUI columns/headers in sync with the actual CURRENT (A/B).
- Remember the NEXT effect symbol so the right column shows something useful.
- Wrap ~switchNow to refresh the GUI automatically after audio toggles.
- Bring GUI window to the front; keep the grey UserDisplay behind.

Style
- var-first; lowercase; AppClock-only; no server.sync.
*/

var installGuiSync;

installGuiSync = {
    var ensureGuiFront, refreshFromState, wrapSwitch, hookApply;

    ensureGuiFront = {
        var gwin;
        ~gui = ~gui ?? { MagicDisplayGUI_GridDemo.new };
        if(~gui.respondsTo(\window)) {
            gwin = ~gui.window;
            if(gwin.notNil) { gwin.front; gwin.alwaysOnTop_(true) };
        };
        if(~ct.notNil and: { ~ct.display.notNil and: { ~ct.display.window.notNil } }) {
            ~ct.display.window.alwaysOnTop_(false);
        };
        if(~gui.notNil) { ~gui.showExpectation("GUI ready; syncing with audio state…", 0) };
        nil
    };

    refreshFromState = {
        var current, next, effC, effN, bA, bB, effSym, nowA;
        bA = []; bB = [];
        effSym = ~nextEffectSym ? \delay;   // default if none chosen yet
        nowA = (~currentIsA ? true);

        if(~gui.isNil) { ^nil };

        if(nowA) {
            // CURRENT=A, NEXT=B
            current = [\chainA, \testmelody];
            next    = [\chainB, effSym, \testmelody];
            ~gui.highlightCurrentColumn(\chainA);
        }{
            // CURRENT=B, NEXT=A
            current = [\chainB, \testmelody];
            next    = [\chainA, effSym, \testmelody];
            ~gui.highlightCurrentColumn(\chainB);
        };
        effC = current; effN = next;

        ~gui.showChainsDetailed(current, next, bA, bB, effC, effN);
        nil
    };

    wrapSwitch = {
        // decorate ~switchNow so it always refreshes the GUI after toggling
        if(~switchNow.notNil) {
            ~switchNow_raw = ~switchNow;
            ~switchNow = {
                ~switchNow_raw.();
                AppClock.sched(0.02, { refreshFromState.value; nil });
            };
        };
        nil
    };

    hookApply = {
        // provide a helper the bridge (or you) can call that both applies FX and refreshes
        ~applyCTEffect = { arg effSym;
            ~nextEffectSym = effSym;
            if(~applyToNext.notNil) { ~applyToNext.(effSym) };
            AppClock.sched(0.02, { refreshFromState.value; nil });
        };
        nil
    };

    ensureGuiFront.value;
    wrapSwitch.value;
    hookApply.value;

    // initial fill so the columns aren’t empty
    AppClock.sched(0.01, { refreshFromState.value; nil });

    "[PATCH] GUI sync installed".postln;
    nil
};

AppClock.sched(0.0, { installGuiSync.value; nil });
)
// bootstrap_audio_and_fx_min.scd
// v0.1

(
Server.default.boot;
Server.default.bind({
    // Musical test source (stereo) – guaranteed audibility
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f    = Demand.kr(trig, 0, seq);
        var env  = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
        Pan2.ar(tone, pan)
    });
    Ndef(\testmelody).ar(2);

    // Minimal \delay (stereo) – matches your style using \in.ar
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig    = \in.ar(2);
        var delayed= CombC.ar(sig, 2.0, time.clip(0.01, 2.0),
                              time * (fb.clip(0.0, 0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\delay).ar(2);
});
)
// CT_SafeSmoke_NoDupes.scd
// v0.1.1
// MD 2025-09-18 11:30 BST

// Purpose:
// - Safe CommandTree-mimic smoke: add exactly one \delay to NEXT, ensure NEXT source is \testmelody,
//   then switch once and verify exclusivity with audio.
// Style:
// - tilde vars; var-first in functions/closures; lowercase names; no server.sync;
// - server ops inside Server.default.bind only when creating/updating Ndefs.

(
var log, countKey, assertOnce, printChainsShort, ensureAdapterOnce, ensureSource;
log = { arg s; ("[CT] " ++ s).postln };
countKey = { arg array, key; var c=0; array.do({ arg k; if(k == key) { c = c + 1 } }); c };
assertOnce = { arg list, key, label;
    var n; n = countKey.(list, key);
    ("[ASSERT] " ++ label ++ " — '" ++ key.asString ++ "' count=" ++ n).postln;
    if(n != 1) { ("[ASSERT] expected exactly 1; got " ++ n).warn };
};
printChainsShort = {
    var cur = ~mpb.effectiveCurrent, nxt = ~mpb.effectiveNext;
    ("[CHAINS] CURRENT=" ++ cur).postln;
    ("[CHAINS] NEXT   =" ++ nxt).postln;
};
ensureAdapterOnce = {
    if(~ct_applyOSCPathToMPB.isNil) {
        "adapter_commandtree_to_magicpedalboard.scd".loadRelative;
        log.("adapter loaded");
    }{
        log.("adapter already present");
    };
};
ensureSource = {
    // Ensure \testmelody exists (stereo). Cheap and idempotent.
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig = Impulse.kr(3.2);
                var seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                var f = Demand.kr(trig, 0, seq);
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
    });
};

// --- run the safe smoke ---
ensureAdapterOnce.();
ensureSource.();

// 0) Baseline visibility
~mpb.printChains;

// 1) Clean NEXT
~mpb.clearChain;
~mpb.printChains;

// 2) Add exactly one delay to NEXT via adapter
~ct_applyOSCPathToMPB.("/add/delay", ~mpb, ~gui);

// 3) Ensure NEXT source is audible BEFORE switching  <<—— added fix
~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);

// Inspect NEXT; assert only one 'delay'
printChainsShort.();
assertOnce.(~mpb.effectiveNext, \delay, "after /add/delay + /setSource/testmelody");


//fix
~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);

// 4) Switch once with a short fade; CURRENT should now include \delay and end with \testmelody
~mpb.switchChain(0.12);

// 5) Post-switch checks
AppClock.sched(0.40, {
    printChainsShort.();
    ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    nil
});
)
// CT_TokenQueue_Manual_Milestone.scd
// v0.1.1
// MD 2025-09-18 15:19 BST

// Purpose:
// - Prove that MagicPedalboardNew responds to CommandTree-like *tokens* today,
//   without any Routine/Task runners (no chance of resume errors).
// - Steps: ensure sources (idempotent) -> apply tokens in order -> single tail verify.
// Style:
// - var-first in every function/closure; lowercase names; no server.sync;
// - server ops inside Server.default.bind only where needed; GUI on AppClock.

(
var log, ensureSources, guardSwitchAudible, applyPath, verifyTail, ok;

log = { arg s; var t; t = "[TOKENS] " ++ s; t.postln };

// quick guards
ok = (~mpb.isNil.not) and: { ~gui.isNil.not } and: { ~ct_applyOSCPathToMPB.notNil };
if(ok.not) {
    "[TOKENS] Missing ~mpb/~gui or adapter. Run StartHere... and adapter_*.scd first.".warn;
    ^nil;
};

// define generated sources if needed (no SoundIn)
ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) });  Ndef(\ts0).ar(2);
    });
};

// ensure NEXT isn’t silent before switching
guardSwitchAudible = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    if(last == \ts0) {
        log.("guard: NEXT tail \\ts0 -> injecting /setSource/testmelody before /switch");
        ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
    };
};

// tiny wrapper around your adapter path applier (for logging)
applyPath = { arg path;
    var p;
    p = path;
    log.("apply -> " ++ p);
    ~ct_applyOSCPathToMPB.(p, ~mpb, ~gui);
};

// verify once after fades
verifyTail = {
    AppClock.sched(0.8, {
        ("[PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        ~mpb.printChains;
        nil
    });
};

// ---- run steps synchronously (no Routine/Task) ----
ensureSources.();

// 1) Make both chains end with \testmelody once (idempotent), and keep Option A:
if(~mpb.effectiveCurrent.last != \testmelody) { ~mpb.setSourceCurrent(\testmelody) };
if(~mpb.effectiveNext   .last != \testmelody) { ~mpb.setSource(\testmelody) };
~mpb.enforceExclusiveCurrentOptionA(0.1);

// 2) Mimic CommandTree tokens via canonical adapter paths:

// ["insert","delay"]  -> "/add/delay"  (applies to NEXT)
applyPath.("/add/delay");

// ["switch"] -> "/switch"  (guard ensures audible NEXT)
guardSwitchAudible.();
applyPath.("/switch");

// ["bypass","delay","on"]  -> "/bypass/delay/on"  (acts on NEXT chain in your adapter semantics)
applyPath.("/bypass/delay/on");

// ["bypass","delay","off"] -> "/bypass/delay/off"
applyPath.("/bypass/delay/off");

// ["switch"] -> "/switch" (again)
guardSwitchAudible.();
applyPath.("/switch");

// 3) One final verification print (PLAY flags + chains)
verifyTail.();
)
// CT_TokenQueue_Milestone_ClockChain.scd
// v0.3.0
// MD 2025-09-18 15:08 BST

// Purpose:
// - Demonstrate (audibly & with logs) that MagicPedalboardNew responds to CommandTree-like
//   *token* queues today, sequenced without Routine/Task (AppClock-only, chain scheduling).
// - Flow: ensure sources -> load adapter via absolute path -> prime sources -> token playlist -> verify.
// Style:
// - var-first in every function/closure; lowercase names; no server.sync;
// - all server ops inside Server.default.bind; GUI ops on AppClock;
// - NodeProxy connections remain inside class rebuilds using the exact <<> operator.

(
var here, loadLocal, log, need, ensureSources, tokensToPath, isNextSilent, guardSwitchAudible;
var applyOneTokens, startClockChain, stopClockChain, verifyAtEnd, startDemo;
var playlist, gap, gen;

// --- path helper: load sibling files from this script's folder ---
here = PathName(thisProcess.nowExecutingPath).pathOnly;
loadLocal = { arg leafName;
    var full;
    full = here +/+ leafName;
    full.load;
};

// --- logging helper ---
log = { arg s;
    var str;
    str = "[TOKENS] " ++ s;
    str.postln;
};

// --- precondition guard (requires bring-up so ~mpb / ~gui exist) ---
need = {
    var ok;
    ok = (~mpb.isNil.not) and: { ~gui.isNil.not };
    if(ok.not) {
        "[TOKENS] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
    };
    ok
};

// --- ensure generated sources exist (no SoundIn) ---
ensureSources = {
    var define;
    define = {
        var made;
        made = false;
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
            made = true;
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) });  Ndef(\ts0).ar(2);
        made
    };
    Server.default.bind({ define.value; });
};

// --- load adapter robustly (absolute path) ---
if(~ct_applyOSCPathToMPB.isNil) {
    loadLocal.value("adapter_CommandTree_to_MagicPedalboard.scd");
    log.("adapter loaded");
} {
    log.("adapter already present");
};

// --- token -> canonical path mapping (what the adapter expects) ---
tokensToPath = { arg tokensIn;
    var tokens, verb, args, result, onOff;
    tokens = tokensIn.collect({ arg t; t.asString });
    if(tokens.size <= 0) { ^nil };
    verb = tokens[0].toLower;
    args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
    result = nil;

    if(verb == "insert" or: { verb == "add" }) {
        if(args.size >= 1) { result = "/add/" ++ args[0] };
    }{
        if(verb == "bypass") {
            onOff = if(args.size >= 2) { args[1].toLower } { "on" };
            onOff = if(#["on","off","true","false","1","0"].includes(onOff)) {
                if((onOff == "true") or: { onOff == "1" }) { "on" } { onOff }
            } { "on" };
            if(args.size >= 1) { result = "/bypass/" ++ args[0] ++ "/" ++ onOff };
        }{
            if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                if(args.size >= 1) { result = "/setSource/" ++ args[0] };
            }{
                if(verb == "removeat") {
                    if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                }{
                    if(verb == "swap") {
                        if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                    }{
                        if(verb == "switch" or: { verb == "commit" }) {
                            result = "/switch";
                        }{
                            result = nil;
                        };
                    };
                };
            };
        };
    };
    ^result
};

// --- guard so /switch never lands on a silent NEXT (\ts0 tail) ---
isNextSilent = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    ^(last == \ts0)
};

guardSwitchAudible = {
    var needed;
    needed = isNextSilent.value;
    if(needed) {
        log.("NEXT ends with \\ts0; injecting /setSource/testmelody before /switch");
        ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
    };
};

// --- apply one token step via the adapter ---
applyOneTokens = { arg tokens;
    var path;
    path = tokensToPath.value(tokens);
    if(path.isNil) {
        log.("unmapped tokens: " ++ tokens.asString);
        ^nil;
    };
    if(path == "/switch") { guardSwitchAudible.value };
    log.("apply " ++ tokens.asString ++ "  -> " ++ path);
    ~ct_applyOSCPathToMPB.(path, ~mpb, ~gui);
};

// --- STOP any previous chain by bumping a generation counter ---
stopClockChain = {
    var old;
    old = ~ctq_gen ? 0;
    ~ctq_gen = old + 1;
    log.("chain stopped (gen=" ++ ~ctq_gen ++ ")");
};

// --- Start a playlist using AppClock chaining; no Routine/Task involved ---
startClockChain = { arg listOfTokenLists, gapSeconds = 0.6;
    var startGen, total, stepFn, scheduleNext, index;

    // bump generation to cancel older scheduled callbacks
    stopClockChain.value;

    startGen = ~ctq_gen;
    total = listOfTokenLists.size;
    index = 0;

    stepFn = {
        var tokens, stillMine;
        tokens = listOfTokenLists[index];
        stillMine = (~ctq_gen == startGen);
        if(stillMine.not) { ^nil }; // cancelled

        applyOneTokens.value(tokens);

        index = index + 1;
        if(index < total) {
            scheduleNext.value;
        }{
            log.("done.");
        };
    };

    scheduleNext = {
        var delay;
        delay = gapSeconds ? 0.6;
        AppClock.sched(delay, {
            var stillMine;
            stillMine = (~ctq_gen == startGen);
            if(stillMine) { stepFn.value } { nil };
        });
    };

    // kick off immediately
    AppClock.sched(0.0, {
        var stillMine;
        stillMine = (~ctq_gen == startGen);
        if(stillMine) { stepFn.value } { nil };
    });

    ^startGen
};

// --- verify tail ---
verifyAtEnd = {
    var a, b;
    a = Ndef(\chainA).isPlaying;
    b = Ndef(\chainB).isPlaying;
    ("[PLAY] A=% B=%".format(a, b)).postln;
    ~mpb.printChains;
};

// --- end-to-end run ---
startDemo = {
    var ok, runGen, tailDelay;
    ok = need.value;
    if(ok.not) { ^nil };

    ensureSources.value;

    // For today: both chains end with \testmelody; NEXT remains silent at sink (Option A).
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);

    // Example playlist
    playlist = [
        ["insert","delay"],
        ["switch"],
        ["bypass","delay","on"],
        ["bypass","delay","off"],
        ["switch"]
    ];
    gap = 0.60;

    runGen = startClockChain.value(playlist, gap);

    // verify near the end; computed tail = steps * gap + small margin
    tailDelay = playlist.size * gap + 0.9;
    AppClock.sched(tailDelay, {
        var stillMine;
        stillMine = (~ctq_gen == runGen);
        if(stillMine) { verifyAtEnd.value };
        nil
    });
};

// --- go ---
startDemo.value;
)
// CT_TokenQueueHarness.scd
// v0.1.1
// MD 2025-09-18 13:56 BST

/*
Purpose
- Minimal harness that accepts CommandTree-like token arrays (e.g. ["insert","delay"])
  and maps them to canonical OSC-style paths understood by your existing adapter
  (~ct_applyOSCPathToMPB). Adds a guard so "/switch" never lands on a silent NEXT.

Style
- tilde vars allowed at top level.
- var-first in every function/closure; lowercase method names.
- no server.sync; all server ops inside Server.default.bind.
- This file does not manipulate Ndefs directly; MagicPedalboardNew handles audio and <<>.
*/

(
// Public factory: ~ctq_makeHarness.(mpb, gui, secondsBetween)
// Returns an IdentityDictionary with keys:
//  - \applyOneTokens : { |tokens| ... }         // tokens = ["insert","delay"] etc.
//  - \runPlaylist    : { |listOfTokenLists, gapSeconds| ... }
//  - \tokensToPath   : { |tokens| ... }         // mapping only
//  - \stop           : { ... }                  // stop current run (if any)

var makeHarness;
makeHarness = { arg mpb, gui, secondsBetween = 0.5;
    var state, log, ensureAdapter, tokensToPath, isNextSilent, guardSwitchAudible;
    var applyOneTokens, runPlaylist, stop, runner;

    log = { arg s;
        var msg;
        msg = "[CTQ] " ++ s;
        msg.postln;
    };

    ensureAdapter = {
        var loadedAlready;
        loadedAlready = (~ct_applyOSCPathToMPB.notNil);
        if(loadedAlready.not) {
            "adapter_CommandTree_to_MagicPedalboard.scd".loadRelative;
            log.("adapter loaded");
        }{
            log.("adapter already present");
        };
    };

    tokensToPath = { arg tokensIn;
        var tokens, verb, args, result, lowerOnOff;
        tokens = tokensIn.collect({ arg t; t.asString });
        if(tokens.size <= 0) { ^nil };
        verb = tokens[0].toLower;
        args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
        result = nil;

        if(verb == "insert" or: { verb == "add" }) {
            if(args.size >= 1) { result = "/add/" ++ args[0] };
        }{
            if(verb == "bypass") {
                if(args.size >= 1) {
                    lowerOnOff = if(args.size >= 2) { args[1].toLower } { "on" };
                    lowerOnOff = (["on","off","true","false","1","0"].includes(lowerOnOff)).if({
                        if((lowerOnOff == "true") or: { lowerOnOff == "1" }) { "on" } { lowerOnOff }
                    },{
                        "on"
                    });
                    result = "/bypass/" ++ args[0] ++ "/" ++ lowerOnOff;
                };
            }{
                if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                    if(args.size >= 1) { result = "/setSource/" ++ args[0] };
                }{
                    if(verb == "switch" or: { verb == "commit" }) {
                        result = "/switch";
                    }{
                        if(verb == "removeat") {
                            if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                        }{
                            if(verb == "swap") {
                                if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                            }{
                                result = nil;
                            };
                        };
                    };
                };
            };
        };
        ^result;
    };

    isNextSilent = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last = effNext[effNext.size - 1];
        ^(last == \ts0);
    };

    guardSwitchAudible = {
        var needed;
        needed = isNextSilent.();
        if(needed) {
            log.("NEXT ends with \\ts0; injecting /setSource/testmelody before /switch");
            ~ct_applyOSCPathToMPB.("/setSource/testmelody", mpb, gui);
        };
    };

    applyOneTokens = { arg tokens;
        var path;
        path = tokensToPath.(tokens);
        if(path.isNil) {
            log.("unmapped tokens: " ++ tokens.asString);
            ^nil;
        };
        if(path == "/switch") { guardSwitchAudible.() };
        ~ct_applyOSCPathToMPB.(path, mpb, gui);
    };

    runPlaylist = { arg listOfTokenLists, gapSeconds;
        var gapLocal, routineLocal;
        gapLocal = gapSeconds ? secondsBetween;
        routineLocal = Routine({
            var i, step;
            i = 0;
            while({ i < listOfTokenLists.size }, {
                step = listOfTokenLists[i];
                log.("apply " ++ step.asString);
                applyOneTokens.(step);
                gapLocal.wait;
                i = i + 1;
            });
            log.("done.");
        });
        runner = routineLocal.play(AppClock);
        ^runner;
    };

    stop = {
        if(runner.notNil) { runner.stop; runner = nil };
        log.("stopped.");
    };

    ensureAdapter.();
    state = IdentityDictionary[
        \applyOneTokens -> applyOneTokens,
        \runPlaylist    -> runPlaylist,
        \tokensToPath   -> tokensToPath,
        \stop           -> stop
    ];
    ^state;
};

~ctq_makeHarness = makeHarness;
)
// CTQ_HardStop_All_Runners.scd
// v0.1.1
// MD 2025-09-18 15:18 BST

// Purpose:
// - Stop any leftover Routine/Task and cancel any pending AppClock chain (generation bump).
// Style:
// - var-first; lowercase; no server.sync.

(
var hadRunner, hadTask, oldGen;
hadRunner = (~ctq_runner.notNil) and: { ~ctq_runner.isPlaying };
hadTask   = (~ctq_task.notNil)   and: { ~ctq_task.isPlaying };

if(hadRunner) { ~ctq_runner.stop };
if(hadTask)   { ~ctq_task.stop };

~ctq_runner = nil;
~ctq_task   = nil;

oldGen = ~ctq_gen ? 0;
~ctq_gen = oldGen + 1;

("[TOKENS] HARD STOP — runner=% task=% gen=%"
    .format(hadRunner, hadTask, ~ctq_gen)).postln;
)
// CTQ_MinHarness_Inline.scd
// v0.1.0
// MD 2025-09-18 14:05 BST

/*Purpose
- Minimal, reliable inline harness to drive MagicPedalboardNew from CommandTree-like token queues
  without relying on a returned dictionary. Good for today's milestone demo.
Style
- tilde vars; var-first in every function/closure; lowercase method names; no server.sync;
  GUI on AppClock; Ndef connections happen inside class code with exact <<> operator.*/


(
// 0) Preconditions and adapter
var need;

need = {
    if(~mpb.isNil or: { ~gui.isNil }) {
        "[CTQ] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
        ^false
    }; ^true
};

if(need.().not) { ^nil };

// load adapter once (defines ~ct_applyOSCPathToMPB)
if(~ct_applyOSCPathToMPB.isNil) {
    "adapter_CommandTree_to_MagicPedalboard.scd".loadRelative;
    "[CTQ] adapter loaded".postln;
} {
    "[CTQ] adapter already present".postln;
};

// 1) Token → path mapper (safe subset for today)
~ctq_tokensToPath = { arg tokensIn;
    var tokens, verb, args, lowerOnOff, result;
    tokens = tokensIn.collect({ arg t; t.asString });
    if(tokens.size <= 0) { ^nil };
    verb = tokens[0].toLower;
    args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
    result = nil;

    if(verb == "insert" or: { verb == "add" }) {
        if(args.size >= 1) { result = "/add/" ++ args[0] };
    } {
        if(verb == "bypass") {
            if(args.size >= 1) {
                lowerOnOff = if(args.size >= 2) { args[1].toLower } { "on" };
                lowerOnOff = (["on","off","true","false","1","0"].includes(lowerOnOff)).if({
                    if((lowerOnOff == "true") or: { lowerOnOff == "1" }) { "on" } { lowerOnOff }
                }, { "on" });
                result = "/bypass/" ++ args[0] ++ "/" ++ lowerOnOff;
            };
        } {
            if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                if(args.size >= 1) { result = "/setSource/" ++ args[0] };
            } {
                if(verb == "switch" or: { verb == "commit" }) {
                    result = "/switch";
                } {
                    if(verb == "removeat") {
                        if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                    } {
                        if(verb == "swap") {
                            if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                        } {
                            result = nil; // unmapped today
                        };
                    };
                };
            };
        };
    };
    ^result;
};

// 2) Guard so /switch never lands on \ts0
~ctq_guardSwitchAudible = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    if(last == \ts0) {
        "[CTQ] NEXT ends with \\ts0; injecting /setSource/testmelody before /switch".postln;
        ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
    };
};

// 3) Apply a single token array
~ctq_applyOneTokens = { arg tokens;
    var path;
    path = ~ctq_tokensToPath.(tokens);
    if(path.isNil) {
        ("[CTQ] unmapped tokens: " ++ tokens.asString).postln; ^nil
    };
    if(path == "/switch") { ~ctq_guardSwitchAudible.() };
    ("[CTQ] apply " ++ tokens.asString ++ " -> " ++ path).postln;
    ~ct_applyOSCPathToMPB.(path, ~mpb, ~gui);
};

// 4) Run a playlist of token arrays with a gap (Routine on AppClock)
~ctq_runPlaylist = { arg listOfTokenLists, gapSeconds = 0.6;
    var routineLocal, gap;
    gap = gapSeconds ? 0.6;
    routineLocal = Routine({
        var i;
        i = 0;
        while({ i < listOfTokenLists.size }, {
            ~ctq_applyOneTokens.( listOfTokenLists[i] );
            gap.wait;
            i = i + 1;
        });
        "[CTQ] done.".postln;
    });
    routineLocal.play(AppClock);
    ^routineLocal
};

// 5) Quick prime (today we want audible switches using \testmelody)
~ctq_primeSources = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    ~mpb.printChains;
    AppClock.sched(0.25, {
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

"[CTQ] inline harness ready".postln;
)
// demo_apply_after_fix.scd
// v0.1
// MD 20250916-1031

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Adapter must be present
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your JSON with payloads/verbs)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// Sequence: add delay -> switch -> bypass on -> bypass off -> switch
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)
// demo_commandtree_apply_hotfix.scd
// v0.1
// MD 20250916-1020

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Ensure adapter is loaded; if not, evaluate adapter_commandtree_to_magicpedalboard.scd
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your updated JSON with payloads)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// 1) add delay on NEXT
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch to hear delay on CURRENT
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON → OFF → final switch
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)
// demo_commandtree_apply_now.scd
// v0.2
// MD 20250916-1003

(
var ensureAudio, ensureGui, ensurePedalboard, ensureAdapter, log;

// simple logger
log = { arg messageString; ("[DEMO] " ++ messageString).postln };

// A) Audio: boot + musical internal source (stereo)
ensureAudio = {
    Server.default.boot;
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);

        // lightweight FX (safe to re-run)
        Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
            var sig = \in.ar(2);
            var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
            XFade2.ar(sig, delayed, (mix.clip(0,1) * 2 - 1))
        });
        Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
            var sig = \in.ar(2);
            var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
            DelayC.ar(sig, 0.1, mod)
        });
    });
};

// B) GUI: your runner guarantees one window + PROBE FRAME
ensureGui = {
    ~md_bootProbeScenario.();
};

// C) Pedalboard + GUI binding (reuse if present)
ensurePedalboard = {
    if(~gui.isNil) { ~gui = MagicDisplayGUI.new() };
    if(~pedalboard.isNil) { ~pedalboard = MagicPedalboardNew.new(~gui) };
    ~pedalboard.setSource(\testmelody);
    ~pedalboard.switchChain(0.12);
};

// D) Adapter presence
ensureAdapter = {
    if(~ct_sendAndApply.isNil) {
        "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
    };
};

// ---- run prep ----
ensureAudio.value;
ensureGui.value;
ensurePedalboard.value;
ensureAdapter.value;

// E) Reload CommandManager (imports updated myTree.json automatically)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// F) Drive actions via queue + SEND + adapter

// 1) add delay
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch (make it CURRENT, audible)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON, then OFF, then switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Inspect (also drives GUI detailed view)
~pedalboard.printChains;
)
// demo_commandtree_milestone.scd
// v0.1
// MD 20250916-0852

(
// ---- A) Audio source + basic FX (no server.sync, safe to re-run) ----
Server.default.boot;  // boot if not already

// Ensure an internal musical test source (stereo) as \testmelody
Server.default.bind({
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f  = Demand.kr(trig, 0, seq);
        var env = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        Pan2.ar(tone, ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6))
    });
    Ndef(\testmelody).ar(2);
});

// Optional: simple FX defaults (if not already defined elsewhere)
Server.default.bind({
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig = \in.ar(2);
        var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
        var sig = \in.ar(2);
        var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
        DelayC.ar(sig, 0.1, mod)
    });
});

// ---- B) Bring up your single GUI window (runner you already have) ----
~md_bootProbeScenario.();   // ensures one MagicDisplayGUI window + PROBE FRAME
// ---- C) Ensure pedalboard & bind GUI as display if not already done ----
~gui = ~gui ?? { MagicDisplayGUI.new() };         // class builds window on AppClock internally
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
~pedalboard.setSource(\testmelody);               // audible source
~pedalboard.switchChain(0.12);                    // fade in CURRENT

// ---- D) CommandManager (imports ~/CommandTreeSavefiles/myTree.json) ----
~cm = ~cm ?? { CommandManager.new };              // uses your importer path
// If you edited myTree.xml, convert to JSON now (uncomment):
// ~ct_convertXmlToJson.("~/myTree.xml", "~/CommandTreeSavefiles/myTree.json");
// ~cm = CommandManager.new;  // reinit to re-import
// ---- E) Demo sequence using your queue + SEND and the adapter ----
// 1) Add delay to NEXT (your current XML tokens may just be "delay"; adapter maps it to add/delay)
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) Switch to hear it (CURRENT <- NEXT)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) Bypass delay ON (then OFF), then switch again
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Optional: turn bypass OFF and switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;   // posts and drives GUI detail view
)
// demo_commandtree_preformed_queues.scd
// v0.2
// MD 20250916-1048

(
var log, makeCMIfNeeded, enqueueTokensFromPath, playlist, indexCounter, totalCount;

log = { arg msg; ("[DEMO] " ++ msg).postln };

makeCMIfNeeded = {
    if(~cm.isNil) { ~cm = CommandManager.new; log.("CommandManager created and JSON imported."); };
};

enqueueTokensFromPath = { arg cm, pathString;
    var tokens, tokenCounter, tokenTotal, one;
    // convert "/verb/arg1/arg2" into a token list on the cm queue
    tokens = pathString.asString.split($/).reject({ arg oneToken; oneToken.isEmpty }).collect({ arg s; s.asSymbol });
    cm.midiManager.queue.clear;
    tokenCounter = 0; tokenTotal = tokens.size;
    while({ tokenCounter < tokenTotal }, {
        one = tokens[tokenCounter];
        cm.midiManager.queue.enqueueCommand(one);
        tokenCounter = tokenCounter + 1;
    });
    log.("enqueued: " ++ tokens);
};

// A small playlist of fully-formed queues, like the tree would send
// (You can add "/commands/..." variants too; adapter strips the prefix.)

playlist = [
    "/setSource/testmelody",  // <— Ensure NEXT isn't Silent
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

/*playlist = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];*/

indexCounter = 0; totalCount = playlist.size;

~demo_next = {
    var path;
    makeCMIfNeeded.value;
    if(indexCounter >= totalCount) {
        log.("playlist complete.");
    }{
        path = playlist[indexCounter];
        enqueueTokensFromPath.(~cm, path);
        ~ct_sendAndApply.(~cm, ~pedalboard, ~gui);
        log.("applied: " ++ path);
        indexCounter = indexCounter + 1;
        ~pedalboard.printChains;
    };
};

~demo_restart = {
    indexCounter = 0;
    log.("playlist reset.");
};
)
// Demo_CommandTree_TokenQueues.scd
// v0.1.1
// MD 2025-09-18 13:56 BST

/*
Purpose
- Demonstrate MagicPedalboardNew responding to CommandTree-like token queues, via
  CT_TokenQueueHarness (tokens -> adapter paths -> pedalboard).

Style
- Requires that StartHere_CleanBoot_OneWindow_BringUp.scd has run (so ~mpb, ~gui exist).
- var-first; lowercase; no server.sync; server ops inside Server.default.bind; GUI on AppClock.
*/

(
var ensureSources, primeSources, gap, h, playlistA, playlistB, after;

if(~mpb.isNil or: { ~gui.isNil }) {
    "[DEMO] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
    ^nil;
};

ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

primeSources = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    ~mpb.printChains;
};

gap = 0.60;
"CT_TokenQueueHarness.scd".loadRelative;
h = ~ctq_makeHarness.(~mpb, ~gui, gap);

// Example token playlists
playlistA = [
    ["insert","delay"],
    ["switch"]
];

playlistB = [
    ["bypass","delay","on"],
    ["bypass","delay","off"],
    ["switch"]
];

ensureSources.();
primeSources.();

h[\runPlaylist].(playlistA, gap);
after = (playlistA.size * gap + 1.0).max(1.0);
AppClock.sched(after, {
    h[\runPlaylist].(playlistB, gap);
    nil
});
)
// Demo_Install_MinProcessors.scd
// v0.1.0
// MD 2025-09-18 11:58 BST

/* Purpose
   - Install a minimal, safe stereo \delay processor so chains like
     [chainX, delay, testmelody] are AUDIBLE.
   - Generated audio only; processors read from \in.ar(2); no SoundIn.
   - Idempotent; safe to re-run.

   Style
   - var-first in every function/closure; lowercase method names.
   - No server.sync; wrap server ops in Server.default.bind.
   - JITLib connections elsewhere MUST use Ndef(left) <<> Ndef(right).
*/

(
var installDelay;
installDelay = {
    Server.default.bind({
        // Simple feedback delay. Reads from \in.ar(2) per project policy.
        Ndef(\delay, {
            var inSig, maxDelay, time, fb, mix, wet;
            inSig    = \in.ar(2);              // <- policy: processors read from \in.ar(defaultNumChannels)
            maxDelay = 1.0;
            time     = (\time.kr(0.25)).clip(0.0, maxDelay);
            fb       = (\fb.kr(0.25)).clip(0.0, 0.95);
            mix      = (\mix.kr(0.35)).clip(0.0, 1.0);
            wet      = DelayC.ar(inSig + (LocalIn.ar(2) * fb), maxDelay, time);
            LocalOut.ar(wet);
            XFade2.ar(inSig, wet, (mix * 2) - 1) * 0.9
        });
        // Pin stereo/audio-rate bus shape (authoritative shape)
        Ndef(\delay).mold(2, \audio);
    });
    "[MINPROC] Installed \\delay (stereo)".postln;
};
installDelay.();
)
// Diag_BusChannel_Map.scd
// v0.1
// MD 20250917-1154
//
// Purpose: Post bus rate + channel count for every Ndef in CURRENT and NEXT
//          effective lists; helps catch mono nodes causing "2→1 wrap".
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, reportList;

log = { arg s; ("[BUS]" ++ " " ++ s).postln };

reportList = { arg label, listSyms;
    var rows;
    rows = listSyms.collect({ arg k;
        var b = Ndef(k).bus;
        var rate = (b.notNil).if({ b.rate }, { \unknown });
        var ch   = (b.notNil).if({ b.numChannels }, { -1 });
        var play = Ndef(k).isPlaying;
        [k, rate, ch, play]
    });
    (label ++ " = " ++ rows.asString).postln;
};

~mpb.printChains;  // also drives your GUI detail view
reportList.("CURRENT", ~mpb.effectiveCurrent);
reportList.("NEXT   ", ~mpb.effectiveNext);
)
// editor_commandtree_add_demo_verbs.scd
// v0.3
// MD 20250916-0957

(
var jsonPath, saveFolder, savePrefix;
var ensureChildUnder, ensurePath, rootNode, commandsNode;

// paths
jsonPath   = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

// load
~tree = MDCommandTree.new;
if (~tree.importJSONFile(jsonPath)) {
    "✅ Loaded tree for editing.".postln;
} {
    "❌ Failed to load tree JSON".warn; ^nil;
};

// helpers
ensureChildUnder = { arg parentNode, childName, fretNumber;
    var existingNode, createdNode;
    existingNode = parentNode.getChildByName(childName);
    if (existingNode.notNil) {
        existingNode
    } {
        createdNode = ~tree.addNode(parentNode.id, childName, fretNumber);
        if (createdNode.isNil) { ("⚠️ addNode failed for " ++ childName).postln };
        createdNode
    }
};

ensurePath = { arg pathArray, fretArray;
    var currentNode, stepIndex, childName, fretNumber, pathSize;
    currentNode = ~tree.root;
    pathSize = pathArray.size;
    stepIndex = 0;
    while({ stepIndex < pathSize }, {
        childName = pathArray[stepIndex];
        fretNumber = fretArray[stepIndex] ? 1;
        currentNode = ensureChildUnder.(currentNode, childName, fretNumber);
        stepIndex = stepIndex + 1;
    });
    currentNode
};

// ---- add demo verbs (idempotent) ----
rootNode = ~tree.root;
commandsNode = ensureChildUnder.(rootNode, "commands", 10);

// commands/add/<proc>
ensurePath.(["commands","add","delay"],   [10,1,1]);
ensurePath.(["commands","add","chorus"],  [10,1,2]);
ensurePath.(["commands","add","reverb"],  [10,1,3]);
ensurePath.(["commands","add","tremolo"], [10,1,4]);

// commands/bypass/<proc>/<on|off>
ensurePath.(["commands","bypass","delay","on"],  [10,2,1,2]);
ensurePath.(["commands","bypass","delay","off"], [10,2,1,3]);

// commands/switch
ensurePath.(["commands","switch"], [10,3]);

// commands/setSource/<src>
ensurePath.(["commands","setSource","testmelody"], [10,4,1]);

// set payloads == names (simple, visible)
~tree.assignPayloads;
~tree.printTreePretty;

// save using custom exporter (preserves payloads in JSON)
~ct_writeJsonWithPayloads.(~tree, jsonPath, true, saveFolder, savePrefix);
)
// helper_recover_if_silent.scd
// v0.2

(
~recoverLog = ~recoverLog ?? { arg messageString;
    ("[RECOVER] " ++ messageString).postln;
};

~recoverIfSilent = {
    var ensureStereo, connectPair, connectList, currentEff, nextEff;
    var currentSink, nextSink, indexCounter, lastIndex;

    if(~mpb.isNil) { ~recoverLog.("~mpb is nil"); ^false };

    // Temporarily disable meters to avoid control-rate warnings during repair
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false) };

    // Ensure sinks are audio-rate
    Server.default.bind({
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });

    // Effective lists from pedalboard
    currentEff = ~mpb.effectiveCurrent;
    nextEff    = ~mpb.effectiveNext;

    ensureStereo = { arg keySymbol; Ndef(keySymbol).ar(2) };

    connectPair = { arg leftKey, rightKey;
        // matches project operator direction: left receives right
        Server.default.bind({ Ndef(leftKey) <<> Ndef(rightKey) });
    };

    connectList = { arg listSymbols;
        indexCounter = 0;
        lastIndex = listSymbols.size - 1;
        while({ indexCounter < lastIndex }, {
            var leftKey, rightKey;
            leftKey  = listSymbols[indexCounter];
            rightKey = listSymbols[indexCounter + 1];
            ensureStereo.(leftKey);
            ensureStereo.(rightKey);
            connectPair.(leftKey, rightKey);
            indexCounter = indexCounter + 1;
        });
    };

    // Rebuild both chains end-to-end
    connectList.(currentEff);
    connectList.(nextEff);

    // Enforce: CURRENT plays, NEXT stopped
    currentSink = currentEff[0];
    nextSink    = nextEff[0];
    Server.default.bind({
        if(Ndef(nextSink).isPlaying)        { Ndef(nextSink).stop };
        if(Ndef(currentSink).isPlaying.not) { Ndef(currentSink).play(numChannels: 2) };
    });

    // Re-enable meters (after AR is guaranteed)
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(true) };

    ~recoverLog.("reconnected. currentEff=" ++ currentEff ++ " nextEff=" ++ nextEff);

    // Status a moment later (no server.sync)
    AppClock.sched(0.20, {
        var aPlaying, bPlaying, line;
        aPlaying = Ndef(\chainA).isPlaying;
        bPlaying = Ndef(\chainB).isPlaying;
        line = "[status] A.playing=% B.playing=%".format(aPlaying, bPlaying);
        line.postln; nil
    });

    true
};
)
// Inline_CT_TokenSmoke.scd
// v0.1.2
// MD 2025-09-18 14:12 BST

// Purpose:
// - Demonstrate that MagicPedalboardNew responds to CommandTree-shaped *token* queues today
//   without external file loads (audible and logged).
// - Flow: ensure sources -> tiny token-harness -> prime sources -> apply tokens -> verify.
// Style:
// - var-first in every function/closure; lowercase names; no server.sync;
// - all server ops inside Server.default.bind; GUI ops on AppClock; NodeProxy connections
//   remain inside class rebuilds using the exact <<> operator.

(
var log, need, ensureSources, tokensToPath, isNextSilent, guardSwitchAudible,
    applyOneTokens, runPlaylist, doRun, playlist, gap;

// --- logging helper (var-first inside) ---
log = { arg s;
    var str;
    str = "[TOKENS] " ++ s;
    str.postln;
};

// --- precondition guard (var-first inside) ---
need = {
    var ok;
    ok = (~mpb.isNil.not) and: { ~gui.isNil.not };
    if(ok.not) {
        "[TOKENS] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
    };
    ok
};

// --- ensure generated sources exist (no SoundIn) ---
ensureSources = {
    var define;
    define = {
        var made;
        made = false;
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
            made = true;
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) });  Ndef(\ts0).ar(2);
        made
    };
    Server.default.bind({ define.value; });
};

// --- token -> canonical path mapping understood by the adapter ---
tokensToPath = { arg tokensIn;
    var tokens, verb, args, result, onOff;
    tokens = tokensIn.collect({ arg t; t.asString });
    if(tokens.size <= 0) { ^nil };
    verb = tokens[0].toLower;
    args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
    result = nil;

    if(verb == "insert" or: { verb == "add" }) {
        if(args.size >= 1) { result = "/add/" ++ args[0] };
    }{
        if(verb == "bypass") {
            onOff = if(args.size >= 2) { args[1].toLower } { "on" };
            onOff = if(#["on","off","true","false","1","0"].includes(onOff)) {
                if((onOff == "true") or: { onOff == "1" }) { "on" } { onOff }
            } { "on" };
            if(args.size >= 1) { result = "/bypass/" ++ args[0] ++ "/" ++ onOff };
        }{
            if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                if(args.size >= 1) { result = "/setSource/" ++ args[0] };
            }{
                if(verb == "removeat") {
                    if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                }{
                    if(verb == "swap") {
                        if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                    }{
                        if(verb == "switch" or: { verb == "commit" }) {
                            result = "/switch";
                        }{
                            result = nil;
                        };
                    };
                };
            };
        };
    };
    ^result
};

// --- guard so /switch never lands on a silent NEXT (\ts0 tail) ---
isNextSilent = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    ^(last == \ts0)
};

guardSwitchAudible = {
    var needed;
    needed = isNextSilent.value;
    if(needed) {
        log.("NEXT ends with \\ts0; injecting /setSource/testmelody before /switch");
        if(~ct_applyOSCPathToMPB.notNil) {
            ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
        }{
            "[TOKENS] adapter missing; cannot auto-fix source".warn;
        };
    };
};

// --- apply one token step via your existing adapter ---
applyOneTokens = { arg tokens;
    var path;
    path = tokensToPath.value(tokens);
    if(path.isNil) {
        log.("unmapped tokens: " ++ tokens.asString);
        ^nil;
    };
    if(path == "/switch") { guardSwitchAudible.value };
    if(~ct_applyOSCPathToMPB.notNil) {
        log.("apply " ++ tokens.asString ++ "  -> " ++ path);
        ~ct_applyOSCPathToMPB.(path, ~mpb, ~gui);
    }{
        ("[TOKENS] adapter missing; would apply " ++ path).warn;
    };
};

// --- run a playlist of token steps with a gap (AppClock) ---
runPlaylist = { arg listOfTokenLists, gapSeconds = 0.6;
    var rt;
    rt = Routine({
        var i;
        i = 0;
        while({ i < listOfTokenLists.size }, {
            applyOneTokens.value(listOfTokenLists[i]);
            gapSeconds.wait;
            i = i + 1;
        });
        log.("done.");
    }).play(AppClock);
    ^rt
};

// --- end-to-end demo: prime sources (today), run, verify ---
doRun = {
    var verify;
    gap = 0.60;

    // For today: both chains end with \testmelody; NEXT stays silent at sink (Option A).
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);

    // Example playlist: insert delay -> switch -> bypass on -> bypass off -> switch back
    playlist = [
        ["insert","delay"],
        ["switch"],
        ["bypass","delay","on"],
        ["bypass","delay","off"],
        ["switch"]
    ];

    runPlaylist.value(playlist, gap);

    verify = {
        var a, b;
        a = Ndef(\chainA).isPlaying; b = Ndef(\chainB).isPlaying;
        ("[PLAY] A=% B=%".format(a, b)).postln;
        ~mpb.printChains;
    };

    AppClock.sched(playlist.size * gap + 0.9, { verify.value; nil });
};

// --- go ---
if(need.value) {
    ensureSources.value;
    doRun.value;
};
)
// fix_current_only_now.scd
// v0.1
// MD 20250916-1007

(
var log;

log = { arg m; ("[FIX] " ++ m).postln };

// stop NEXT sink explicitly
if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop; log.("stopped \\chainB"); };

// re-wire CURRENT effective list with the correct operator and play only CURRENT
Server.default.bind({
    // ensure stereo busses (cheap no-op if already set)
    Ndef(\chainA).ar(2);
    Ndef(\testmelody).ar(2);

    // correct embed operator you use in this project:
    Ndef(\chainA) <<> Ndef(\testmelody);

    // play CURRENT sink only
    Ndef(\chainA).play(numChannels: 2);
});

~pedalboard.printChains;
"[FIX] chainA <<> testmelody; chainA.play done.".postln;
)
// MagicDisplayGUI_ProcessorsHUD_TopLeft.scd
// v0.3.2
// MD 20250919-08:25 BST

/*
Purpose
- Install a compact Processors HUD inside the existing MagicDisplayGUI window.
- Anchored top-left; no FlowLayout; adequate height so the "NEXT" line never truncates.
- Reflows width on update; safe to evaluate multiple times.
- If ~mpb is available, shows CURRENT/NEXT processor tails; otherwise shows placeholders.

Style
- var-first; lowercase; AppClock-only GUI ops; no caret returns in AppClock closures; no server.sync.
*/

(
var findGuiWindow, ensureHud, renderHud, makeRect, summarize, extractTail, clipStr, posCorner;

posCorner = \topLeft;

// helpers
findGuiWindow = {
    var windowsList, targetWindow;
    windowsList = Window.allWindows.select({ arg w;
        var nameStr, isMagic;
        nameStr = w.tryPerform(\name);
        isMagic = nameStr.notNil and: { nameStr.asString.beginsWith("MagicDisplayGUI") };
        isMagic
    });
    targetWindow = windowsList.last;
    targetWindow
};

makeRect = { arg parentRect;
    var margin, minWidth, panelWidth, panelHeight, xPos, yPos;
    margin = 10;
    minWidth = 220;
    panelHeight = 60; // title (16) + line (16) + line (16) + padding
    panelWidth  = (parentRect.width - (margin * 2)).clip(minWidth, 10000);
    xPos = if(posCorner == \topRight) { (parentRect.width - margin - panelWidth) } { margin };
    yPos = margin;
    Rect(xPos, yPos, panelWidth, panelHeight)
};

clipStr = { arg anyString, maxChars = 84;
    var s;
    s = anyString.asString;
    if(s.size > maxChars) { s.copyRange(0, maxChars-3) ++ "…" } { s }
};

extractTail = { arg chainArray;
    var arr;
    arr = chainArray ? [];
    if(arr.size > 0) { arr.copyRange(1, arr.size - 1) } { [] }
};

summarize = { arg syms;
    var namesArr, joined;
    namesArr = syms.collect(_.asString);
    joined = namesArr.join(" -> ");
    clipStr.value(joined, 84)
};

// installer
ensureHud = {
    AppClock.sched(0, {
        var win, rootView, boxView, titleText, lineCurrent, lineNext, rect, exists;
        win = findGuiWindow.value;
        if(win.notNil) {
            rootView = win.view;
            exists = (~procHud.notNil) and: { ~procHud[\view].notNil } and: { ~procHud[\view].isClosed.not };
            if(exists.not) {
                rect = makeRect.value(rootView.bounds);
                boxView = CompositeView(rootView, rect).background_(Color(0.12, 0.12, 0.12, 0.90));
                titleText = StaticText(boxView, Rect(8, 6, rect.width - 16, 16))
                    .string_("Processors")
                    .stringColor_(Color(0.95, 0.95, 0.95));
                lineCurrent = StaticText(boxView, Rect(8, 24, rect.width - 16, 16))
                    .string_("CURRENT: -")
                    .stringColor_(Color(0.90, 0.90, 0.90));
                lineNext = StaticText(boxView, Rect(8, 42, rect.width - 16, 16)) // 42 avoids clipping
                    .string_("NEXT: -")
                    .stringColor_(Color(0.80, 0.80, 0.80));
                ~procHud = IdentityDictionary[
                    \view -> boxView,
                    \lineCurrent -> lineCurrent,
                    \lineNext -> lineNext
                ];
                "[HUD] installed (top-left)".postln;
            };
        }{
            "[HUD] MagicDisplayGUI not found yet".postln;
        };
        nil
    });
};

// renderer
renderHud = {
    AppClock.sched(0, {
        var win, rootView, alive, rect, lineCurrent, lineNext;
        var currentArr, nextArr, currentTail, nextTail, currentStr, nextStr, haveMpb;

        win = findGuiWindow.value;
        if(win.notNil) {
            rootView = win.view;
            alive = (~procHud.notNil) and: { ~procHud[\view].notNil } and: { ~procHud[\view].isClosed.not };
            if(alive.not) {
                ensureHud.value;
                AppClock.sched(0.08, { renderHud.value; nil });
            }{
                rect = makeRect.value(rootView.bounds);
                ~procHud[\view].bounds = rect;

                haveMpb = (~mpb.notNil);
                if(haveMpb) {
                    currentArr = ~mpb.effectiveCurrent;
                    nextArr    = ~mpb.effectiveNext;
                    currentTail= extractTail.value(currentArr);
                    nextTail   = extractTail.value(nextArr);
                    currentStr = summarize.value(currentTail);
                    nextStr    = summarize.value(nextTail);
                }{
                    currentStr = "-";
                    nextStr    = "-";
                };

                lineCurrent = ~procHud[\lineCurrent];
                lineNext    = ~procHud[\lineNext];
                if(lineCurrent.notNil) {
                    lineCurrent.bounds = Rect(8, 24, rect.width - 16, 16);
                    lineCurrent.string = "CURRENT: " ++ currentStr;
                };
                if(lineNext.notNil) {
                    lineNext.bounds = Rect(8, 42, rect.width - 16, 16);
                    lineNext.string = "NEXT: " ++ nextStr;
                };
                ~procHud[\view].front;
            };
        }{
            "[HUD] no MagicDisplayGUI; cannot render".postln;
        };
        nil
    });
};

// public API
~procHud_install  = { ensureHud.value };
~procHud_update   = { renderHud.value };
~procHud_relocate = { arg cornerSymbol;
    var corner;
    corner = cornerSymbol ? \topLeft;
    posCorner = ([\topLeft, \topRight].includes(corner)).if({ corner }, { \topLeft });
    renderHud.value;
};

// install & draw once
~procHud_install.();
AppClock.sched(0.10, { ~procHud_update.(); nil });
)
// MagicDisplayGUI_ProcessorsHUD.scd
// v0.2.1
// MD 20250918-21:05 BST

/*
Purpose
- Add a lightweight "Processors HUD" to the existing MagicDisplayGUI window.
- Shows CURRENT and NEXT processor tails (symbols). Updates via ~procHud_update.

Style
- var-first in every function/closure; lowercase names; no server.sync; AppClock for GUI only;
- one window only (install into the existing MagicDisplayGUI* window).
*/

(
var symbolsToString, extractTail, findGuiWindow, clampRect, hudInstall, hudRender;

/********** helpers **********/
symbolsToString = { arg syms;
    var namesArray, joined;
    namesArray = syms.collect(_.asString);
    joined = namesArray.join(" \u2192 "); // arrow
    joined
};

extractTail = { arg chainArray;
    var arr;
    arr = chainArray ? [];
    if(arr.size > 0) { arr.copyRange(1, arr.size - 1) } { [] }
};

findGuiWindow = {
    var wins, target;
    wins = Window.allWindows.select({ arg w;
        var nm, isMagic;
        nm = w.tryPerform(\name);
        isMagic = nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") };
        isMagic
    });
    target = wins.last;
    target
};

clampRect = { arg parentRect;
    var x, y, w, h;
    x = 10;
    w = (parentRect.width - 20).max(160);
    h = 46;
    y = (parentRect.height - (h + 10)).max(10);
    Rect(x, y, w, h)
};

/********** installer (explicit bounds; no FlowLayout; no caret returns) **********/
hudInstall = {
    AppClock.sched(0, {
        var win, root, r, box, title, lineA, lineB, exists;

        win = findGuiWindow.value;
        if(win.notNil) {
            root = win.view;

            exists = (~procHud.notNil)
                and: { ~procHud[\view].notNil }
                and: { ~procHud[\view].isClosed.not };

            if(exists.not) {
                r = clampRect.value(root.bounds);

                box = CompositeView(root, r)
                    .background_(Color(0.12, 0.12, 0.12, 0.88));

                title = StaticText(box, Rect(8, 6, (r.width - 16).max(80), 16))
                    .string_("Processors HUD")
                    .stringColor_(Color(0.9,0.9,0.9));

                lineA = StaticText(box, Rect(8, 22, (r.width - 16).max(80), 16))
                    .string_("CURRENT: -")
                    .stringColor_(Color(0.9,0.9,0.9));

                lineB = StaticText(box, Rect(8, 38, (r.width - 16).max(80), 16))
                    .string_("NEXT:    -")
                    .stringColor_(Color(0.8,0.8,0.8));

                ~procHud = IdentityDictionary[
                    \view        -> box,
                    \lineCurrent -> lineA,
                    \lineNext    -> lineB
                ];

                "[HUD] installed into MagicDisplayGUI".postln;
            };
        }{
            "[HUD] MagicDisplayGUI window not found yet (install will retry on update)".postln;
        };
        nil
    });
};

/********** renderer (safe guards; no caret returns) **********/
hudRender = {
    AppClock.sched(0, {
        var ok, curArr, nextArr, curTail, nextTail, curStr, nextStr, lineA, lineB, alive;

        ok = (~mpb.notNil);
        if(ok) {
            alive = (~procHud.notNil)
                and: { ~procHud[\view].notNil }
                and: { ~procHud[\view].isClosed.not };

            if(alive.not) {
                hudInstall.value;
                AppClock.sched(0.07, { hudRender.value; nil });
            }{
                curArr  = ~mpb.effectiveCurrent;
                nextArr = ~mpb.effectiveNext;

                curTail = extractTail.value(curArr);
                nextTail = extractTail.value(nextArr);

                curStr = if(curTail.size > 0) { symbolsToString.value(curTail) } { "-" };
                nextStr = if(nextTail.size > 0) { symbolsToString.value(nextTail) } { "-" };

                lineA = ~procHud[\lineCurrent];
                lineB = ~procHud[\lineNext];

                if(lineA.notNil) { lineA.string = "CURRENT: " ++ curStr };
                if(lineB.notNil) { lineB.string = "NEXT:    " ++ nextStr };
            };
        }{
            "[HUD] cannot render (no ~mpb)".postln;
        };
        nil
    });
};

/********** public API **********/
~procHud_install = { hudInstall.value };
~procHud_update  = { hudRender.value };

// install & draw once
~procHud_install.();
AppClock.sched(0.10, { ~procHud_update.(); nil });
)
/* MagicProcessorLibrary_defs.scd
   Register a few defaults. Keep this file small and readable.
*/
(
var lib, define;

lib = MagicProcessorLibrary.new;

define = { arg key, func; lib.register(key, func) };

// Sources
define.(\ts0, {
    var inputSignal;
    inputSignal = Silent.ar((0..1));
    inputSignal * 1.0
});

// Effects – same as in bootstrap, or your refined versions
define.(\delay, {
    var inputSignal, time, fb, mix, delayed;
    inputSignal = \in.ar;
    time = \time.kr(0.35).clip(0.01, 2.0);
    fb   = \fb.kr(0.35).clip(0.0, 0.95);
    mix  = \mix.kr(0.25).clip(0.0, 1.0);
    delayed = CombC.ar(inputSignal, 2.0, time, time * (fb * 6 + 0.1));
    XFade2.ar(inputSignal, delayed, (mix * 2 - 1))
});

define.(\tremolo, {
    var inputSignal, rate, depth;
    inputSignal = \in.ar;
    rate  = \rate.kr(5).clip(0.1, 20);
    depth = \depth.kr(0.5).clip(0, 1);
    inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
});

define.(\reverb, {
    var inputSignal, mix, room, damp;
    inputSignal = \in.ar;
    mix  = \mix.kr(0.25).clip(0, 1);
    room = \room.kr(0.5).clip(0, 1);
    damp = \damp.kr(0.3).clip(0, 1);
    XFade2.ar(inputSignal, FreeVerb2.ar(inputSignal[0], inputSignal[1], mix, room, damp), 0)
});

define.(\chorus, {
    var inputSignal, rate, depth, baseDelay, modDelay;
    inputSignal = \in.ar;
    rate      = \rate.kr(0.8).clip(0.1, 5);
    depth     = \depth.kr(0.008).clip(0.0, 0.02);
    baseDelay = \base.kr(0.020).clip(0.0, 0.05);
    modDelay  = baseDelay + (SinOsc.kr(rate, 0, depth));
    DelayC.ar(inputSignal, 0.1, modDelay)
});

define.(\drive, {
    var inputSignal, gain;
    inputSignal = \in.ar;
    gain = \gain.kr(2.5).clip(1, 10);
    (inputSignal * gain).tanh
});

// Expose the library in a tilde var for convenience
~procLib = lib;

// Ensure a basic set now (optional; you can call ensureFromChain later)
~procLib.ensureMany(~procLib.keys, 2);
)
// MagicStart_Prelude_SelfRun
// v0.4.9
// 2025-09-17 14:48 BST (MD)
//
// Purpose:
// - Self-running top-of-file prelude to start from a known-good state.
// - Avoid quit/boot races by reusing a healthy server + init tree + clear default group.
// - Define busMeterA / busMeterB with a COMPILE-TIME channel count to prevent In.ar errors.
// - Mix meters to mono internally to avoid language-level max comparisons on UGens.
// Style:
// - tilde vars only, var-first inside functions, no server.sync,
//   Server.default.bind for server ops, GUI-safe (AppClock), your SC coding rules respected.

(
var numChannelsConst;

// --- Decide a compile-time channel count for the meter synths ----------------
// If you already set ~defaultNumChannels elsewhere (Integer > 0), we use it; otherwise fall back to 2.
numChannelsConst = (
    ~defaultNumChannels.isKindOf(Integer) and: { ~defaultNumChannels > 0 }
).if({ ~defaultNumChannels }, { 2 });

// --- Helpers -----------------------------------------------------------------
~closeMagicDisplayGUIWindows = {
    var windows;
    windows = Window.allWindows.select { |w|
        var name;
        name = w.tryPerform(\name);
        name.notNil and: { name.asString.beginsWith("MagicDisplayGUI") }
    };
    windows.do { |w| w.close };
    "[START] closed any existing MagicDisplayGUI windows".postln;
};

~ensureServerReady = {
    var s;
    s = Server.default;

    if (s.serverRunning) {
        "[START] server already running → reusing".postln;
    } {
        if (s.booting) {
            "[START] server already booting → waiting…".postln;
        } {
            "[START] booting server…".postln;
            s.boot;
        };
        s.waitForBoot;
    };

    Server.default.bind({
        s.initTree;
        s.defaultGroup.freeAll;
    });
    "[START] tree inited + default group cleared".postln;
};

~ensureMeterDefs = {
    var needA, needB;
    needA = SynthDescLib.global.at(\busMeterA).isNil;
    needB = SynthDescLib.global.at(\busMeterB).isNil;

    if (needA or: { needB }) {
        ("[START] (re)defining meter synths with numChannelsConst=" ++ numChannelsConst).postln;

        // Capture numChannelsConst at SynthDef build time (literal inside the UGen graph).
        Server.default.bind({
            SynthDef(\busMeterA, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                // choose an index: \bus if >=0 else \in (control-rate comparator is fine for Select)
                useBus = Select.kr(bus >= 0, [in, bus]);
                // read exactly numChannelsConst channels (compile-time integer)
                sig    = In.ar(useBus, numChannelsConst);
                // mix to mono to avoid language-level max across arrays of UGens
                mono   = Mix(sig);
                // meters
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterA", [rms, peak]);
            }).add;

            SynthDef(\busMeterB, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                useBus = Select.kr(bus >= 0, [in, bus]);
                sig    = In.ar(useBus, numChannelsConst);
                mono   = Mix(sig);
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterB", [rms, peak]);
            }).add;
        });
    };
};

// Optional: quick chain channel sanity check (posted if chains already exist)
~checkChainChannels = {
    var a, b;
    a = Ndef(\chainA).tryPerform(\numChannels);
    b = Ndef(\chainB).tryPerform(\numChannels);
    if(a.notNil or: { b.notNil }) {
        "[CHECK] Ndef chain channels → A:% , B:%".format(a, b).postln;
    };
};

// --- Execute preflight now (self-running) ------------------------------------
~closeMagicDisplayGUIWindows.value;
~ensureServerReady.value;
~ensureMeterDefs.value;
~checkChainChannels.value;   // harmless if chains don't exist yet
"[READY] MagicStart prelude complete — continue with your runner code below.".postln;
)
// Manage_MagicDisplayGUI_Singleton.scd
// v0.1
// MD 20250917-1230
//
// Purpose: Close any existing MagicDisplayGUI windows and spawn one fresh GUI,
//          then (optionally) create/recreate ~mpb bound to that GUI.
// Style: tilde vars, var-first, lowercase names, AppClock for GUI ops.
//        no server.sync; server ops should happen elsewhere.

(
var closeExisting, createNew;

closeExisting = {
    AppClock.sched(0.0, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            (w.name ? "").asString.beginsWith("MagicDisplayGUI")
        });
        wins.do({ arg w; w.close });
        nil
    });
};

createNew = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI.new;
        ~mpb = MagicPedalboardNew.new(~gui);
        nil
    });
};

closeExisting.value;
createNew.value;
)
// Milestone_QueueResponse.scd
// v0.1.1
// MD 2025-09-18 13:56 BST
/*
Purpose
- One-button milestone demo: build the token-harness, run a short token playlist,
  and print concise checks. Use after bring-up.

Style
- var-first; lowercase; no server.sync; GUI on AppClock; audio graph owned by class code.
*/

(
/*("bob").postln;*/
var log, need, ensureSources, verify, run;

log = { arg s; ("[MILESTONE] " ++ s).postln };

need = {
    var ok;
    ok = (~mpb.notNil and: { ~gui.notNil });
    if(ok.not) { "[MILESTONE] ~mpb/~gui are nil. Run the bring-up script first.".warn };
    ^ok;
};

ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

verify = { arg tag = "now";
    var aPlaying, bPlaying;
    aPlaying = Ndef(\chainA).isPlaying;
    bPlaying = Ndef(\chainB).isPlaying;
    ("[PLAY] A=% B=%".format(aPlaying, bPlaying)).postln;
    ~mpb.printChains;
    ("[CHECK] " ++ tag).postln;
};

run = {
    var gap, h, playlist;
    gap = 0.60;

    "CT_TokenQueueHarness.scd".loadRelative;
    ~ctq = ~ctq_makeHarness.(~mpb, ~gui, gap);

    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    verify.("after prime");

    playlist = [
        ["insert","delay"],
        ["switch"],
        ["bypass","delay","on"],
        ["bypass","delay","off"],
        ["switch"]
    ];

    ~ctq[\runPlaylist].(playlist, gap);
    AppClock.sched(playlist.size * gap + 0.8, { verify.("after playlist"); nil });
};

if(need.()) {
    ensureSources.();
    run.();
};
)
(
// mpb_exclusiveReset_now.scd
// v0.1
// MD 20250916

var reportStatus;

reportStatus = {
    var aPlaying, bPlaying, textOut;
    aPlaying = Ndef(\chainA).isPlaying;
    bPlaying = Ndef(\chainB).isPlaying;
    textOut = "[status] A.playing=%  B.playing=%".format(aPlaying, bPlaying);
    textOut.postln;
};

// Reset MPB: leaves CURRENT playing and NEXT stopped
~mpb.reset;
reportStatus.();
)
// OneShot_Acceptance_CommandDriven.scd
// v0.2.3
// MD 20250917-1312
//
// Purpose: Robust, non-intrusive acceptance using your adapter.
//          - Waits for server + ~mpb + adapter
//          - Disables meters only during ops (to avoid attach races)
//          - Pins stereo shape with mold(2,\audio) (does NOT overwrite sink sources)
//          - Enforces Option A at source level; hard-drops NEXT monitor with .end
//            (does NOT replace NEXT’s source), so flags match audio
//          - Drives: /add/delay → /switch → /bypass/delay/on → /bypass/delay/off → /switch
//          - Asserts A XOR B after each step and prints a summary
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind. GUI AppClock only; one window.

(
var log, step, t,
    ready, disableMeters, enableMeters,
    pinStereoSinks, ensureSources, baselineExclusive,
    enforceOptionA_EndNext, assertXor, apply, runScenario;

var passCount, failCount;
passCount = 0; failCount = 0;

// helpers
log  = { arg s; ("[ACCEPT] " ++ s).postln };
step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

// timings
t = ( prep:0.00, baseline:0.25, add:0.45, sw1:0.75, byOn:1.05, byOff:1.30, sw2:1.60, meters:1.90, sum:2.10 );

// readiness
ready = {
    if(Server.default.serverRunning.not) { Server.default.boot };
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
    if(~ct_applyOSCPathToMPB.isNil) {
        "[ACCEPT] adapter missing: eval adapter_commandtree_to_magicpedalboard.scd, then rerun.".warn;
        ^false
    };
    true
};

// meters control (non-intrusive)
disableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(false);
        log.("meters disabled");
    };
};
enableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(true);
        log.("meters enabled");
    };
};

// non-destructive stereo pin (NO source overwrite)
pinStereoSinks = {
    Server.default.bind({
        Ndef(\chainA).mold(2, \audio);
        Ndef(\chainB).mold(2, \audio);
        // NOTE: no Ndef(\chainX, { \in.ar(2) }) here; class manages sources.
    });
    log.("sinks pinned: mold(2,audio) (non-destructive)");
};

// sources (safe to define)
ensureSources = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(3.2);
            var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            var f    = Demand.kr(trig, 0, seq);
            var env  = Decay2.kr(trig, 0.01, 0.35);
            var tone = SinOsc.ar(f) * env * 0.25;
            var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        }); Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
    log.("sources ensured (\\testmelody, \\ts0)");
};

// enforce Option A at source level + drop NEXT monitor only (NO source overwrite)
enforceOptionA_EndNext = {
    var nextSink = ~mpb.nextChain[0];
    ~mpb.enforceExclusiveCurrentOptionA(0.1);    // class silences NEXT at source
    Server.default.bind({
        Ndef(nextSink).end;                      // drop monitor/flag
        // do NOT change next sink’s source here; class manages it
        Ndef(nextSink).mold(2, \audio);         // keep shape pinned
    });
    log.("Option A enforced + NEXT ended (monitor dropped)");
};

// baseline: CURRENT <- \testmelody
baselineExclusive = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
    enforceOptionA_EndNext.value;
};

// A XOR B assert
assertXor = { arg expectA, expectB, label;
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying, ok;
    ok = (a == expectA) and: { b == expectB };
    ((ok.if({"PASS"},{"FAIL"})) ++ " — " ++ label ++ " (A=" ++ a ++ " B=" ++ b ++ ")").postln;
    if(ok) { passCount = passCount + 1 } { failCount = failCount + 1 };
    ok
};

// adapter apply
apply = { arg pathString; ~ct_applyOSCPathToMPB.(pathString, ~mpb, ~gui) };

// scenario
runScenario = {
    if(ready.value.not) { ^nil };

    disableMeters.value;
    pinStereoSinks.value;
    ensureSources.value;

    baselineExclusive.value;
    ~mpb.printChains;
    assertXor.value(true, false, "baseline: CURRENT audible; NEXT silent");

    apply.value("/add/delay");
    ~mpb.printChains;
    assertXor.value(true, false, "after add/delay (NEXT) — exclusivity holds");

    apply.value("/switch");               // A->B
    step.value(0.35, {
        enforceOptionA_EndNext.value;     // drop NEXT flag only (no source changes)
        ~mpb.printChains;
        assertXor.value(false, true, "after first switch — NEXT→CURRENT");

        apply.value("/bypass/delay/on");
        ~mpb.printChains;
        assertXor.value(false, true, "after bypass on (CURRENT)");

        apply.value("/bypass/delay/off");
        ~mpb.printChains;
        assertXor.value(false, true, "after bypass off (CURRENT)");

        apply.value("/switch");           // B->A
        step.value(0.35, {
            enforceOptionA_EndNext.value;
            ~mpb.printChains;
            assertXor.value(true, false, "after second switch — back to A");

            enableMeters.value;
            ("[ACCEPT] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount).postln;
            nil
        });
        nil
    });
};

// run
runScenario.value;
)
// OneShot_Acceptance_SwitchDelay.scd
// v0.1
// MD 20250916-1618

// Purpose: Automated acceptance: baseline -> add \delay to NEXT -> switch (0.12s) -> verify exclusive playback and chain contents; includes basic PASS/FAIL counting and GUI meter retarget.
// Style: tilde vars, var-first, lowercase names, no server.sync, Server.default.bind for server ops.

(
var log, passCount, failCount, assertTrue, step, timePlan, ensureSinks, ensureGuiMpb, ensureSource, ensureDelayProc, verifyExclusive, runScenario;

log = { arg s; ("[ACCEPT] " ++ s).postln };

passCount = 0; failCount = 0;
assertTrue = { arg cond, label;
    var text;
    text = if(cond) { "PASS" } { "FAIL" };
    ("[ACCEPT] " ++ text ++ " — " ++ label).postln;
    if(cond) { passCount = passCount + 1 } { failCount = failCount + 1 };
};

step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

timePlan = ( sinks:0.05, gui:0.10, source:0.20, meters:0.30, baseline:0.45, add:0.60, switch:0.80, verify2:1.10, bypassOn:1.30, bypassOff:1.50, switchBack:1.70, summary:1.95 );

// 1) Robust sinks (consumes \in) + AR buses
ensureSinks = {
    log.("ensure sinks robust + audio-rate");
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) });
        Ndef(\chainB, { \in.ar(2) });
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
};

// 2) GUI + MPB
ensureGuiMpb = {
    log.("ensure GUI + MPB");
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};

// 3) Known-good internal source
ensureSource = {
    log.("define \\testmelody");
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);
    });
};

// 4) Ensure proc (\delay) exists (stereo)
ensureDelayProc = {
    log.("ensure \\delay processor exists");
    Server.default.bind({
        Ndef(\delay, { |time=0.45, fb=0.35, mix=0.5|
            var sig = \in.ar(2);
            var delayed = CombC.ar(sig, 2.0, time.clip(0.01,2.0), time * (fb.clip(0,0.95)*6 + 0.1));
            XFade2.ar(sig, delayed, (mix.clip(0,1) * 2 - 1))
        });
        Ndef(\delay).ar(2);
    });
};

// helper: verify exclusive CURRENT (A XOR B playing)
verifyExclusive = { arg expectAPlaying, expectBPlaying, label;
    var a, b, match;
    a = Ndef(\chainA).isPlaying;
    b = Ndef(\chainB).isPlaying;
    match = (a == expectAPlaying) and: { b == expectBPlaying };
    assertTrue.(match, label ++ " (A=" ++ a ++ " B=" ++ b ++ ")");
};

// 5) Scenario: baseline -> add \delay (NEXT) -> switch -> verify -> bypass current on/off -> switch back
runScenario = {
    log.("baseline: CURRENT <- \\testmelody; play A, stop B; meters reattach");
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
    Server.default.bind({
        if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
        if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
    });
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false); ~gui.enableMeters(true) };

    ~mpb.printChains;
    verifyExclusive.(true, false, "baseline exclusive: A=true, B=false");

    log.("add \\delay to NEXT, then switch (0.12s)");
    ~mpb.add(\delay);
    ~mpb.printChains;
    ~mpb.switchChain(0.12);

    // verify after fade
    step.(0.25, {
        verifyExclusive.(false, true, "after switch: A=false, B=true");
        ~mpb.printChains;

        log.("bypassCurrent(\\delay, true) then false");
        ~mpb.bypassCurrent(\delay, true);
        ~mpb.printChains;
        ~mpb.bypassCurrent(\delay, false);
        ~mpb.printChains;

        log.("switch back to A");
        ~mpb.switchChain(0.12);

        step.(0.25, {
            verifyExclusive.(true, false, "after switch-back: A=true, B=false");
            ("[ACCEPT] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount).postln;
        });
    });
};

// --- run sequence (no server.sync; AppClock timing) ---
Server.default.boot;
step.(timePlan[\sinks], { ensureSinks.value });
step.(timePlan[\gui],   { ensureGuiMpb.value });
step.(timePlan[\source],{ ensureSource.value });
step.(timePlan[\meters],{ if(~gui.notNil, { ~gui.enableMeters(false); ~gui.enableMeters(true) }) });
step.(timePlan[\baseline], { runScenario.value });

)
// OneShot_BringUp_MagicPedalboardNew_GUI_Meters.scd
// v0.2.1
// MD 20250917-1208
//
// Purpose: Deterministic bring-up: disable meters early; stereo sinks (\in.ar(2)); \ts0 stereo Silent;
//          define \testmelody; play CURRENT; enforce Option A; then explicitly pause NEXT so
//          isPlaying=B=false; enable meters; verify A XOR B.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind. GUI on AppClock only; one window.

(
var log, step, t,
    doBoot, ensureGuiMpb_disableMetersEarly, ensureSinksStereo, ensureTs0SilentStereo,
    ensureTestMelody, startCurrent_enforceExclusive, forceNextPauseFlag, enableMetersClean, verifyState;

log  = { arg s; ("[BRINGUP] " ++ s).postln };
step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

// timings (seconds)
t = (
    boot:     0.00,
    guiMpb:   0.35,
    sinks:    0.50,
    ts0:      0.65,
    source:   0.80,
    current:  1.00,
    nextPause:1.05,   // tiny step after Option A
    meters:   1.20,
    verify:   1.40
);

doBoot = {
    log.("boot audio");
    Server.default.boot;
};

ensureGuiMpb_disableMetersEarly = {
    log.("ensure GUI + pedalboard; disable meters early");
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    // proactively disable meters twice (beats any queued enable)
    AppClock.sched(0.00, { ~gui.enableMeters(false); nil });
    AppClock.sched(0.05, { ~gui.enableMeters(false); nil });

    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};

ensureSinksStereo = {
    log.("robust sinks: \\in.ar(2) + ar(2)");
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) }); Ndef(\chainA).ar(2);
        Ndef(\chainB, { \in.ar(2) }); Ndef(\chainB).ar(2);
    });
};

ensureTs0SilentStereo = {
    log.("define \\ts0 as stereo Silent (for NEXT)");
    Server.default.bind({
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

ensureTestMelody = {
    log.("define \\testmelody (stereo)");
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(3.2);
            var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            var f    = Demand.kr(trig, 0, seq);
            var env  = Decay2.kr(trig, 0.01, 0.35);
            var tone = SinOsc.ar(f) * env * 0.25;
            var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
};

startCurrent_enforceExclusive = {
    log.("CURRENT <- \\testmelody; play + enforce Option A");
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;                         // MPB enforces Option A after play
    ~mpb.enforceExclusiveCurrentOptionA(0.1); // belt-and-braces: NEXT hard-silenced + stop
};

forceNextPauseFlag = {
    // Ensure NEXT.isPlaying == false (state aligns with Option A audio silence)
    var nextSink;
    nextSink = ~mpb.nextChain[0];             // sink symbol (chainB if A is current)
    Server.default.bind({ Ndef(nextSink).pause });
    log.("NEXT paused (flag B=false)");
};

enableMetersClean = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        log.("enable meters (guards + re-sends SynthDefs)");
        ~gui.enableMeters(true);
    };
};

verifyState = {
    log.("verify");
    ~mpb.printChains;
    AppClock.sched(0.25, {
        var a = Ndef(\chainA).isPlaying;
        var b = Ndef(\chainB).isPlaying;
        ("[PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

log.("start deterministic bring-up");
step.(t[\boot],     { doBoot.value });
step.(t[\guiMpb],   { ensureGuiMpb_disableMetersEarly.value });
step.(t[\sinks],    { ensureSinksStereo.value });
step.(t[\ts0],      { ensureTs0SilentStereo.value });
step.(t[\source],   { ensureTestMelody.value });
step.(t[\current],  { startCurrent_enforceExclusive.value });
step.(t[\nextPause],{ forceNextPauseFlag.value });   // <-- NEW tiny step
step.(t[\meters],   { enableMetersClean.value });
step.(t[\verify],   { verifyState.value });
)
// OneShot_BringUp_MinimalOnly.scd
// v0.1
// MD 20250916-1608

(
// =========================================================

// Purpose: bring up to a clean audible baseline (no FX demo);
//          robust sinks; retarget meters; verify.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

// =========================================================

var log, step, t, doBoot, ensureSinks, ensureGuiMpb, ensureSource,
    enforceExclusiveCurrent, ensureMetersOk, verifyState;

log = { arg s; ("[BRINGUP] " ++ s).postln };
step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

// timings
t = ( boot:0.00, sinks:0.40, guiMpb:0.55, source:0.75, current:0.95, meters:1.15, verify:1.35 );

doBoot = { log.("boot audio"); Server.default.boot; };

ensureSinks = {
    log.("ensure sinks robust + AR");
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) }); Ndef(\chainB, { \in.ar(2) });
        Ndef(\chainA).ar(2);          Ndef(\chainB).ar(2);
    });
};

ensureGuiMpb = {
    log.("ensure GUI + MPB");
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};

ensureSource = {
    log.("define \\testmelody (stereo)");
    Server.default.bind({
        Ndef(\testmelody, {
            var trig=Impulse.kr(3.2), seq=Dseq([220,277.18,329.63,392,329.63,277.18,246.94],inf);
            var f=Demand.kr(trig,0,seq), env=Decay2.kr(trig,0.01,0.35);
            var tone=SinOsc.ar(f)*env*0.25, pan=ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
};

enforceExclusiveCurrent = {
    log.("CURRENT <- \\testmelody; play A, stop B");
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
    Server.default.bind({
        if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
        if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
    });
};

ensureMetersOk = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        log.("meters retarget");
        ~gui.enableMeters(false); ~gui.enableMeters(true);
    };
};

verifyState = {
    log.("verify");
    ~mpb.printChains;
    AppClock.sched(0.15, {
        "[PLAY] A=%  B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)
        .postln; nil
    });
};

log.("starting bring‑up (minimal)");
step.(t[\boot],    { doBoot.value });
step.(t[\sinks],   { ensureSinks.value });
step.(t[\guiMpb],  { ensureGuiMpb.value });
step.(t[\source],  { ensureSource.value });
step.(t[\current], { enforceExclusiveCurrent.value });
step.(t[\meters],  { ensureMetersOk.value });
step.(t[\verify],  { verifyState.value });

)
// OneShot_ResetToCleanBaseline.scd
// v0.6
// MD 20250916-1708

//
// Purpose: Reset to a clean, audible baseline and GUARANTEE exclusivity by silencing NEXT.
//          Ensures robust sinks (\in.ar(2)), defines \testmelody, uses MPB.reset, then enforces
//          CURRENT-only by muting NEXT at the sink source; retargets meters and prints final state.
// Style:   tilde vars; var-first; lowercase names; no server.sync; Server.default.bind for server ops.

(
var log, ensureSinksRobust, ensureSource, ensureGuiMpb, doMpbReset,
    setCurrent, enforceExclusiveBySilence, retargetMeters, verify;

log = { arg s; ("[RESET] " ++ s).postln; };

// Robust sinks + AR
ensureSinksRobust = {
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) });
        Ndef(\chainB, { \in.ar(2) });
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
};

// Internal source
ensureSource = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, pan;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
            f    = Demand.kr(trig,0,seq);
            env  = Decay2.kr(trig,0.01,0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
};

// GUI + MPB and reset
ensureGuiMpb = {
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};
doMpbReset = { ~mpb.reset };

// CURRENT <- testmelody; play
setCurrent = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
};

// Silencing strategy: mute NEXT sink’s source (hard silence), keep CURRENT robust+playing
enforceExclusiveBySilence = {
    var currentSink, nextSink;
    currentSink = ~mpb.effectiveCurrent[0];
    nextSink    = ~mpb.effectiveNext[0];

    Server.default.bind({
        // CURRENT robust + playing
        Ndef(currentSink, { \in.ar(2) });
        Ndef(currentSink).ar(2);
        Ndef(currentSink).fadeTime_(0.05);
        if(Ndef(currentSink).isPlaying.not) { Ndef(currentSink).play(numChannels: 2) };

        // NEXT silenced at source (even if its monitor claims 'playing', it contributes 0 audio)
        Ndef(nextSink, { Silent.ar(2) });
        Ndef(nextSink).ar(2);
        Ndef(nextSink).fadeTime_(0.01);
        Ndef(nextSink).stop;
    });
    log.("exclusive enforced by silencing NEXT " ++ nextSink.asString);
};

// meters after AR
retargetMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(false);
        ~gui.enableMeters(true);
    };
};

// final print
verify = {
    ~mpb.printChains;
    AppClock.sched(0.25, {
        ("[PLAY] A=%  B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

log.("start");
Server.default.boot;

ensureSinksRobust.value;
ensureGuiMpb.value;
doMpbReset.value;
ensureSource.value;
setCurrent.value;
enforceExclusiveBySilence.value;
retargetMeters.value;
verify.value;
)
// Patch_StartHere_Milestone_BringUpAndRun_freshBoot_Fix.scd
// v0.1.4a
// MD 20250918-18:02 BST

/* Purpose
   Replace the freshBoot step with a doWhenBooted-aware version that proceeds even if
   the server is already booting. Avoids stalls at "already booting". No server.sync.

   Style
   - var-first in every function/closure; lowercase method names; no server.sync
   - server ops inside Server.default.bind; GUI on AppClock
*/

(
var replaceFreshBoot;

replaceFreshBoot = {
    var serverRef, didInitFlag, doInitTreeFunc, safeInitOnceFunc, startBootFunc;

    serverRef = Server.default;
    didInitFlag = false;

    doInitTreeFunc = {
        var ignore;
        if(didInitFlag) { ^nil };
        didInitFlag = true;
        ignore = nil;
        Server.default.bind({
            serverRef.initTree;
            serverRef.defaultGroup.freeAll;
        });
        MagicDisplay.setMeterChannels(2);
        "[RUN] server tree inited; meter defs set to 2ch".postln;
    };

    safeInitOnceFunc = {
        // Guard against multiple signals (doWhenBooted + polls)
        if(serverRef.serverRunning) { doInitTreeFunc.value };
    };

    // Subscribe once; SC clears the function after it fires
    serverRef.doWhenBooted({ AppClock.sched(0, { safeInitOnceFunc.value; nil }) });

    if(serverRef.serverRunning) {
        "[RUN] fresh boot: quitting current server…".postln;
        serverRef.quit;
        AppClock.sched(0.05, {
            var waitDown;
            waitDown = {
                if(serverRef.serverRunning.not and: { serverRef.booting.not }) {
                    serverRef.boot;
                    nil
                }{
                    AppClock.sched(0.05, waitDown)
                }
            };
            waitDown.value;
            nil
        });
    }{
        // server not running
        if(serverRef.booting) {
            "[RUN] server is already booting; will init when boot completes…".postln;
            // doWhenBooted will trigger doInitTreeFunc
        }{
            "[RUN] fresh boot: starting server…".postln;
            serverRef.boot;
        };
    };
};

freshBoot = replaceFreshBoot; // replace original binding in the script runtime
)
// prep_demo_audio_gui_current.scd
// v0.1
// MD 20250916-1046

(
var ensureSource;

Server.default.boot;

// ensure a musical internal source
ensureSource = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);
        // simple FX
        Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
            var sig, delayed, bal;
            sig = \in.ar(2);
            delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
            bal = (mix.clip(0,1) * 2 - 1);
            XFade2.ar(sig, delayed, bal)
        });
    });
};

// one GUI window via your runner
~md_bootProbeScenario.();

// ensure GUI + pedalboard, and make CURRENT audible
~gui = ~gui ?? { MagicDisplayGUI.new() };
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
~pedalboard.reset;
~pedalboard.setSourceCurrent(\testmelody);  // CURRENT, so it's audible immediately
~pedalboard.playCurrent;
~pedalboard.printChains;
)
// Probe_Ndef_SinkState.scd
// v0.1
// MD 20250916-1700

//
// Purpose: Safely inspect a sink Ndef’s current source object and playing/paused/monitor status.
//          Uses .source (not .sourceCode) and prints class + optional asCompileString if available.
// Style:   tilde vars, var-first, lowercase names, no server.sync, Server.default.bind for server ops.

(
var key, nx, srcObj, srcClass, srcCode, mon, playing, paused;

key = \chainA; // change to \chainA if you want to probe A

nx       = Ndef(key);
srcObj   = nx.source;                 // current source object (Function or other)
srcClass = srcObj.class;
srcCode  = srcObj.tryPerform(\asCompileString); // may be nil if not supported
mon      = nx.monitor;                // monitor object (if any)
playing  = nx.isPlaying;
paused   = nx.paused ? false;         // NodeProxy sometimes keeps paused flag internally

("[PROBE] key=%  class=%  playing=%  paused=%  hasMonitor=%"
    .format(key, srcClass, playing, paused, mon.notNil)).postln;

if(srcCode.notNil) {
    "[PROBE] source asCompileString:".postln;
    srcCode.postln;
} {
    "[PROBE] source does not implement asCompileString; printing .source:".postln;
    srcObj.postln;
};
)
// quick_start_audible.scd
// v0.1

(
// 0) Recompile classes first (Cmd+Shift+L) if you just edited them.
// 1) GUI + pedalboard
~gui = ~gui ?? { MagicDisplayGUI.new };
~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };

// 2) Make CURRENT use our internal melody, play it
~mpb.setSourceCurrent(\testmelody);
~mpb.playCurrent;

// 3) Add delay to NEXT and switch (should hear the echo)
~mpb.add(\delay);
~mpb.switchChain(0.12);

// 4) If you still hear nothing, run the recover helper:
~recoverIfSilent.();

// 5) Inspect
~mpb.printChains;
"[[PLAY]] A=%  B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying).postln;
)
// quickpatch.scd
// Quick Patch — GUI/Audio sync + reliable GUI front
// v0.1.0
// MD 20250919-10:10 BST

(

/*
Purpose
- Keep MagicDisplayGUI columns/headers in sync with the actual CURRENT (A/B).
- Remember the NEXT effect symbol so the right column shows something useful.
- Wrap ~switchNow to refresh the GUI automatically after audio toggles.
- Bring GUI window to the front; keep the grey UserDisplay behind.

Style
- var-first; lowercase; AppClock-only; no server.sync.
*/

var installGuiSync;

installGuiSync = {
    var ensureGuiFront, refreshFromState, wrapSwitch, hookApply;

    ensureGuiFront = {
        var gwin;
        ~gui = ~gui ?? { MagicDisplayGUI_GridDemo.new };
        if(~gui.respondsTo(\window)) {
            gwin = ~gui.window;
            if(gwin.notNil) { gwin.front; gwin.alwaysOnTop_(true) };
        };
        if(~ct.notNil and: { ~ct.display.notNil and: { ~ct.display.window.notNil } }) {
            ~ct.display.window.alwaysOnTop_(false);
        };
        if(~gui.notNil) { ~gui.showExpectation("GUI ready; syncing with audio state…", 0) };
        nil
    };

    refreshFromState = {
        var current, next, effC, effN, bA, bB, effSym, nowA;
        bA = []; bB = [];
        effSym = ~nextEffectSym ? \delay;   // default if none chosen yet
        nowA = (~currentIsA ? true);

        if(~gui.isNil) { ^nil };

        if(nowA) {
            // CURRENT=A, NEXT=B
            current = [\chainA, \testmelody];
            next    = [\chainB, effSym, \testmelody];
            ~gui.highlightCurrentColumn(\chainA);
        }{
            // CURRENT=B, NEXT=A
            current = [\chainB, \testmelody];
            next    = [\chainA, effSym, \testmelody];
            ~gui.highlightCurrentColumn(\chainB);
        };
        effC = current; effN = next;

        ~gui.showChainsDetailed(current, next, bA, bB, effC, effN);
        nil
    };

    wrapSwitch = {
        // decorate ~switchNow so it always refreshes the GUI after toggling
        if(~switchNow.notNil) {
            ~switchNow_raw = ~switchNow;
            ~switchNow = {
                ~switchNow_raw.();
                AppClock.sched(0.02, { refreshFromState.value; nil });
            };
        };
        nil
    };

    hookApply = {
        // provide a helper the bridge (or you) can call that both applies FX and refreshes
        ~applyCTEffect = { arg effSym;
            ~nextEffectSym = effSym;
            if(~applyToNext.notNil) { ~applyToNext.(effSym) };
            AppClock.sched(0.02, { refreshFromState.value; nil });
        };
        nil
    };

    ensureGuiFront.value;
    wrapSwitch.value;
    hookApply.value;

    // initial fill so the columns aren’t empty
    AppClock.sched(0.01, { refreshFromState.value; nil });

    "[PATCH] GUI sync installed".postln;
    nil
};

AppClock.sched(0.0, { installGuiSync.value; nil });
)
// quickprep.scd
// v0.1
// MD 20250916


(
// ===== Acceptance Prep =====
var linkedDisplay, hasGui, chainAName, chainBName;

linkedDisplay = nil;
hasGui = (~gui.notNil) and: { ~gui.isKindOf(MagicDisplayGUI) };
if(hasGui) { linkedDisplay = ~gui };

if(~mpb.isNil) {
    ~mpb = MagicPedalboardNew.new(linkedDisplay);
} {
    if(linkedDisplay.notNil) { ~mpb.setDisplay(linkedDisplay) };
};

// create a simple stereo test melody (safe levels)
Ndef(\testmelody, {
    var freq, lfo, sig;
    lfo = LFTri.kr(0.13).range(0.5, 1.0);
    freq = [220, 330] * lfo;
    sig = SinOsc.ar(freq, 0, 0.08);  // quiet
    sig
});

// set source to \testmelody on both chains (explicit)
~mpb.setSourceCurrent(\testmelody);
~mpb.setSource(\testmelody);

// start CURRENT sink (A by default on fresh boot)
~mpb.playCurrent;

// convenience: names for readability
chainAName = \chainA;
chainBName = \chainB;

// status
"Prep done. CURRENT is playing. A.isPlaying=%, B.isPlaying=%"
    .format(Ndef(chainAName).isPlaying, Ndef(chainBName).isPlaying).postln;
)
// QuickRestore_AudioAndExclusive.scd
// v0.2
// MD 20250917-1338
//
// Purpose: If audio is quiet, rebuild class-managed wiring (uses Ndef(left) <<> Ndef(right))
//          and re-enforce Option A. No sink-source overwrites.

(
var log; log = { arg s; ("[RESTORE] " ++ s).postln };

if(~mpb.isNil) { "[RESTORE] ~mpb is nil".warn; ^nil };

Server.default.bind({
    ~mpb.rebuildUnbound(~mpb.currentChain);   // internally uses Ndef(left) <<> Ndef(right)
    ~mpb.rebuildUnbound(~mpb.nextChain);
});
~mpb.playCurrent;
~mpb.enforceExclusiveCurrentOptionA(0.1);

AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[RESTORE] [PLAY] A=% B=%".format(a, b)).postln;
    nil
});
)
// RebuildAndRestore_OptionA.scd
// v0.1
// MD 20250917-1230
//
// Purpose: Recover class-managed wiring and Option A without touching sink sources.
// Style: tilde vars, var-first, no server.sync, Server.default.bind.

(
var log;
log = { arg s; ("[RECOVER] " ++ s).postln };

if(~mpb.isNil) { "[RECOVER] ~mpb is nil".warn; ^nil };

Server.default.bind({
    ~mpb.rebuildUnbound(~mpb.currentChain);   // uses Ndef(left) <<> Ndef(right) internally
    ~mpb.rebuildUnbound(~mpb.nextChain);
});

~mpb.playCurrent;
~mpb.enforceExclusiveCurrentOptionA(0.1);

AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[RECOVER] [PLAY] A=% B=%".format(a, b)).postln;
    nil
});
)
(
// retargetMeters.scd
// v0.1
// MD 20250916

var ensureAudioRateAndReloadMeters, hasGui;

ensureAudioRateAndReloadMeters = {
    hasGui = (~gui.notNil) and: { ~gui.isKindOf(MagicDisplayGUI) };

    // Turn meters off to free Synths/OSCdefs cleanly
    if(hasGui) { ~gui.enableMeters(false) };

    // Ensure sinks are audio-rate proxies (2 channels)
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // Turn meters back on; will now bind to the audio buses
    if(hasGui) { ~gui.enableMeters(true) };

    "[meters] reattached to audio-rate buses".postln;
};

ensureAudioRateAndReloadMeters.();
)
// Run_Milestone_Today.scd
// v0.1.0
// MD 20250918-19:40 BST

/* Purpose
   - Run today's milestone playlist via the adapter, assuming runner v0.6 has already succeeded.
   Style
   - var-first in every closure; lowercase; no server.sync; server ops inside adapter/MPB.
*/

(
var ok, log, guard, apply, run, gap, playlist;

log = { arg s; var t; t = "[TOKENS] " ++ s; t.postln };

ok = (~mpb.notNil) and: { ~gui.notNil } and: { ~ct_applyOSCPathToMPB.notNil };
if(ok.not) {
    "[TOKENS] Missing ~mpb/~gui or adapter. Run StartHere_* and load adapter first.".warn;
    ^nil;
};

guard = {
    var last;
    last = ~mpb.effectiveNext.last;
    if(last == \ts0) { log.("guard: NEXT ends with \\ts0 -> /setSource/testmelody"); ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui) };
};

apply = { arg path;
    var p;
    p = path.asString;
    log.("apply -> " ++ p);
    ~ct_applyOSCPathToMPB.(p, ~mpb, ~gui);
};

run = {
    var idx, count, step;
    ~mpb.setSourcesBoth(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    ~mpb.printChains;
    ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

    idx = 0; count = playlist.size;
    step = {
        if(idx >= count) {
            AppClock.sched(0.9, {
                ("[PLAY] A=% B=%"
                  .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
                ~mpb.printChains;
                nil
            });
            ^nil
        };
        if(playlist[idx] == "/switch") { guard.value };
        apply.value(playlist[idx]);
        idx = idx + 1;
        AppClock.sched(gap, step);
    };
    AppClock.sched(gap, step);
};

playlist = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

gap = 0.60;
run.value;
)
// Run_Milestone_Today.scd
// v0.2.1
// MD 20250918-21:05 BST

/*
Purpose
- Minimal, reliable milestone driver (no boot logic). Run main block once (sets up helpers + HUD),
  then run the one-liners below, in order, to hear/see the expected changes.

Style
- var-first in every function/closure; lowercase methods; no server.sync;
- server ops live inside adapter/MPB; GUI ops on AppClock; one window only; generated audio only;
- JITLib connect operator remains exactly "<<>"; processors/sinks read from \in.ar(2).
*/

(
// ---------- setup ----------

var log, ensureAdapter, symbolsToString, extractTail, findGuiWindow;
var hudInstall, hudRender, hudUpdate, wrapApply, primeToday, guardSwitch, stateLine;

// small logger
log = { arg s;
    var line;
    line = "[TOKENS] " ++ s;
    line.postln;
};

// pretty chain printing
symbolsToString = { arg syms;
    var arr, joined;
    arr = syms.collect(_.asString);
    joined = arr.join(" \u2192 ");
    joined
};

// drop leading \chainA / \chainB
extractTail = { arg chainArray;
    var arr;
    arr = chainArray ? [];
    if(arr.size > 0) { arr.copyRange(1, arr.size - 1) } { [] }
};

// find existing MagicDisplayGUI window
findGuiWindow = {
    var wins, target;
    wins = Window.allWindows.select({ arg w;
        var nm, isMagic;
        nm = w.tryPerform(\name);
        isMagic = nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") };
        isMagic
    });
    target = wins.last;
    target
};

// Ensure adapter is loaded (absolute path, no loadRelative)
ensureAdapter = {
    var scriptDir, fileLower, fileCamel, ok, p, d;
    scriptDir = ~scriptDir ?? {
        p = thisProcess.nowExecutingPath;
        d = if(p.notNil) { PathName(p).pathOnly } { thisProcess.cwd };
        d
    };
    ok = (~ct_applyOSCPathToMPB.notNil);
    if(ok.not) {
        fileLower = (scriptDir +/+ "adapter_commandtree_to_magicpedalboard.scd").standardizePath;
        fileCamel = (scriptDir +/+ "adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
        if(File.exists(fileLower)) { fileLower.load; ok = true } {
            if(File.exists(fileCamel)) { fileCamel.load; ok = true };
        };
    };
    if(ok) { "[RUN] adapter is available".postln } { "[RUN] adapter missing — please load adapter file".warn };
    ok
};

// HUD: install into existing MagicDisplayGUI (explicit bounds; no caret returns)
hudInstall = {
    AppClock.sched(0, {
        var win, root, r, box, title, lineA, lineB, exists;

        win = findGuiWindow.value;
        if(win.notNil) {
            root = win.view;

            exists = (~procHud.notNil)
                and: { ~procHud[\view].notNil }
                and: { ~procHud[\view].isClosed.not };

            if(exists.not) {
                r = Rect(10, (root.bounds.height - 56).max(10), (root.bounds.width - 20).max(160), 46);

                box = CompositeView(root, r)
                    .background_(Color(0.12, 0.12, 0.12, 0.88));

                title = StaticText(box, Rect(8, 6, (r.width - 16).max(80), 16))
                    .string_("Processors HUD")
                    .stringColor_(Color(0.9,0.9,0.9));

                lineA = StaticText(box, Rect(8, 22, (r.width - 16).max(80), 16))
                    .string_("CURRENT: -")
                    .stringColor_(Color(0.9,0.9,0.9));

                lineB = StaticText(box, Rect(8, 38, (r.width - 16).max(80), 16))
                    .string_("NEXT:    -")
                    .stringColor_(Color(0.8,0.8,0.8));

                ~procHud = IdentityDictionary[
                    \view        -> box,
                    \lineCurrent -> lineA,
                    \lineNext    -> lineB
                ];

                "[HUD] installed in MagicDisplayGUI".postln;
            };
        }{
            "[HUD] MagicDisplayGUI window not found yet; run bring-up first".postln;
        };
        nil
    });
};

// HUD: render (safe guards; no caret returns)
hudRender = {
    AppClock.sched(0, {
        var alive, curArr, nextArr, curTail, nextTail, curStr, nextStr, lineA, lineB;

        if(~mpb.notNil) {
            alive = (~procHud.notNil)
                and: { ~procHud[\view].notNil }
                and: { ~procHud[\view].isClosed.not };

            if(alive.not) {
                hudInstall.value;
                AppClock.sched(0.07, { hudRender.value; nil });
            }{
                curArr  = ~mpb.effectiveCurrent;
                nextArr = ~mpb.effectiveNext;

                curTail = extractTail.value(curArr);
                nextTail = extractTail.value(nextArr);

                curStr = if(curTail.size > 0) { symbolsToString.value(curTail) } { "-" };
                nextStr = if(nextTail.size > 0) { symbolsToString.value(nextTail) } { "-" };

                lineA = ~procHud[\lineCurrent];
                lineB = ~procHud[\lineNext];

                if(lineA.notNil) { lineA.string = "CURRENT: " ++ curStr };
                if(lineB.notNil) { lineB.string = "NEXT:    " ++ nextStr };
            };
        }{
            "[HUD] cannot render (no ~mpb)".postln;
        };
        nil
    });
};

hudUpdate = { hudRender.value };

// guard: ensure NEXT audible before /switch (avoid switching to \ts0)
guardSwitch = {
    var lastTail;
    lastTail = ~mpb.effectiveNext.last;
    if(lastTail == \ts0) {
        log.("guard: NEXT ends with \\ts0 -> /setSource/testmelody");
        ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
    };
    hudRender.value;
};

// state print (what you should see)
stateLine = {
    var line;
    ~mpb.printChains;
    line = "[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying);
    line.postln;
    hudRender.value;
};

// prime (for today's demo)
primeToday = {
    var ignore;
    ignore = nil;
    ~mpb.setSourcesBoth(\testmelody); // both tails end with testmelody
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    stateLine.value;
};

// apply wrapper: call adapter, then HUD update
wrapApply = { arg pathString;
    var p;
    p = pathString.asString;
    log.("apply -> " ++ p);
    ~ct_applyOSCPathToMPB.(p, ~mpb, ~gui);
    hudRender.value;
};

// ---------- publish helpers for your 1-liners ----------
~tok = IdentityDictionary[
    \apply       -> wrapApply,
    \prime       -> primeToday,
    \guardSwitch -> guardSwitch,
    \state       -> stateLine,
    \hudUpdate   -> hudUpdate,
    \hudInstall  -> hudInstall
];

// ---------- sanity + first render ----------
if((~mpb.isNil) or: { ~gui.isNil }) {
    "[RUN] Bring-up not ready (~mpb/~gui). Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
}{
    if(ensureAdapter.value) {
        hudInstall.value;
        AppClock.sched(0.10, { ~tok.state.(); nil });
    };
};
)
// saveonly_commandtree_current_to_json.scd
// v0.2
// MD 20250916-0942

(
var saveFolder, savePrefix, jsonPath, jsonString;

saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";
jsonPath   = (saveFolder +/+ "myTree.json").standardizePath;

// Ensure a saver instance (if nil, create one)
~saver = ~saver ?? { CircularFileSave.new(savePrefix, saveFolder, 10) };

// Serialize current in‑memory tree to JSON text
jsonString = JSONlib.convertToJSON(~tree.root.asDictRecursively);

// Save a versioned copy and overwrite the live JSON file for CommandManager
~saver.saveVersion(jsonString);
~tree.exportJSONFile(jsonPath);

"💾 Saved versioned JSON and wrote current tree to: ".postln;
jsonPath.postln;
)
// StartHere_CleanBoot_OneWindow_BringUp.scd
// v0.6
// MD 20250917-1616
//
// Purpose:
//   Known-state bring-up with one MagicDisplayGUI window, CURRENT=\testmelody
//   audible, NEXT silent (Option A), meters on, and verify A=true B=false.
//   Handles the case where GUI/MPB init quits and reboots the server mid-sequence
//   by detecting the reboot, waiting for it, and re-publishing the graph afterward.
//
// Style:
//   - tilde vars only
//   - var-first in every block
//   - lowercase names
//   - no server.sync
//   - server ops inside Server.default.bind
//   - GUI via AppClock (single window named “MagicDisplayGUI…”)

(
var log, s, numChConst,
    closeGuiWindows, freshBoot, ensureMeterDefs, checkChainChannels,
    clearOldNdefs, buildAudio, makeGuiAndMpb,
    waitForServerDownThenUp, baselinePlayWithRetry, metersOn, verify,
    runSequence,waitOnMpbReady;

log = { arg msg; ("[START] " ++ msg).postln };
s   = Server.default;

// channel constant everywhere (respects your global default if set)
numChConst = (
    ~defaultNumChannels.isKindOf(Integer) and: { ~defaultNumChannels > 0 }
).if({ ~defaultNumChannels }, { 2 });

// 1) Close any MagicDisplayGUI windows (singleton)
closeGuiWindows = {
    var wins;
    wins = Window.allWindows
        .select({ arg w; (w.name ? "").asString.beginsWith("MagicDisplayGUI") });
    wins.do(_.close);
    log.("closed any existing MagicDisplayGUI windows");
};

// 2) Force a FRESH server (quit if running, then boot), then clean the tree
freshBoot = {
    var t0, timeout, keepWait;
    timeout = 5.0;

    if(s.serverRunning) {
        log.("server running → quitting for clean boot");
        s.quit;
        t0 = Main.elapsedTime;
        keepWait = true;
        while({ s.serverRunning and: { keepWait } }, {
            0.05.wait;
            if((Main.elapsedTime - t0) > timeout) {
                "[WARN] timeout waiting for server to quit".postln;
                keepWait = false;
            };
        });
    };

    log.("booting server…");
    s.boot;
    s.waitForBoot;

    Server.default.bind({
        s.initTree;
        s.defaultGroup.freeAll;
    });
    log.("tree inited + default group cleared");
};

// 3) Ensure meter SynthDefs exist (compile-time channel count; mono mix inside)
ensureMeterDefs = {
    var needA, needB, n;
    n = numChConst;
    needA = SynthDescLib.global.at(\busMeterA).isNil;
    needB = SynthDescLib.global.at(\busMeterB).isNil;

    if(needA or: { needB }) {
        ("[START] (re)defining meter synths with numChConst=" ++ n).postln;

        Server.default.bind({
            SynthDef(\busMeterA, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                useBus = Select.kr(bus >= 0, [in, bus]);  // prefer \bus if set; else \in
                sig    = In.ar(useBus, n);                // compile-time literal
                mono   = Mix(sig);                        // stable single-channel level
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterA", [rms, peak]);
            }).add;

            SynthDef(\busMeterB, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                useBus = Select.kr(bus >= 0, [in, bus]);
                sig    = In.ar(useBus, n);
                mono   = Mix(sig);
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterB", [rms, peak]);
            }).add;
        });
    };
};

// 4) Optional: print A/B channel counts if chains already exist
checkChainChannels = {
    var a, b;
    a = Ndef(\chainA).tryPerform(\numChannels);
    b = Ndef(\chainB).tryPerform(\numChannels);
    if(a.notNil or: { b.notNil }) {
        "[CHECK] Ndef chain channels → A:% , B:%".format(a, b).postln;
    };
};

// 5) Clear any previous proxies to avoid channel wrapping warnings
clearOldNdefs = {
    Server.default.bind({
        if(Ndef(\chainA).notNil) { Ndef(\chainA).clear(0) };
        if(Ndef(\chainB).notNil) { Ndef(\chainB).clear(0) };
        if(Ndef(\ts0).notNil)    { Ndef(\ts0).clear(0) };
        if(Ndef(\testmelody).notNil) { Ndef(\testmelody).clear(0) };
    });
};


// 6) Build sinks and sources (server ops)
buildAudio = {
    Server.default.bind({
        // Sinks: read \in.ar(defaultNumChannels)
        Ndef(\chainA, { \in.ar(numChConst) }); Ndef(\chainA).ar(numChConst);
        Ndef(\chainB, { \in.ar(numChConst) }); Ndef(\chainB).ar(numChConst);

        // Sources: NEXT-safe silent + generated test melody
        Ndef(\ts0, { Silent.ar(numChConst) }); Ndef(\ts0).ar(numChConst);

        Ndef(\testmelody, {
            var trig, seq, f, env, tone, pan;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(numChConst);
    });
    log.("sinks + sources defined");
};

// 7) Create GUI + MPB (meters OFF initially). (We call this inside AppClock Routine)
makeGuiAndMpb = {
    ~gui = MagicDisplayGUI.new;
    ~mpb = MagicPedalboardNew.new(~gui);
    if(~gui.respondsTo(\enableMeters)) { ~gui.enableMeters(false) };
    if(~pedalboard.isNil and: { ~mpb.notNil }) { ~pedalboard = ~mpb };
    log.("GUI + MPB created (meters off)");
};

// 8) Detect a **server restart** after MPB creation; wait for it and re-publish graph
waitForServerDownThenUp = {
    var sawDown, t0, timeout, bootKickSent, stableCount, stableNeeded;
    sawDown = false;
    t0 = Main.elapsedTime;
    timeout = 10.0;
    bootKickSent = false;
    stableCount = 0;
    stableNeeded = 5; // 5 * 0.2s = 1.0s of stable running

    // Observe the server for up to 10 seconds; if it goes down, wait until it comes back
    while({
        (Main.elapsedTime - t0) < timeout and: { stableCount < stableNeeded }
    }, {
        0.20.wait;

        if(s.serverRunning.not) {
            sawDown = true;
            stableCount = 0;

            // If it doesn't auto-boot within ~1s, kick a boot
            if((Main.elapsedTime - t0) > 1.0 and: { bootKickSent.not }) {
                "WARNING: server not running → booting server…".postln;
                s.boot;
                bootKickSent = true;
            };
        }{
            // server is running now
            stableCount = stableCount + 1;
        };
    });

    if(sawDown) {
        // If it was down during the window, make sure it's fully up
        if(s.serverRunning.not) {
            "WARNING: waiting for server to come up…".postln;
            s.boot;  // safe to call even if already booting
            s.waitForBoot;
        }{
            // give it a tiny settle and request notifications (optional but nice)
            0.20.wait;
            s.notify;
        };

        // Re-publish meter defs and audio graph after the reboot
        ensureMeterDefs.value;
        clearOldNdefs.value;
        buildAudio.value;

        // Give MPB a chance to rebuild its server tree if it does so lazily
        0.20.wait;
        if(~mpb.respondsTo(\rebuild)) { ~mpb.rebuild(\current) };
        0.20.wait;
    };
};


// 9) Baseline + robust play with retry (ensures MPB has built server groups)
baselinePlayWithRetry = {
    var attempts, ok;
    attempts = 0;
    ok = false;

    while({ (attempts < 4) and: { ok.not } }, {
        ~mpb.setSourceCurrent(\testmelody);
        ~mpb.playCurrent;
        ~mpb.enforceExclusiveCurrentOptionA(0.1);  // NEXT silenced at source (Option A)

        0.30.wait; // allow bundles to land
        ok = Ndef(\chainA).isPlaying;

        attempts = attempts + 1;
        if(ok) {
            log.("baseline set: CURRENT=\\testmelody (Option A)");
        }{
            ("[RETRY] playCurrent attempt % failed; retrying…".format(attempts)).postln;
            if(~mpb.respondsTo(\rebuild)) { ~mpb.rebuild(\current) };
            0.30.wait;
        };
    });

    if(ok.not) {
        "[WARN] playCurrent did not report Ndef(\\chainA).isPlaying=true after retries".postln;
    };
};

// 10) Meters ON (ensure defs just-in-time)
metersOn = {
    ensureMeterDefs.value; // idempotent safety
    if(~gui.respondsTo(\enableMeters)) { ~gui.enableMeters(true) };
    log.("meters enabled");
};

// 11) Verify final state
verify = {
    ~mpb.printChains;
    ("[PLAY] A=% B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    checkChainChannels.value;
};

// 11b) Wait for MPB "ready" and then do meters + verify (no fixed sleeps)
waitOnMpbReady = {
    var onReady;  // var-first in outer function

    onReady = {
        var a, b;  // var-first in inner function/closure

        // meters on only when sinks are AR and CURRENT is playing
        if(~gui.respondsTo(\enableMeters)) { ~gui.enableMeters(true) };

        ~mpb.printChains;

        ("[PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

        // channel sanity print
        a = Ndef(\chainA).tryPerform(\numChannels);
        b = Ndef(\chainB).tryPerform(\numChannels);
        ("[CHECK] Ndef chain channels → A:% , B:%".format(a, b)).postln;
    };

    // use the new class helper; no sleeps here
    ~mpb.waitUntilReady(2.5, 0.05, onReady);
};


// --- Execute clean sequence in one AppClock Routine --------------------------
runSequence = {
    var waitPreGUI, waitAfterMPB;
    waitPreGUI  = 0.05; // small settle between bundles
    waitAfterMPB = 0.15; // short window for GUI-created side effects

    Routine({
        // 0) Hygiene
        closeGuiWindows.value;

        // 1) Fresh boot + clean tree
        freshBoot.value;

        // 2) Predefine meter SynthDefs post-boot (safe re-add)
        // ensureMeterDefs.value;
		MagicDisplay.setMeterChannels(numChConst);

        // 3) Start clean, then build audio graph
        clearOldNdefs.value;
        buildAudio.value;

        // 4) Create GUI + MPB (this may quit the server in its init)
        waitPreGUI.wait;
        makeGuiAndMpb.value;

        // 5) Watch for server going down and coming back; then re-publish defs/graph
        waitAfterMPB.wait;    // allow immediate /quit to show up
        waitForServerDownThenUp.value;
// 6) Baseline + robust play (kept, since it launches CURRENT deterministically)
baselinePlayWithRetry.value;
// 7–8) Wait on a real MPB condition, then meters + verify (no fixed sleeps)
waitOnMpbReady.value;

    }).play(AppClock);
};

// Kick off the sequence
runSequence.value;
)
// StartHere_Milestone_BringUpAndRun.scd
// v0.1.5b
// MD 20250918-18:36 BST

/*
Purpose
- Clean, deterministic bring-up (fresh boot) + today's CommandTree-mimic milestone playlist.
- Simpler, robust boot sequencing: poll 'serverRunning'/'booting' (no doWhenBooted), so it proceeds
  even if the server is already booting. Extra step logs to confirm progression.

Style
- tilde vars at top-level; var-first in every function/closure; lowercase method names; no server.sync;
- server ops inside Server.default.bind; GUI ops on AppClock; JITLib operator exactly "<<>";
- generated audio only (no SoundIn); sinks/processors read from \in.ar(2).
*/

(
var log, step, pollUntil, freshBoot, makeGui, makeMpb, ensureSources;
var settleBeforeMeters, loadAdapterRobust, installInlineAdapter;
var waitOnMpbReadyThen, enableMetersAfterReady, runMilestone, runAll;
var gapSeconds, meterDelaySec;

// ---------- capture this script's directory once (for absolute loads) ----------
~scriptDir = ~scriptDir ?? {
    var pathString, dirString;
    pathString = thisProcess.nowExecutingPath;
    dirString = if(pathString.notNil) { PathName(pathString).pathOnly } { thisProcess.cwd };
    dirString
};
("[DEBUG] scriptDir=" ++ ~scriptDir).postln;

// ---------- small logger ----------
log = { arg messageString;
    var lineText;
    lineText = "[RUN] " ++ messageString;
    lineText.postln;
};

// terse step tagger
step = { arg tag; ("[STEP] " ++ tag).postln };

// ---------- generic AppClock poll (no server.sync) ----------
pollUntil = { arg conditionFunc, everySeconds = 0.05, onOkFunc;
    var tickFunc, secondsLocal, condFuncLocal, onOkLocal;
    condFuncLocal = conditionFunc;
    secondsLocal = everySeconds ? 0.05;
    onOkLocal = onOkFunc ? { nil };
    tickFunc = {
        var okNow;
        okNow = condFuncLocal.value;
        if(okNow) { onOkLocal.value; nil } { AppClock.sched(secondsLocal, tickFunc) }
    };
    AppClock.sched(0, tickFunc);
};

// ---------- reset globals before start ----------
~gui = nil;
~mpb = nil;

// ---------- 0) Fresh boot (polling): quit -> wait down -> boot -> wait up -> initTree ----------
freshBoot = {
    var serverRef, waitDown, waitUp, doInitTree;
    serverRef = Server.default;

    doInitTree = {
        var ignore;
        ignore = nil;
        Server.default.bind({
            serverRef.initTree;
            serverRef.defaultGroup.freeAll;
        });
        MagicDisplay.setMeterChannels(2); // compile-time meter defs to 2ch
        log.("server tree inited; meter defs set to 2ch");
    };

    waitUp = {
        var cond;
        cond = { serverRef.serverRunning };
        pollUntil.value(cond, 0.05, {
            doInitTree.value;
        });
    };

    waitDown = {
        var cond;
        cond = { serverRef.serverRunning.not and: { serverRef.booting.not } };
        pollUntil.value(cond, 0.05, {
            log.("fresh boot: starting server…");
            serverRef.boot;
            waitUp.value;
        });
    };

    if(serverRef.serverRunning or: { serverRef.booting }) {
        log.("fresh boot: quitting current server…");
        serverRef.quit;
        // give the server a moment to start going down, then poll until fully down
        AppClock.sched(0.05, { waitDown.value; nil });
    }{
        log.("fresh boot: starting server…");
        serverRef.boot;
        waitUp.value;
    };
};

// ---------- 1) GUI: close old MagicDisplayGUI and create a fresh one ----------
makeGui = {
    var closeOldFunc;
    closeOldFunc = {
        var windowsList;
        windowsList = Window.allWindows.select({ arg w;
            var nameString, isMagic;
            nameString = w.tryPerform(\name);
            isMagic = nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") };
            isMagic
        });
        windowsList.do({ arg w; w.close });
        log.("closed any existing MagicDisplayGUI windows");
    };
    AppClock.sched(0, {
        closeOldFunc.value;
        ~gui = MagicDisplayGUI.new;
        nil
    });
};

// ---------- 2) MPB: create AFTER GUI exists ----------
makeMpb = {
    pollUntil.value({ ~gui.notNil }, 0.05, {
        AppClock.sched(0, {
            ~mpb = MagicPedalboardNew.new(~gui);
            log.("MagicPedalboardNew created");
            nil
        });
    });
};

// ---------- 3) Sources (generated only) ----------
ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, freqSig, envAmp, panPos, outSig;
                trig    = Impulse.kr(3.2);
                seq     = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freqSig = Demand.kr(trig, 0, seq);
                envAmp  = Decay2.kr(trig, 0.01, 0.35);
                panPos  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                outSig  = Pan2.ar(SinOsc.ar(freqSig) * envAmp * 0.25, panPos);
                outSig
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) });
        Ndef(\ts0).ar(2);
    });
    log.("sources ensured (\\testmelody stereo; \\ts0 silent stereo)");
};

// ---------- 4) Settle BEFORE meters: Option A + pin sinks (NO setSourcesBoth here) ----------
settleBeforeMeters = {
    pollUntil.value({ ~mpb.notNil }, 0.05, {
        ~mpb.playCurrent;                         // deterministic CURRENT audible
        ~mpb.enforceExclusiveCurrentOptionA(0.1); // NEXT silent at source

        Server.default.bind({
            Ndef(\chainA).mold(2, \audio);
            Ndef(\chainB).mold(2, \audio);
        });

        ~mpb.printChains;
        ("[PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    });
};

// ---------- 5) Adapter: absolute-load robustly; fallback to inline mini-adapter ----------
installInlineAdapter = {
    if(~ct_applyOSCPathToMPB.isNil) {
        ~ct_applyOSCPathToMPB = { arg pathString, mpb, gui;
            var tokens, normalized, verbLower, argsList, onOffStr, procSym, idxA, idxB, lastTail;
            tokens = pathString.asString.split($/).reject({ arg t; t.isEmpty }).collect(_.asString);
            normalized = if(tokens.size > 0 and: { tokens[0] == "commands" }) { tokens.copyRange(1, tokens.size - 1) } { tokens };
            verbLower = (normalized.size > 0).if({ normalized[0].toLower }, { "" });
            argsList  = (normalized.size > 1).if({ normalized.copyRange(1, normalized.size - 1) }, { [] });

            switch(verbLower,
                "add",      { if(argsList.size >= 1) { procSym = argsList[0].asSymbol; mpb.add(procSym) } },
                "bypass",   {
                    if(argsList.size >= 2) {
                        procSym  = argsList[0].asSymbol;
                        onOffStr = argsList[1].toLower;
                        onOffStr = (["on","off","true","false","1","0"].includes(onOffStr)).if({
                            if((onOffStr=="true") or: { onOffStr=="1" }) { "on" } { onOffStr }
                        }, { "on" });
                        mpb.bypass(procSym, onOffStr=="on");
                    };
                },
                "removeat", { if(argsList.size >= 1) { mpb.removeAt(argsList[0].asInteger) } },
                "swap",     { if(argsList.size >= 2) { idxA=argsList[0].asInteger; idxB=argsList[1].asInteger; mpb.swap(idxA, idxB) } },
                "setsource",{ if(argsList.size >= 1) { mpb.setSource(argsList[0].asSymbol) } },
                "switch",   {
                    lastTail = mpb.effectiveNext.last;
                    if(lastTail == \ts0) { mpb.setSource(\testmelody) }; // guard
                    mpb.switchChain(0.12);
                },
                { /* ignore unknown */ }
            );
        };
        log.("inline mini-adapter installed (fallback)");
    };
};

loadAdapterRobust = {
    var adapterFileLower, adapterFileCamel, existsLower, existsCamel;
    if(~ct_applyOSCPathToMPB.notNil) {
        log.("adapter already present");
        ^this;
    };
    adapterFileLower = (~scriptDir +/+ "adapter_commandtree_to_magicpedalboard.scd").standardizePath;
    adapterFileCamel = (~scriptDir +/+ "adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
    existsLower = File.exists(adapterFileLower);
    existsCamel = File.exists(adapterFileCamel);

    if(existsLower) {
        adapterFileLower.load; log.("adapter loaded: " ++ adapterFileLower);
    }{
        if(existsCamel) {
            adapterFileCamel.load; log.("adapter loaded: " ++ adapterFileCamel);
        }{
            log.("adapter file not found near script; installing fallback");
            installInlineAdapter.value;
        };
    };
};

// ---------- 6) Readiness gate only after ~mpb exists ----------
waitOnMpbReadyThen = { arg onReadyFunc;
    var onOkLocal;
    onOkLocal = onReadyFunc ? { nil };
    pollUntil.value({ ~mpb.notNil }, 0.05, {
        ~mpb.waitUntilReady(2.5, 0.05, {
            ("[PLAY] A=% B=%"
                .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
            onOkLocal.value;
        });
    });
};

// ---------- 7) Re-enforce Option A and enable meters AFTER readiness (with a short delay) ----------
enableMetersAfterReady = {
    var postDelay;
    postDelay = meterDelaySec ? 0.25; // small settle delay

    AppClock.sched(postDelay, {
        ~mpb.enforceExclusiveCurrentOptionA(0.1); // re-check exclusivity before meters

        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
            ~gui.enableMeters(false);
            ~gui.enableMeters(true);
            log.("meters enabled after readiness");
        };
        ("[CHECK] Ndef chain channels -> A:% , B:%"
            .format(Ndef(\chainA).tryPerform(\numChannels), Ndef(\chainB).tryPerform(\numChannels))).postln;
        nil
    });
};

// ---------- 8) Milestone playlist (single prime sets sources) ----------
runMilestone = {
    var gapLocal, applyPathFunc, primeFunc, playlistArray, stepIndex, stepCount, stepFunc;
    gapLocal = 0.60;

    applyPathFunc = { arg pathString;
        var lineText;
        lineText = "[TOKENS] apply -> " ++ pathString;
        lineText.postln;
        ~ct_applyOSCPathToMPB.(pathString, ~mpb, ~gui);
    };

    primeFunc = {
        ~mpb.setSourcesBoth(\testmelody);     // single place we set both tails today
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        ~mpb.printChains;
        ("[PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    };

    playlistArray = [
        "/add/delay",
        "/switch",
        "/bypass/delay/on",
        "/bypass/delay/off",
        "/switch"
    ];
    stepIndex = 0;
    stepCount = playlistArray.size;

    stepFunc = {
        var doneNow;
        doneNow = (stepIndex >= stepCount);
        if(doneNow) {
            AppClock.sched(0.9, {
                ("[PLAY] A=% B=%"
                    .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
                ~mpb.printChains;
                nil
            });
            ^nil
        };
        applyPathFunc.value(playlistArray[stepIndex]);
        stepIndex = stepIndex + 1;
        AppClock.sched(gapLocal, stepFunc);
    };

    primeFunc.value;
    AppClock.sched(gapLocal, stepFunc);
};

// ---------- 9) Orchestrate strictly in order ----------
runAll = {
    var proceedAfterBoot;
    proceedAfterBoot = {
        makeGui.value;           step.("GUI");
        makeMpb.value;           step.("MPB create");
        ensureSources.value;     step.("sources");
        settleBeforeMeters.value;step.("settle-before-meters");
        loadAdapterRobust.value; step.("adapter");
        waitOnMpbReadyThen.value({
            enableMetersAfterReady.value; step.("meters");
            runMilestone.value;          step.("playlist");
        });
    };
    log.("orchestration start");
    freshBoot.value;             step.("boot-in-progress");
    // Continue once server is really running and tree initialized
    pollUntil.value({ Server.default.serverRunning }, 0.05, {
        // a tiny guard in case initTree hasn't run yet
        AppClock.sched(0.10, { proceedAfterBoot.value; nil });
    });
};

gapSeconds    = 0.60;
meterDelaySec = 0.25;

// fire
runAll.value;
)
// Strict_Reset_To_Exclusive_Audible.scd
// v0.1
// MD 20250917-1145
//
// Purpose: Deterministic recovery: disable meters, hard-reset MPB to A=current/B=next,
// define stereo ts0 (Silent) and testmelody, enforce Option A, re-enable meters,
// verify A XOR B is true.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, disableMeters, defineStereoTs0, defineTestMelody, doReset, enforceExclusive, enableMeters, verify;

log = { arg s; ("[STRICT] " ++ s).postln };

disableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        AppClock.sched(0.0, { ~gui.enableMeters(false); nil });
        AppClock.sched(0.05, { ~gui.enableMeters(false); nil });
        log.("meters disabled");
    };
};

defineStereoTs0 = {
    Server.default.bind({
        Ndef(\ts0, { Silent.ar(2) });  // NEXT-safe, stereo
        Ndef(\ts0).ar(2);
    });
    log.("\\ts0 set to stereo Silent");
};

defineTestMelody = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(3.2);
            var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            var f    = Demand.kr(trig, 0, seq);
            var env  = Decay2.kr(trig, 0.01, 0.35);
            var tone = SinOsc.ar(f) * env * 0.25;
            var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
    log.("\\testmelody ensured (stereo)");
};

doReset = {
    // Reset reinitialises chainA/B lists and calls the class logic that enforces exclusivity at end.
    ~mpb.reset;
    log.("mpb.reset done");
};

enforceExclusive = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;                        // MPB already enforces Option A post-play
    ~mpb.enforceExclusiveCurrentOptionA(0.1); // belt-and-braces
    log.("Option A exclusivity asserted");
};

enableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(true);             // guards for AR buses and re-sends SynthDefs
        log.("meters re-enabled");
    };
};

verify = {
    AppClock.sched(0.30, {
        var a = Ndef(\chainA).isPlaying;
        var b = Ndef(\chainB).isPlaying;
        ("[STRICT] [PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

disableMeters.value;
defineStereoTs0.value;
defineTestMelody.value;
doReset.value;
enforceExclusive.value;
enableMeters.value;
verify.value;
)
// Switch_VerifyCurrentAudible_OptionA.scd
// v0.1
// MD 20250917-1320
//
// Purpose: After switching, ensure CURRENT sink is audibly playing and NEXT is ended,
//          without altering any sink sources. Non-intrusive.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, enforce;

log = { arg s; ("[SWCHK] " ++ s).postln };

enforce = {
    var cur = ~mpb.currentChain[0], nxt = ~mpb.nextChain[0];
    Server.default.bind({
        // Make CURRENT audible
        Ndef(cur).mold(2, \audio);
        if(Ndef(cur).isPlaying.not) { Ndef(cur).play(numChannels: 2) };

        // Make NEXT cleanly inactive (flag false), keep stereo shape
        Ndef(nxt).end;
        Ndef(nxt).mold(2, \audio);
    });
    AppClock.sched(0.25, {
        var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
        ("[SWCHK] [PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

enforce.value;
)
// switchDelayCheck.scd
// v0.1
// MD 20250916

(
// Goal: add \delay to NEXT, switch with a crossfade, and confirm audio continues on CURRENT.

// --- Preconditions: GUI + MPB exist; audibleSanity.scd already run today. ---

var log, cleanupDirectPlays, prepStatus, addDelayToNext, doSwitch, afterSwitchCheck, recoverIfSilent;

log = { arg m; ("[switchDelay] " ++ m).postln };

cleanupDirectPlays = {
    // ensure no direct-to-out play is active for the generator
    if(Ndef(\testmelody).isPlaying) { Ndef(\testmelody).stop; log.("stopped direct \\testmelody") };
};

prepStatus = {
    ~mpb.printChains;
    ("[before] A=%  B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
};

addDelayToNext = {
    ~mpb.clearChain;            // keep NEXT minimal before adding
    ~mpb.add(\delay);           // add to NEXT
    ~mpb.printChains;
};

doSwitch = {
    ~mpb.switchChain(0.12);     // short crossfade; CURRENT <-> NEXT
};

afterSwitchCheck = {
    AppClock.sched(0.35, {
        ~mpb.printChains;
        ("[after]  A=%  B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

// If for any reason we went silent, rebuild connections & enforce CURRENT-only play.
// (Equivalent to your enforceExclusiveCurrentNow utilities)
recoverIfSilent = {
    AppClock.sched(0.60, {
        var curEff, curSink;
        curEff = ~mpb.effectiveCurrent;
        curSink = curEff[0];
        Server.default.bind({
            ~mpb.rebuildUnbound(~mpb.currentChain);
            ~mpb.rebuildUnbound(~mpb.nextChain);
            // enforce exclusive current
            if(curSink == \chainA) {
                if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
                if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
            }{
                if(Ndef(\chainA).isPlaying) { Ndef(\chainA).stop };
                if(Ndef(\chainB).isPlaying.not) { Ndef(\chainB).play(numChannels: 2) };
            };
        });
        log.("reconnect enforced, currentEff=" ++ curEff);
        nil
    });
};

// --- run steps ---
cleanupDirectPlays.value;
prepStatus.value;
addDelayToNext.value;
doSwitch.value;
afterSwitchCheck.value;
recoverIfSilent.value;
)
// Test_CommandTree_To_AudioBridge.scd
// v0.6.2
// MD 20250919-09:16 BST

/*
Purpose
- Bridge Command Tree -> Audio + GUI:
  - Simulate 3–5–7 → \queue → \send (demo).
  - Map OSC tokens (strings; hyphen-safe) to NEXT (B) effect.
  - Ignore trivial paths like "/audio".
  - Passive observer watches ~commandToSend for real SENDs.

Style
- var-first; AppClock-only; no server.sync.
*/

(
var ensureDeps, buildEffectMap, simulatePath_3_5_7, queueAndSend, reflectOsc, startObserver;

ensureDeps = {
    var run;
    run = {
        if(~fx.isNil or: { ~applyToNext.isNil }) {
            "[ERROR] Audio helpers not found. Run Test_MagicAudio_BringUp_A_B.scd first.".warn;
        };
        ~ct = ~ct ?? { CommandManager.new };
        if(~ct.display.notNil and: { ~ct.display.window.notNil }) { ~ct.display.window.front };
        if(~gui.isNil) { "[WARN] ~gui not present (GUI optional). Proceeding…".postln };
        "[CT] CommandManager ready".postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

buildEffectMap = {
    var run;
    run = {
        ~ctFxMapS = IdentityDictionary[
            "single-delay" -> \delay,
            "delay"        -> \delay,
            "echo"         -> \delay,
            "freeverb"     -> \reverb,
            "reverb"       -> \reverb,
            "chorus"       -> \chorus,
            "tremolo"      -> \tremolo,
            "flanger"      -> \flanger
        ];
        "[CT] Effect token map (string-keyed) installed".postln;
        nil
    };
    AppClock.sched(0.02, { run.value; nil });
};

reflectOsc = { arg pathStr;
    var run;
    run = {
        var tokens, effTok, effSym, hasMeaning;
        var current, next, effC, effN, bA, bB;

        tokens = pathStr.asString.split($/).reject(_.isEmpty);
        hasMeaning = (tokens.size >= 2); // ignore "/audio" or similar one-token paths
        if(hasMeaning.not) {
            ("[CT] Ignoring trivial path: " ++ pathStr).postln;
        }{
            effTok = tokens.reverse.detect({ arg t; ~ctFxMapS.includesKey(t.asString) });
            effSym = (effTok.isNil).if({ \delay }, { ~ctFxMapS[effTok.asString] });

            ~applyToNext.(effSym);

            if(~gui.notNil) {
                ~gui.showExpectation("CT SEND → " ++ pathStr, 0);
                current = [\chainA, \testmelody];
                next    = [\chainB, effSym, \testmelody];
                effC = current; effN = next; bA=[]; bB=[];
                ~gui.showChainsDetailed(current, next, bA, bB, effC, effN);
            };
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

simulatePath_3_5_7 = {
    var run;
    run = {
        var mm, gh;
        mm = ~ct.midiManager; gh = mm.guitarHandler;

        mm.setMode(mm.modes[\prog]); // resets nav, starts at string 6
        gh.handleMessage(0, \noteOn, 43); 0.12.wait; // fret 3 on string 6
        gh.handleMessage(1, \noteOn, 50); 0.12.wait; // fret 5 on string 5
        gh.handleMessage(2, \noteOn, 57); 0.08.wait; // fret 7 on string 4

        if(~gui.notNil) { ~gui.showExpectation("CT PROG: 3–5–7 reached. Queue when ready.", 0) };
        nil
    };
    Routine({ run.value }).play(AppClock);
};

queueAndSend = {
    var run;
    run = {
        var mm, path;
        mm = ~ct.midiManager;
        mm.setMode(mm.modes[\queue]); 0.08.wait;
        mm.setMode(mm.modes[\send]);  0.08.wait;

        path = ~ct.midiManager.queue.exportAsOSCPath;
        ("[CT] OSC path exported: " ++ path).postln;
        reflectOsc.value(path);

        "[CT] Applied effect to NEXT; call ~switchNow.() to promote".postln;
        nil
    };
    Routine({ run.value }).play(AppClock);
};

startObserver = {
    var run;
    run = {
        var lastSeen;
        lastSeen = "";
        if(~ctObserver.notNil) { AppClock.clear(~ctObserver); ~ctObserver = nil };
        ~ctObserver = AppClock.sched(0.20, {
            var currentStr, tokens, hasMeaning;
            currentStr = (~commandToSend ? "").asString;
            if(currentStr.size > 0 and: { currentStr != lastSeen }) {
                tokens = currentStr.split($/).reject(_.isEmpty);
                hasMeaning = (tokens.size >= 2);
                if(hasMeaning) {
                    ("[CT OBS] detected SEND: " ++ currentStr).postln;
                    reflectOsc.value(currentStr);
                }{
                    ("[CT OBS] ignoring trivial path: " ++ currentStr).postln;
                };
                lastSeen = currentStr;
            };
            0.20  // reschedule
        });
        "[CT] Observer started (listening to ~commandToSend)".postln;
        nil
    };
    AppClock.sched(0.10, { run.value; nil });
};

// ---- run sequence ----
ensureDeps.value;
buildEffectMap.value;

// Demo pass (comment out if using real controller later)
AppClock.sched(0.25, { simulatePath_3_5_7.value; nil });
AppClock.sched(1.10, { queueAndSend.value; nil });

// Passive observer for real SENDs
startObserver.value;
)
// test_editor_commandtree_add_demo_verbs_part_a.scd
// v0.1
// MD 20250916-0919

(
var jsonPath, loadOk, tree, getNodeByPath, assert, expectPath, pathsToCheck, passCount, failCount, countAfter, summary;

jsonPath = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
passCount = 0;
failCount = 0;

assert = { arg condition, label;
    var statusText;
    statusText = if(condition) { "PASS" } { "FAIL" };
    ("[TEST] " ++ statusText ++ " — " ++ label).postln;
    if(condition) { passCount = passCount + 1 } { failCount = failCount + 1 };
};

getNodeByPath = { arg treeRef, nameList;
    var foundNode;
    foundNode = treeRef.getNodeByNamePath(nameList);
    foundNode
};

expectPath = { arg treeRef, nameList;
    var nodeRef, lastName, hasNode, payloadMatches;
    nodeRef = getNodeByPath.(treeRef, nameList);
    lastName = nameList.last;
    hasNode = nodeRef.notNil;
    assert.(hasNode, "exists: " ++ nameList.join(" → "));
    if(hasNode) {
        payloadMatches = (nodeRef.payload == lastName);
        assert.(payloadMatches, "payload==name for: " ++ nameList.join(" → "));
    };
};

// 1) Load tree
tree = MDCommandTree.new;
loadOk = tree.importJSONFile(jsonPath);
assert.(loadOk, "JSON loaded from " ++ jsonPath);

// 2) Expected paths created by the editor script
pathsToCheck = [
    ["commands"],
    ["commands","add","delay"],
    ["commands","add","chorus"],
    ["commands","add","reverb"],
    ["commands","add","tremolo"],
    ["commands","bypass","delay","on"],
    ["commands","bypass","delay","off"],
    ["commands","switch"],
    ["commands","setSource","testmelody"]
];

// 3) Check each path exists and payload==name
pathsToCheck.do({ arg nameList; expectPath.(tree, nameList) });

// 4) Record node map size (for idempotency comparison later)
countAfter = tree.nodeMap.size;
~ct_nodecount_after_first = countAfter;  // store globally for Part B
("[TEST] nodeMap.size after first run = " ++ countAfter).postln;

// 5) Summary
summary = "[TEST] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount;
summary.postln;
)
// test_editor_commandtree_add_demo_verbs_part_b.scd
// v0.1
// MD 20250916-0920

(
var jsonPath, loadOk, tree, countBefore, countAfter, assert, summary, passCount, failCount;

jsonPath = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
passCount = 0; failCount = 0;

assert = { arg condition, label;
    var statusText;
    statusText = if(condition) { "PASS" } { "FAIL" };
    ("[TEST] " ++ statusText ++ " — " ++ label).postln;
    if(condition) { passCount = passCount + 1 } { failCount = failCount + 1 };
};

// 0) Precondition: you just re-ran editor_commandtree_add_demo_verbs.scd
// 1) Reload tree
tree = MDCommandTree.new;
loadOk = tree.importJSONFile(jsonPath);
assert.(loadOk, "JSON reloaded");

// 2) Compare node counts
countBefore = ~ct_nodecount_after_first ? -1;
countAfter  = tree.nodeMap.size;

("[TEST] nodeMap.size first=" ++ countBefore ++ " second=" ++ countAfter).postln;

// Expectation: no new nodes created on second run (idempotent)
assert.(countBefore == countAfter, "idempotent: nodeMap size unchanged after second run");

// 3) Summary
summary = "[TEST] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount;
summary.postln;
)
// Test_MagicAudio_BringUp_A_B.scd
// v0.9.3
// MD 20250919-09:16 BST

/*
Purpose
- Robust audio bring-up (no SoundIn), Option A for NEXT:
  - Atomic build into a dedicated root group (~mpRoot).
  - A audible; B muted at source until switch.
  - FX via Ndef(\chainX).filter dictionary.
  - Helpers: ~applyToNext, ~clearNext, ~switchNow, ~audioReset.

Style
- var-first; lowercase; AppClock-only; no server.sync.
*/

(
var boot, installFxDict, buildOnce, installHelpers, announce;
var s;

boot = {
    var run;
    run = {
        s = Server.default;
        s.waitForBoot({
            Server.default.bind({
                s.initTree;
                s.defaultGroup.freeAll;
            });
            ("[AUDIO] server booted: " ++ s.addr).postln;
        });
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

installFxDict = {
    var run;
    run = {
        ~fx = IdentityDictionary[
            \delay -> { arg in, time=0.35, decay=2.0, max=1.0;
                time = time.clip(0.005, max);
                CombC.ar(in, max, time, decay)
            },
            \reverb -> { arg in, mix=0.20, room=0.60, damp=0.50;
                FreeVerb.ar(in, mix.clip(0,1), room.clip(0,1), damp.clip(0,1))
            },
            \chorus -> { arg in, depth=0.003, rate=0.25;
                var mod;
                mod = SinOsc.kr(rate).range(depth * -1, depth);
                DelayC.ar(in, depth*2 + 0.01, mod + depth + 0.005)
            },
            \tremolo -> { arg in, rate=5, depth=0.6;
                var lfo;
                lfo = LFTri.kr(rate).range(1-depth, 1);
                in * lfo
            }
        ];
        "[FX] dictionary installed (\\delay, \\reverb, \\chorus, \\tremolo)".postln;
        nil
    };
    AppClock.sched(0.02, { run.value; nil });
};

buildOnce = {
    var run;
    run = {
        var lat, atomBuild, stopClear;
        lat = s.latency ? 0.2;

        atomBuild = {
            // stop/clear any prior proxies quietly
            stopClear = { arg name;
                var p = Ndef(name);
                if(p.isPlaying) { p.stop };
                p.clear;
            };
            [\out, \mix, \chainA, \chainB, \srcA, \srcB].do(stopClear);

            // new root group
            if(~mpRoot.notNil) { try { ~mpRoot.free } };
            ~mpRoot = Group.head(s);

            // sources
            Ndef(\srcA).fadeTime = 0.02;
            Ndef(\srcA).source = { arg amp=0.20;
                var t, seq, freq, sig;
                t   = Impulse.kr(2);
                seq = Demand.kr(t, 0, Dseq([220, 277, 247, 294, 330, 262], inf));
                freq= Lag.kr(seq, 0.02);
                sig = Mix.new(VarSaw.ar(freq * [1, 0.501], 0, 0.4)) * 0.35;
                sig = LPF.ar(sig, 6000);
                Pan2.ar(sig, 0) * amp;
            };

            Ndef(\srcB).fadeTime = 0.02;
            Ndef(\srcB).source = { arg amp=0.20, muted=1;
                var t, seq, freq, sig;
                t   = Impulse.kr(2);
                seq = Demand.kr(t, 0, Dseq([196, 233, 262, 220, 294, 247], inf));
                freq= Lag.kr(seq, 0.02);
                sig = Mix.new(VarSaw.ar(freq * [1, 0.503], 0, 0.4)) * 0.35;
                sig = LPF.ar(sig, 5400);
                sig = Pan2.ar(sig, 0) * amp;
                Select.ar(muted.clip(0,1), [sig, Silent.ar(2)])
            };

            // chains
            Ndef(\chainA).fadeTime = 0.02;
            Ndef(\chainA).source = { Ndef(\srcA).ar };

            Ndef(\chainB).fadeTime = 0.02;
            Ndef(\chainB).source = { Ndef(\srcB).ar };

            // mix and out
            Ndef(\mix).fadeTime = 0.02;
            Ndef(\mix).source = { Ndef(\chainA).ar + Ndef(\chainB).ar };

            Ndef(\out).fadeTime = 0.02;
            Ndef(\out).source = { Ndef(\mix).ar };

            // play out into our group (positional group arg #6)
            Ndef(\out).play(0, nil, ~mpRoot, 1.0, 1.0, 0.02, \addToHead);

            // initial params
            Ndef(\srcA).set(\amp, 0.20);
            Ndef(\srcB).set(\amp, 0.20, \muted, 1); // Option A
        };

        s.makeBundle(lat, atomBuild);
        AppClock.sched(lat + 0.05, { "[AUDIO] atomic graph built + out playing".postln; nil });
        nil
    };
    AppClock.sched(0.04, { run.value; nil });
};

installHelpers = {
    var run;
    run = {
        ~currentIsA = true;
        ~ampA = 0.20; ~ampB = 0.20;

        ~applyToNext = { arg fxSym, params = ( );
            var f;
            f = ~fx[fxSym];
            if(f.isNil) {
                ("[FX] unknown: " ++ fxSym).warn;
            }{
                Ndef(\chainB).filter(fxSym, f, params);
                "[FX] applied to NEXT: ".post; fxSym.postln;
            };
        };

        ~clearNext = {
            Ndef(\chainB).clear;
            Ndef(\chainB).source = { Ndef(\srcB).ar };
            "[FX] NEXT cleared".postln;
        };

        ~switchNow = {
            if(~currentIsA) {
                Ndef(\srcA).set(\amp, 0.0);
                Ndef(\srcB).set(\muted, 0, \amp, ~ampB);
                ~currentIsA = false;
                if(~gui.notNil) { ~gui.highlightCurrentColumn(\chainB) };
                "[SWITCH] B is now CURRENT".postln;
            }{
                Ndef(\srcB).set(\amp, 0.0, \muted, 1);
                Ndef(\srcA).set(\amp, ~ampA);
                ~currentIsA = true;
                if(~gui.notNil) { ~gui.highlightCurrentColumn(\chainA) };
                "[SWITCH] A is now CURRENT".postln;
            };
        };

        ~audioReset = {
            var lat, doReset;
            lat = s.latency ? 0.2;
            doReset = {
                [\out, \mix, \chainA, \chainB, \srcA, \srcB].do({ arg k;
                    var p = Ndef(k);
                    if(p.isPlaying) { p.stop };
                    p.clear;
                });
                if(~mpRoot.notNil) { try { ~mpRoot.free } };
            };
            s.makeBundle(lat, doReset);
            AppClock.sched(lat + 0.05, { buildOnce.value; nil });
            "[AUDIO] reset requested".postln;
        };

        // initial GUI hint
        if(~gui.notNil) { ~gui.highlightCurrentColumn(\chainA) };
        nil
    };
    AppClock.sched(0.10, { run.value; nil });
};

announce = {
    var run;
    run = {
        "[READY] Audio up. Helpers: ~applyToNext.(\\delay), ~clearNext.(), ~switchNow.(), ~audioReset.()".postln;
        nil
    };
    AppClock.sched(0.12, { run.value; nil });
};

boot.value;
installFxDict.value;
buildOnce.value;
installHelpers.value;
announce.value;
)
/*
 * Test_MagicDisplayGUI_AllInOne_Monolithic.scd v0.10
 * Single top-level block = no "unexpected '('" parse issue.
 *
 * Contents
 *  - Section A: Test_MagicDisplayGUI_BootAndScenarios.scd v0.4 (verbatim)
 *  - Section B: Test_MagicDisplayGUI_Scenarios.scd v0.5 (verbatim)
 *  - Section C: Test_MagicDisplayGUI_InlineInstrument.scd v0.2 (verbatim)
 *  - Section D: Resilient UI-queue patch + v6 aliases + one-button runner
 *
 * Style respected:
 *  - tilde vars, var-first in each block, lowercase names
 *  - no server.sync, explicit AppClock scheduling for UI work (.defer)
 */

(
// ======================================================================
// Section A — Test_MagicDisplayGUI_BootAndScenarios.scd v0.4 (verbatim)
// ======================================================================

// ---------- shared helpers ------------------------------------------------
~postState = { |labelString|
    var curr, nxt;
    curr = ~mpb.tryPerform(\currentChain);
    nxt = ~mpb.tryPerform(\nextChain);
    ("[STATE] " ++ labelString ++ " → current=" ++ curr.asString
        ++ "  next=" ++ nxt.asString).postln;
};

~drawOnce = {
    var curr, nxt, bypassA, bypassB, effA, effB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    curr = ~mpb.currentChain;
    nxt = ~mpb.nextChain;
    bypassA = ~mpb.bypassKeysCurrent;
    bypassB = ~mpb.bypassKeysNext;
    effA = ~mpb.effectiveCurrent;
    effB = ~mpb.effectiveNext;
    // GUI method that actually updates the lists/labels
    ~gui.showChainsDetailed(curr, nxt, bypassA, bypassB, effA, effB);
};

~refreshView = { |labelString|
    ~postState.(labelString);
    // Console view via MPB (also calls showChainsDetailed under the hood)
    ~mpb.printChains;
    // Explicit GUI redraw (belt-and-braces)
    ~drawOnce.();
};

// ---------- robust boot: wait for window, then first draw ----------------
~bootGuiV4 = {
    var guiObj, board, maxPollCount, pollDelaySeconds, routine;
    // stop any previous tasks
    ~mdgTask.notNil.if { ~mdgTask.stop; ~mdgTask = nil };
    ~bootTask.notNil.if { ~bootTask.stop; ~bootTask = nil };

    // create GUI and disable meters (avoid server dependency)
    guiObj = MagicDisplayGUI.new;
    guiObj.enableMeters(false);

    // create pedalboard and attach display
    board = MagicPedalboardNew(guiObj);
    ~gui = guiObj;
    ~mpb = board;

    // poll for the window (it is built asynchronously on AppClock)
    maxPollCount = 200; // up to ~10 seconds
    pollDelaySeconds = 0.05;
    routine = Routine {
        var pollCount;
        pollCount = 0;
        while({ (~gui.window.isNil) and: { pollCount < maxPollCount } }, {
            pollCount = pollCount + 1;
            pollDelaySeconds.wait; // SystemClock here; avoids AppClock contention
        });
        defer({
            if(~gui.window.notNil) {
                "Window ready — fronting and drawing columns.".postln;
                ~gui.window.front;
            }{
                "Window did not appear in time (10 s).".warn;
            };
            ~refreshView.("boot");
        });
    };
    ~bootTask = Task(routine, SystemClock).play; // use SystemClock for the polling loop
    "Booting GUI (meters disabled). Waiting for window…".postln;
};

// bring GUI to front later if needed
~frontGui = {
    if(~gui.notNil and: { ~gui.window.notNil }) { ~gui.window.front };
};

// stop any running scenario
~stopScenarios = {
    var runningTask;
    runningTask = ~mdgTask;
    if(runningTask.notNil) { runningTask.stop; ~mdgTask = nil; };
    "Stopped scenario task (if any).".postln;
};

// ---------- Scenarios (run on SystemClock, post step labels) -------------
~scenario1v4 = {
    var routine, waitSeconds, steps, totalSteps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitSeconds = 0.8;
    steps = [
        { "[SC1] init".postln; ~refreshView.("SC1/init") },
        { "[SC1] add flanger".postln;
          ~mpb.add(\flanger);
          ~refreshView.("SC1/add flanger") },
        { "[SC1] bypass flanger → true".postln;
          ~mpb.bypass(\flanger, true);
          ~refreshView.("SC1/bypass flanger true") },
        { "[SC1] add delay".postln;
          ~mpb.add(\delay);
          ~refreshView.("SC1/add delay") },
        { "[SC1] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC1/clear NEXT") }
    ];
    totalSteps = steps.size;
    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };
    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play; // SystemClock: robust in headless/server-off
    ~mdgTask
};

~scenario2v4 = {
    var routine, waitSeconds, steps, totalSteps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitSeconds = 0.25;
    steps = [
        { "[SC2] init".postln; ~refreshView.("SC2/init") },
        { "[SC2] add chorus".postln; ~mpb.add(\chorus); ~refreshView.("SC2/add chorus") },
        { "[SC2] add reverb".postln; ~mpb.add(\reverb); ~refreshView.("SC2/add reverb") },
        { "[SC2] add tremolo".postln; ~mpb.add(\tremolo); ~refreshView.("SC2/add tremolo") },
        { "[SC2] removeAt 2".postln; ~mpb.removeAt(2); ~refreshView.("SC2/removeAt 2") },
        { "[SC2] add phaser".postln; ~mpb.add(\phaser); ~refreshView.("SC2/add phaser") },
        { "[SC2] clear NEXT".postln; ~mpb.clearChain; ~refreshView.("SC2/clear NEXT") }
    ];
    totalSteps = steps.size;
    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };
    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};

~scenario3v4 = {
    var routine, waitSeconds, steps, totalSteps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitSeconds = 0.6;
    steps = [
        { "[SC3] init".postln; ~refreshView.("SC3/init") },
        { "[SC3] add bitcrusher".postln;
          ~mpb.add(\bitcrusher);
          ~refreshView.("SC3/add bitcrusher") },
        { "[SC3] bypass bitcrusher → false".postln;
          ~mpb.bypass(\bitcrusher, false);
          ~refreshView.("SC3/bypass bitcrusher false") },
        { "[SC3] removeAt 1 (if exists)".postln;
          ~mpb.removeAt(1);
          ~refreshView.("SC3/removeAt 1") },
        { "[SC3] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC3/clear NEXT") }
    ];
    totalSteps = steps.size;
    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };
    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};


// ======================================================================
// Section B — Test_MagicDisplayGUI_Scenarios.scd v0.5 (verbatim)
// ======================================================================

~log = { |msg| ("[SC] " ++ msg).postln };

~refreshGuiFromMpb = {
    var curr, nxt, bA, bB, eA, eB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    curr = ~mpb.currentChain; nxt = ~mpb.nextChain;
    bA = ~mpb.bypassKeysCurrent; bB = ~mpb.bypassKeysNext;
    eA = ~mpb.effectiveCurrent; eB = ~mpb.effectiveNext;
    ~gui.showChainsDetailed(curr, nxt, bA, bB, eA, eB);
};

~scenario1v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.8;
    steps = [
        { ~log.("init"); ~gui.showExpectation("Command: init", 0); ~refreshGuiFromMpb.() },
        { ~log.("add flanger"); ~gui.showExpectation("Command: add flanger", 0); ~mpb.add(\flanger); ~refreshGuiFromMpb.() },
        { ~log.("bypass flanger true"); ~gui.showExpectation("Command: bypass flanger true", 0); ~mpb.bypass(\flanger, true); ~refreshGuiFromMpb.() },
        { ~log.("add delay"); ~gui.showExpectation("Command: add delay", 0); ~mpb.add(\delay); ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT"); ~gui.showExpectation("Command: clear NEXT", 0); ~mpb.clearChain; ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario2v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.25;
    steps = [
        { ~log.("init"); ~gui.showExpectation("Command: init", 0); ~refreshGuiFromMpb.() },
        { ~log.("add chorus"); ~gui.showExpectation("Command: add chorus", 0); ~mpb.add(\chorus); ~refreshGuiFromMpb.() },
        { ~log.("add reverb"); ~gui.showExpectation("Command: add reverb", 0); ~mpb.add(\reverb); ~refreshGuiFromMpb.() },
        { ~log.("add tremolo"); ~gui.showExpectation("Command: add tremolo", 0); ~mpb.add(\tremolo); ~refreshGuiFromMpb.() },
        { ~log.("removeAt 2"); ~gui.showExpectation("Command: removeAt 2", 0); ~mpb.removeAt(2); ~refreshGuiFromMpb.() },
        { ~log.("add phaser"); ~gui.showExpectation("Command: add phaser", 0); ~mpb.add(\phaser); ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT"); ~gui.showExpectation("Command: clear NEXT", 0); ~mpb.clearChain; ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario3v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.6;
    steps = [
        { ~log.("init"); ~gui.showExpectation("Command: init", 0); ~refreshGuiFromMpb.() },
        { ~log.("add bitcrusher"); ~gui.showExpectation("Command: add bitcrusher", 0); ~mpb.add(\bitcrusher); ~refreshGuiFromMpb.() },
        { ~log.("bypass bitcrusher false"); ~gui.showExpectation("Command: bypass bitcrusher false", 0); ~mpb.bypass(\bitcrusher, false); ~refreshGuiFromMpb.() },
        { ~log.("removeAt 1"); ~gui.showExpectation("Command: removeAt 1", 0); ~mpb.removeAt(1); ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT"); ~gui.showExpectation("Command: clear NEXT", 0); ~mpb.clearChain; ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};


// ======================================================================
// Section C — Test_MagicDisplayGUI_InlineInstrument.scd v0.2 (verbatim)
// ======================================================================

~probeGuiV2 = {
    var hasGui, hasWin, current, next, bypassA, bypassB, effA, effB;
    hasGui = ~gui.notNil;
    if(hasGui.not) { "No ~gui. Run ~bootGuiV4.() first.".warn; ^nil };
    hasWin = ~gui.tryPerform(\window).notNil;
    ["[PROBE] gui exists:", hasGui, "window exists:", hasWin].postln;

    // very distinctive frame so you can spot it instantly
    current = [\chainA, \AAA_debug_one, \BBB_debug_two, \ts0];
    next    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];
    bypassA = [\BBB_debug_two];
    bypassB = [];
    effA    = [\chainA, \AAA_debug_one, \ts0];
    effB    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];

    // make the "Command:" box change as well (immediate visible cue)
    ~gui.showExpectation("Command: PROBE FRAME", 0);

    // schedule list redraw on AppClock (same thread your GUI uses internally)
    AppClock.sched(0, {
        "[PROBE] Calling showChainsDetailed on AppClock…".postln;
        ~gui.showChainsDetailed(current, next, bypassA, bypassB, effA, effB);
        "[PROBE] showChainsDetailed returned.".postln;
        nil
    });

    "Probe queued. Expect 'PROBE FRAME' in the Command area and AAA/BBB/CCC/DDD items in the lists."
    .postln;
};


// ======================================================================
// Section D — Patch + v6 Aliases + One-button Runner
// ======================================================================

// Resilient UI-queue patch: make queued UI work run immediately on AppClock
~md_applyQueueUiPatch = {
    var displayCandidates, candidateIndex, candidate, patched, proofFun;

    patched = false;
    displayCandidates = [];

    // Prefer ~magicDisplay if present; fallback to ~gui
    if(~magicDisplay.notNil) { displayCandidates = displayCandidates.add(~magicDisplay) };
    if(~gui.notNil)          { displayCandidates = displayCandidates.add(~gui) };

    if(displayCandidates.isEmpty) {
        "[PATCH] No display object (~magicDisplay or ~gui) yet; run boot first.".postln;
        ^false
    };

    candidateIndex = 0;
    while({ candidateIndex < displayCandidates.size and: { patched.not } }, {
        candidate = displayCandidates[candidateIndex];

        // Try setter first (slot/property on an object)
        if(candidate.respondsTo(\queueUi_)) {
            candidate.queueUi = { |selfArg, fun| fun.defer };  // UI-safe immediate
            patched = true;
        }{
            // Try dictionary/event-like storage
            if(candidate.respondsTo(\atPut)) {
                candidate[\queueUi] = { |ignoredSelf, fun| fun.defer }; // UI-safe immediate
                patched = true;
            };
        };

        candidateIndex = candidateIndex + 1;
    });

    if(patched) {
        "[PATCH] queueUi patched to immediate (.defer)".postln;

        // Proof-of-life
        if(candidate.respondsTo(\queueUi)) {
            candidate.queueUi({ "[CHECK] queueUi immediate hit".postln });
        }{
            if(candidate.respondsTo(\at)) {
                proofFun = candidate[\queueUi];
                if(proofFun.isKindOf(Function)) {
                    proofFun.value(candidate, { "[CHECK] queueUi immediate hit".postln });
                };
            };
        };
        ^true
    }{
        "[PATCH] Display found but exposes neither queueUi_ nor atPut; not patched.".postln;
        ^false
    };
};

// Wait-and-patch helper: polls until a display is available, then applies patch
~md_waitAndPatchQueueUiImmediate = {
    var attempts, maxAttempts, stepSeconds, routineInstance;

    attempts = 0;
    maxAttempts = 200;     // ~10 seconds at 0.05s
    stepSeconds = 0.05;

    routineInstance = Routine({
        "[PATCH] Waiting for display (~magicDisplay or ~gui)…".postln;
        while({ attempts < maxAttempts }, {
            if(~magicDisplay.notNil or: { ~gui.notNil }) {
                if(~md_applyQueueUiPatch.()) {
                    thisThread.stop;
                };
            };
            attempts = attempts + 1;
            stepSeconds.wait;
        });
        "[PATCH] Timed out waiting for display; run ~md_waitAndPatchQueueUiImmediate.() again after boot."
        .postln;
    }).play(AppClock);

    routineInstance
};

// v6-style aliases wrapping your existing definitions
~bootGuiV6 = {
    var booted;
    booted = false;
    if(~bootGuiV4.notNil) {
        ~bootGuiV4.();
        booted = true;
    }{
        "Missing ~bootGuiV4; please check Section A definitions.".warn;
    };

    // Start the wait-and-patch watcher right after boot
    if(booted) {
        ~md_waitAndPatchQueueUiImmediate.();
    };
};

~scenario1v6 = { if(~scenario1v5.notNil) { ~scenario1v5.() }{ if(~scenario1v4.notNil) { ~scenario1v4.() }{ "No scenario1 function found.".warn }} };
~scenario2v6 = { if(~scenario2v5.notNil) { ~scenario2v5.() }{ if(~scenario2v4.notNil) { ~scenario2v4.() }{ "No scenario2 function found.".warn }} };
~scenario3v6 = { if(~scenario3v5.notNil) { ~scenario3v5.() }{ if(~scenario3v4.notNil) { ~scenario3v4.() }{ "No scenario3 function found.".warn }} };

~probeGuiV3 = { if(~probeGuiV2.notNil) { ~probeGuiV2.() }{ "No probe function (~probeGuiV2) found.".warn } };

// One-button runner: boot → patch → probe → scenario
~md_go = {
    var bootTask;
    bootTask = Task({
        "[ALL-IN-ONE] Booting GUI (v6 alias)…".postln;
        ~bootGuiV6.();

        // small wait for "Window ready…" to appear
        0.5.wait;

        if(~probeGuiV3.notNil) {
            "[ALL-IN-ONE] Running probe (~probeGuiV3)…".postln;
            ~probeGuiV3.();
        };

        0.2.wait;

        if(~scenario1v6.notNil) {
            "[ALL-IN-ONE] Running scenario (~scenario1v6)…".postln;
            ~scenario1v6.();
        };
    });
    bootTask.start;
    bootTask
};

// Session banner
"[ALL-IN-ONE] Ready. Typical flow:\n  1) ~bootGuiV6.();\n  2) ~md_waitAndPatchQueueUiImmediate.();\n  3) ~probeGuiV3.();\n  4) ~scenario1v6.();\nOr just run: ~md_go.();"
.postln;

) // <— single top-level block ends here
/* Test_MagicDisplayGUI_BootAndScenarios.scd v0.4
   Purpose: Deterministic boot (meters OFF), wait for window, then scenarios that
            clearly post progress AND force GUI redraws every step.

   Style: tilde vars, var-first, lowercase names, no server.sync, no single-letter locals.
*/

(
// ---------- shared helpers ----------------------------------------------------

~postState = { |labelString|
    var curr, nxt;
    curr = ~mpb.tryPerform(\currentChain);
    nxt  = ~mpb.tryPerform(\nextChain);
    ("[STATE] " ++ labelString ++ " → current=" ++ curr.asString
        ++ " | next=" ++ nxt.asString).postln;
};

~drawOnce = {
    var curr, nxt, bypassA, bypassB, effA, effB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    curr    = ~mpb.currentChain;
    nxt     = ~mpb.nextChain;
    bypassA = ~mpb.bypassKeysCurrent;
    bypassB = ~mpb.bypassKeysNext;
    effA    = ~mpb.effectiveCurrent;
    effB    = ~mpb.effectiveNext;

    // GUI method that actually updates the lists/labels
    ~gui.showChainsDetailed(curr, nxt, bypassA, bypassB, effA, effB);
};

~refreshView = { |labelString|
    ~postState.(labelString);
    // Console view via MPB (also calls showChainsDetailed under the hood)
    ~mpb.printChains;
    // Explicit GUI redraw (belt-and-braces)
    ~drawOnce.();
};

// ---------- robust boot: wait for window, then first draw --------------------

~bootGuiV4 = {
    var guiObj, board, maxPollCount, pollDelaySeconds, routine;

    // stop any previous tasks
    ~mdgTask.notNil.if { ~mdgTask.stop; ~mdgTask = nil };
    ~bootTask.notNil.if { ~bootTask.stop; ~bootTask = nil };

    // create GUI and disable meters (avoid server dependency)
    guiObj = MagicDisplayGUI.new;
    guiObj.enableMeters(false);

    // create pedalboard and attach display
    board = MagicPedalboardNew(guiObj);
    ~gui = guiObj;
    ~mpb = board;

    // poll for the window (it is built asynchronously on AppClock)
    maxPollCount = 200;          // up to ~10 seconds
    pollDelaySeconds = 0.05;

    routine = Routine {
        var pollCount;
        pollCount = 0;

        while({ (~gui.window.isNil) and: { pollCount < maxPollCount } }, {
            pollCount = pollCount + 1;
            pollDelaySeconds.wait;      // SystemClock here; avoids AppClock contention
        });

        defer({
            if(~gui.window.notNil) {
                "Window ready — fronting and drawing columns.".postln;
                ~gui.window.front;
            }{
                "Window did not appear in time (10 s).".warn;
            };
            ~refreshView.("boot");
        });
    };

    ~bootTask = Task(routine, SystemClock).play; // use SystemClock for the polling loop
    "Booting GUI (meters disabled). Waiting for window…".postln;
};

// bring GUI to front later if needed
~frontGui = {
    if(~gui.notNil and: { ~gui.window.notNil }) { ~gui.window.front };
};

// stop any running scenario
~stopScenarios = {
    var runningTask;
    runningTask = ~mdgTask;
    if(runningTask.notNil) { runningTask.stop; ~mdgTask = nil; };
    "Stopped scenario task (if any).".postln;
};

// ---------- Scenarios (run on SystemClock, post step labels) -----------------

~scenario1v4 = {
    var routine, waitSeconds, steps, totalSteps;

    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    waitSeconds = 0.8;

    steps = [
        { "[SC1] init".postln; ~refreshView.("SC1/init") },

        { "[SC1] add flanger".postln;
          ~mpb.add(\flanger);
          ~refreshView.("SC1/add flanger") },

        { "[SC1] bypass flanger → true".postln;
          ~mpb.bypass(\flanger, true);
          ~refreshView.("SC1/bypass flanger true") },

        { "[SC1] add delay".postln;
          ~mpb.add(\delay);
          ~refreshView.("SC1/add delay") },

        { "[SC1] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC1/clear NEXT") }
    ];

    totalSteps = steps.size;

    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;   // SystemClock: robust in headless/server-off
    ~mdgTask
};

~scenario2v4 = {
    var routine, waitSeconds, steps, totalSteps;

    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    waitSeconds = 0.25;

    steps = [
        { "[SC2] init".postln; ~refreshView.("SC2/init") },
        { "[SC2] add chorus".postln;  ~mpb.add(\chorus);  ~refreshView.("SC2/add chorus") },
        { "[SC2] add reverb".postln;  ~mpb.add(\reverb);  ~refreshView.("SC2/add reverb") },
        { "[SC2] add tremolo".postln; ~mpb.add(\tremolo); ~refreshView.("SC2/add tremolo") },
        { "[SC2] removeAt 2".postln;  ~mpb.removeAt(2);   ~refreshView.("SC2/removeAt 2") },
        { "[SC2] add phaser".postln;  ~mpb.add(\phaser);  ~refreshView.("SC2/add phaser") },
        { "[SC2] clear NEXT".postln;  ~mpb.clearChain;    ~refreshView.("SC2/clear NEXT") }
    ];

    totalSteps = steps.size;

    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};

~scenario3v4 = {
    var routine, waitSeconds, steps, totalSteps;

    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    waitSeconds = 0.6;

    steps = [
        { "[SC3] init".postln; ~refreshView.("SC3/init") },

        { "[SC3] add bitcrusher".postln;
          ~mpb.add(\bitcrusher);
          ~refreshView.("SC3/add bitcrusher") },

        { "[SC3] bypass bitcrusher → false".postln;
          ~mpb.bypass(\bitcrusher, false);
          ~refreshView.("SC3/bypass bitcrusher false") },

        { "[SC3] removeAt 1 (if exists)".postln;
          ~mpb.removeAt(1);
          ~refreshView.("SC3/removeAt 1") },

        { "[SC3] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC3/clear NEXT") }
    ];

    totalSteps = steps.size;

    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};
)
/* Test_MagicDisplayGUI_InlineInstrument.scd v0.2
   Goal: verify that MagicDisplayGUI executes UI updates on AppClock and
         that a single forced frame appears in the lists and "Command:" area.
*/

(
~probeGuiV2 = {
    var hasGui, hasWin, current, next, bypassA, bypassB, effA, effB;

    hasGui = ~gui.notNil;
    if(hasGui.not) { "No ~gui. Run ~bootGuiV4.() first.".warn; ^nil };

    hasWin = ~gui.tryPerform(\window).notNil;

    ["[PROBE] gui exists:", hasGui, "window exists:", hasWin].postln;

    // very distinctive frame so you can spot it instantly
    current = [\chainA, \AAA_debug_one, \BBB_debug_two, \ts0];
    next    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];
    bypassA = [\BBB_debug_two];
    bypassB = [];
    effA    = [\chainA, \AAA_debug_one, \ts0];
    effB    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];

    // make the "Command:" box change as well (immediate visible cue)
    ~gui.showExpectation("Command: PROBE FRAME", 0);

    // schedule list redraw on AppClock (same thread your GUI uses internally)
    AppClock.sched(0, {
        "[PROBE] Calling showChainsDetailed on AppClock…".postln;
        ~gui.showChainsDetailed(current, next, bypassA, bypassB, effA, effB);
        "[PROBE] showChainsDetailed returned.".postln;
        nil
    });

    "Probe queued. Expect 'PROBE FRAME' in the Command area and AAA/BBB/CCC/DDD items in the lists."
    .postln;
};
)
// Test_MagicDisplayGUI_LayoutOnly_v2.scd
// v0.3.0
// MD 20250919-08:45 BST

/*
Purpose
- Bring up MagicDisplayGUI for visual-only testing and apply a NO-RECOMPILE layout fix:
  1) Move the HUD to the top-right so it doesn't cover the columns.
  2) Hide the Ops panel and reclaim the right-hand third for A/B columns.
  3) Shrink the meters horizontally.
- Populate CURRENT/NEXT with demo data and flip the CURRENT highlight every few seconds.

Style
- var-first; lowercase; AppClock-only GUI ops; no server.sync; one window named "MagicDisplayGUI*".
*/

(
var closeMagicWindows, makeGui, populateListsOnce, cycleCurrentHighlight;
var applyVisualFix, attachResizeFix;

// -- close any existing MagicDisplayGUI* windows to be deterministic
closeMagicWindows = {
    AppClock.sched(0.0, {
        var wins, count;
        wins = Window.allWindows.select({ arg w;
            var nm; nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        count = wins.size;
        wins.do(_.close);
        ("[GUI] closed " ++ count ++ " MagicDisplayGUI windows").postln;
        nil
    });
};

// -- create GUI; explicitly disable meters (no audio today)
makeGui = {
    AppClock.sched(0.05, {
        ~gui = ~gui ?? { MagicDisplayGUI.new };
        AppClock.sched(0.0, { ~gui.enableMeters(false); nil });
        AppClock.sched(0.05, { ~gui.enableMeters(false); nil });
        "[GUI] created; meters disabled".postln;
        nil
    });
};

// -- demo visual data
populateListsOnce = {
    AppClock.sched(0.15, {
        var current, next, effC, effN, bypassA, bypassB, ops;
        current = [\chainA, \delay, \chorus, \testmelody];
        next    = [\chainB, \reverb, \testmelody];
        bypassA = [\chorus];
        bypassB = [];
        effC = current; effN = next;
        if(~gui.notNil) {
            ~gui.showChainsDetailed(current, next, bypassA, bypassB, effC, effN);
            ~gui.highlightCurrentColumn(\chainA);
            ~gui.showExpectation("Visual-only layout test. No audio. No meters.", 0);

            // Fill ops list so we can immediately hide it in the fix thereafter.
            ops = ["insert delay", "switch", "bypass delay on", "bypass delay off", "switch"];
            if(~gui.respondsTo(\setOperations)) {
                ~gui.setOperations(ops);
                ~gui.setNextAction({ arg idx; ("[ops] next index " ++ idx).postln; });
            };
        };
        "[GUI] lists populated".postln;
        nil
    });
};

// -- flip current highlight every 3s (visual only)
cycleCurrentHighlight = {
    AppClock.sched(0.30, {
        var isA, step;
        isA = true;
        step = {
            if(~gui.notNil) {
                if(isA) {
                    ~gui.highlightCurrentColumn(\chainA);
                    ~gui.showExpectation("CURRENT: A (visual highlight only)", 0);
                }{
                    ~gui.highlightCurrentColumn(\chainB);
                    ~gui.showExpectation("CURRENT: B (visual highlight only)", 0);
                };
            };
            isA = isA.not;
        };
        Routine({ 8.do({ step.value; 3.0.wait; }) }).play(AppClock);
        nil
    });
};

// ---- NO-RECOMPILE VISUAL FIX ----
// Hide Ops panel, expand columns, shrink meters, park HUD top-right.
// This works by walking the window's view tree (no need to access class ivars).
applyVisualFix = {
    AppClock.sched(0.25, {
        var win, root, pad, colGap, metersH, expH, expGap, countH;
        var winRect, colW, colH, leftX, rightX;

        var compositeChildren, staticTexts, textViews, userViews, listViews, buttons, levelIndicators;

        var guessPanels, isPanelColumn, headerString, leftPanelView, rightPanelView;
        var expectationTextView, countdownLabelView, countdownBarView, metersGroupView;

        // 0) grab window
        win = Window.allWindows.detect({ arg w;
            var nm; nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        if(win.isNil) {
            "[FIX] MagicDisplayGUI window not found; skip.".postln; ^nil
        };
        root = win.view;

        // 1) classify direct children
        compositeChildren = root.children.select(_.isKindOf(CompositeView));
        staticTexts       = root.children.select(_.isKindOf(StaticText));
        textViews         = root.children.select(_.isKindOf(TextView));
        userViews         = root.children.select(_.isKindOf(UserView));
        listViews         = root.children.select(_.isKindOf(ListView));
        buttons           = root.children.select(_.isKindOf(Button));

        // 2) heuristics to identify parts
        //    - left/right panels are CompositeViews that contain a ListView (their list)
        //      and a StaticText header "CURRENT" / "NEXT"
        isPanelColumn = { arg panel;
            var hasList, hasHeader;
            hasList = panel.children.any(_.isKindOf(ListView));
            hasHeader = panel.children.any({ arg v;
                (v.isKindOf(StaticText)) and: {
                    headerString = v.tryPerform(\string);
                    headerString.notNil and: {
                        var s = headerString.asString.toUpper;
                        (s.contains("CURRENT") or: { s.contains("NEXT") })
                    }
                }
            });
            hasList and: { hasHeader }
        };
        guessPanels = compositeChildren.select(isPanelColumn);
        if(guessPanels.size >= 1) {
            // pick the two widest as left/right
            guessPanels = guessPanels.sortBy({ arg v; v.bounds.left });
            leftPanelView  = guessPanels.first;
            rightPanelView = (guessPanels.size > 1).if({ guessPanels.last }, { nil });
        };

        // expectation text = the only TextView child (class file creates one)
        expectationTextView = textViews.first;

        // countdown label = StaticText under expectation (we just move it with bounds)
        countdownLabelView = staticTexts.detect({ arg st;
            var y = st.bounds.top;
            var txt = st.tryPerform(\string);
            (txt.notNil) and: { y > ((expectationTextView.notNil).if({ expectationTextView.bounds.bottom }, { 0 })) }
        });

        // countdown bar = only UserView child (class file creates one)
        countdownBarView = userViews.first;

        // meters group = CompositeView child that contains LevelIndicator(s)
        levelIndicators = root.children.select(_.isKindOf(LevelIndicator)); // not direct parent; we need group
        metersGroupView = compositeChildren.detect({ arg cv;
            cv.children.any(_.isKindOf(LevelIndicator))
        });

        // 3) compute new geometry
        pad     = 10;
        colGap  = 40;
        metersH = 86;
        expH    = 52;
        expGap  = 6;
        countH  = 20;

        winRect = root.bounds;
        // hide the Ops list/button/status (these live directly under root)
        listViews.do(_.visible_(false));
        buttons.do(_.visible_(false));
        staticTexts.do({ arg st;
            var txt = st.tryPerform(\string);
            if(txt.notNil and: { txt.asString.beginsWith("Next:") }) { st.visible_(false) };
        });

        // recompute full-width (reclaim right third)
        colW = ((winRect.width - (2 * pad) - colGap) / 2).max(220);
        colH = (winRect.height
            - (2 * pad)   // top + bottom
            - metersH
            - expH
            - expGap
            - countH
            - 12).max(120);

        leftX  = pad;
        rightX = pad + colW + colGap;

        // 4) apply bounds if we found the views
        if(leftPanelView.notNil)  { leftPanelView.bounds  = Rect(leftX,  pad, colW, colH) };
        if(rightPanelView.notNil) { rightPanelView.bounds = Rect(rightX, pad, colW, colH) };

        if(expectationTextView.notNil) {
            expectationTextView.bounds = Rect(leftX, leftPanelView.bounds.bottom + 6, colW * 2 + colGap, expH)
        };
        if(countdownLabelView.notNil and: { expectationTextView.notNil }) {
            countdownLabelView.bounds = Rect(leftX, expectationTextView.bounds.bottom + expGap, 120, 20)
        };
        if(countdownBarView.notNil and: { expectationTextView.notNil }) {
            countdownBarView.bounds = Rect(leftX + 130, expectationTextView.bounds.bottom + expGap,
                (colW * 2 + colGap) - 140, 20)
        };

        // shrink meters width (e.g., 65% of columns span) and align left
        if(metersGroupView.notNil) {

            var groupLeft, groupTop, groupW, labelW, barW;
			var bars;
            groupLeft = pad;
            groupTop  = winRect.height - metersH - pad;
            groupW    = ((colW * 2 + colGap) * 0.65).clip(260, winRect.width - 2*pad);
            metersGroupView.bounds = Rect(groupLeft, groupTop, groupW, metersH);

            // child bars inside group (two rows)
            labelW = 60;
            barW   = groupW - labelW - 10;

            // find the two LevelIndicator children and set their bounds
            // (order is deterministic in your build: A first row, B second row)
            bars = metersGroupView.children.select(_.isKindOf(LevelIndicator));
            if(bars.size >= 1) { bars[0].bounds = Rect(labelW + 6, 4, barW, 20) };
            if(bars.size >= 2) { bars[1].bounds = Rect(labelW + 6, 42, barW, 20) };
        };

        // park HUD top-right so it doesn't cover the columns
        if(~procHud_relocate.notNil) {
            ~procHud_relocate.(\topRight);
            AppClock.sched(0.05, { if(~procHud_update.notNil) { ~procHud_update.() }; nil });
        };

        "[FIX] visual-only layout applied (ops hidden, columns expanded, meters shrunk, HUD top-right)".postln;
        nil
    });
};

// re-apply the layout fix on window resize
attachResizeFix = {
    AppClock.sched(0.28, {
        var win;
        win = Window.allWindows.detect({ arg w;
            var nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        if(win.notNil) {
            win.onResize = { applyVisualFix.value };
        };
        nil
    });
};

// ---- Run sequence ----
closeMagicWindows.value;
makeGui.value;
populateListsOnce.value;
cycleCurrentHighlight.value;

// If you already evaluated the Top-Left HUD file earlier, it will be moved to top-right.
// If not, this fix still works without HUD.
applyVisualFix.value;
attachResizeFix.value;
)
// Test_MagicDisplayGUI_LayoutOnly_v3.scd
// v0.3.3
// MD 20250919-09:05 BST

/*
Purpose
- Visual-only formatting test for MagicDisplayGUI (no audio, no meters).
- Robustly wait for the window to be created (AppClock poll) before any layout tweaks.
- Fixes you asked for:
  1) Move HUD to top-right (so it doesn't cover columns).
  2) Reclaim right-hand empty area by hiding ops panel if present.
  3) Shrink meters horizontally.

Style
- var-first in every function/closure; lowercase method names; AppClock-only for GUI; no server.sync.
- One window whose name begins with "MagicDisplayGUI".
*/

(
var closeMagicWindows, makeGui, waitForGuiWindow, bringToFront,
    populateListsOnce, cycleCurrentHighlight, applyVisualFix, attachResizeFix;

// ---- A) Close pre-existing windows (deterministic start) ----
closeMagicWindows = {
    var run;
    run = {
        var wins, count;
        wins = Window.allWindows.select({ arg w;
            var nm;
            nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        count = wins.size;
        wins.do({ arg w; w.close });
        ("[GUI] closed " ++ count ++ " MagicDisplayGUI windows").postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- B) Create GUI and keep meters disabled (visual-only) ----
makeGui = {
    var run;
    run = {
        ~gui = ~gui ?? { MagicDisplayGUI.new };
        // keep meters off (no audio)
        ~gui.enableMeters(false);
        ("[GUI] created; meters disabled").postln;
        nil
    };
    AppClock.sched(0.05, { run.value; nil });
};

// ---- C) Wait until the MagicDisplayGUI window exists (AppClock poll) ----
waitForGuiWindow = { arg timeoutSec = 2.0, pollSec = 0.05, onReadyFunc = nil;
    var startTime, poll;
    startTime = Main.elapsedTime;
    poll = {
        var win, have;
        win = Window.allWindows.detect({ arg w;
            var nm;
            nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        have = win.notNil;
        if(have) {
            if(onReadyFunc.notNil) { onReadyFunc.value(win) };
            nil
        }{
            if((Main.elapsedTime - startTime) > timeoutSec) {
                "[WAIT] MagicDisplayGUI window not found (timeout)".warn;
                nil
            }{
                AppClock.sched(pollSec, poll)
            }
        }
    };
    AppClock.sched(0.00, { poll.value; nil });
    ^this
};

// ---- D) Bring the window to the front (belt-and-braces) ----
bringToFront = { arg win;
    var run;
    run = {
        if(win.notNil) {
            win.front;
            win.alwaysOnTop_(true);
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- E) Populate CURRENT/NEXT lists visually (no audio) ----
populateListsOnce = {
    var run;
    run = {
        var current, next, effC, effN, bypassA, bypassB, ops;
        current  = [\chainA, \delay, \chorus, \testmelody];
        next     = [\chainB, \reverb, \testmelody];
        bypassA  = [\chorus];
        bypassB  = [];
        effC     = current;
        effN     = next;
        if(~gui.notNil) {
            ~gui.showChainsDetailed(current, next, bypassA, bypassB, effC, effN);
            ~gui.highlightCurrentColumn(\chainA);
            ~gui.showExpectation("Visual-only layout test. No audio. No meters.", 0);
            // Provide text for the ops list (non-interactive); may not exist on your build
            ops = ["insert delay", "switch", "bypass delay on", "bypass delay off", "switch"];
            if(~gui.respondsTo(\setOperations)) {
                ~gui.setOperations(ops);
                ~gui.setNextAction({ arg idx; ("[ops] next index " ++ idx).postln; });
            };
        };
        ("[GUI] lists populated").postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- F) Flip CURRENT highlight every ~3 seconds (visual only) ----
cycleCurrentHighlight = {
    var run;
    run = {
        var isA;
        isA = true;
        Routine({
            8.do({
                if(~gui.notNil) {
                    if(isA) {
                        ~gui.highlightCurrentColumn(\chainA);
                        ~gui.showExpectation("CURRENT: A (visual highlight only)", 0);
                    }{
                        ~gui.highlightCurrentColumn(\chainB);
                        ~gui.showExpectation("CURRENT: B (visual highlight only)", 0);
                    };
                };
                isA = isA.not;
                3.0.wait;
            });
        }).play(AppClock);
        nil
    };
    AppClock.sched(0.25, { run.value; nil });
};

// ---- G) Visual fix: reclaim right space, shrink meters, move HUD top-right ----
applyVisualFix = { arg win;
    var run;
    run = {
        var root, pad, colGap, metersH, expH, expGap, countH;
        var winRect, colW, colH, leftX, rightX;
        var compositeChildren, staticTexts, textViews, userViews, listViews, buttons, levelIndicators;
        var guessPanels, isPanelColumn, headerString, leftPanelView, rightPanelView;
        var expectationTextView, countdownLabelView, countdownBarView, metersGroupView;

        // guard
        if(win.isNil) { ^nil };

        root  = win.view;
        pad   = 10;
        colGap= 40;
        metersH = 86;
        expH    = 52;
        expGap  = 6;
        countH  = 20;

        winRect = root.bounds;

        // classify children (direct)
        compositeChildren = root.children.select({ arg v; v.isKindOf(CompositeView) });
        staticTexts       = root.children.select({ arg v; v.isKindOf(StaticText) });
        textViews         = root.children.select({ arg v; v.isKindOf(TextView) });
        userViews         = root.children.select({ arg v; v.isKindOf(UserView) });
        listViews         = root.children.select({ arg v; v.isKindOf(ListView) });
        buttons           = root.children.select({ arg v; v.isKindOf(Button) });
        levelIndicators   = root.children.select({ arg v; v.isKindOf(LevelIndicator) }); // probably empty; bars live under meters group

        // locate left/right column panels via heuristics
        isPanelColumn = { arg panel;
            var hasList, hasHeader;
            hasList   = panel.children.any({ arg c; c.isKindOf(ListView) });
            hasHeader = panel.children.any({ arg c;
                var t;
                t = (c.isKindOf(StaticText)).if({ c.tryPerform(\string) }, { nil });
                t.notNil and: {
                    var s;
                    s = t.asString.toUpper;
                    s.contains("CURRENT") or: { s.contains("NEXT") }
                }
            });
            hasList and: { hasHeader }
        };
        guessPanels = compositeChildren.select(isPanelColumn).sortBy({ arg v; v.bounds.left });
        leftPanelView  = (guessPanels.size >= 1).if({ guessPanels[0] }, { nil });
        rightPanelView = (guessPanels.size >= 2).if({ guessPanels[1] }, { nil });

        expectationTextView = textViews.first;         // created in class
        countdownBarView    = userViews.first;         // created in class
        countdownLabelView  = staticTexts.detect({ arg st;
            var lbok, txt, y, expBottom;
            txt = st.tryPerform(\string);
            y   = st.bounds.top;
            expBottom = (expectationTextView.notNil).if({ expectationTextView.bounds.bottom }, { 0 });
            lbok = txt.notNil and: { y > expBottom };
            lbok
        });

        // hide ops area if present
        listViews.do({ arg lv; lv.visible_(false) });
        buttons.do({ arg b; b.visible_(false) });
        staticTexts.do({ arg st;
            var txt;
            txt = st.tryPerform(\string);
            if(txt.notNil and: { txt.asString.beginsWith("Next:") }) { st.visible_(false) };
        });

        // recompute two column geometry across full width
        colW = ((winRect.width - (2 * pad) - colGap) / 2).max(220);
        colH = (winRect.height - (2 * pad) - metersH - expH - expGap - countH - 12).max(120);
        leftX  = pad;
        rightX = pad + colW + colGap;

        if(leftPanelView.notNil)  { leftPanelView.bounds  = Rect(leftX,  pad, colW, colH) };
        if(rightPanelView.notNil) { rightPanelView.bounds = Rect(rightX, pad, colW, colH) };

        if(expectationTextView.notNil and: { leftPanelView.notNil }) {
            expectationTextView.bounds = Rect(leftX, leftPanelView.bounds.bottom + 6, colW * 2 + colGap, expH)
        };
        if(countdownLabelView.notNil and: { expectationTextView.notNil }) {
            countdownLabelView.bounds = Rect(leftX, expectationTextView.bounds.bottom + expGap, 120, 20)
        };
        if(countdownBarView.notNil and: { expectationTextView.notNil }) {
            countdownBarView.bounds = Rect(leftX + 130, expectationTextView.bounds.bottom + expGap,
                (colW * 2 + colGap) - 140, 20)
        };

        // locate meters group: CompositeView child that contains LevelIndicators
        metersGroupView = compositeChildren.detect({ arg cv;
            cv.children.any({ arg c; c.isKindOf(LevelIndicator) })
        });

        // shrink meters width to 60% of columns span and align left
        if(metersGroupView.notNil) {
            var groupLeft, groupTop, groupW, labelW, barW, bars;
            groupLeft = pad;
            groupTop  = winRect.height - metersH - pad;
            groupW    = ((colW * 2 + colGap) * 0.60).clip(240, winRect.width - 2*pad);
            metersGroupView.bounds = Rect(groupLeft, groupTop, groupW, metersH);

            // child indicators (two rows: A/B)
            labelW = 60;
            barW   = groupW - labelW - 10;
            bars   = metersGroupView.children.select({ arg v; v.isKindOf(LevelIndicator) });
            if(bars.size >= 1) { bars[0].bounds = Rect(labelW + 6, 4,  barW, 20) };
            if(bars.size >= 2) { bars[1].bounds = Rect(labelW + 6, 42, barW, 20) };
        };

        // move HUD to top-right (if the helpers exist)
        if(~procHud_relocate.notNil) {
            ~procHud_relocate.(\topRight);
            AppClock.sched(0.05, { if(~procHud_update.notNil) { ~procHud_update.() }; nil });
        };

        "[FIX] visual-only layout applied (ops hidden if present, columns expanded, meters shrunk, HUD top-right)".postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- H) Reapply fix on window resize ----
attachResizeFix = { arg win;
    var run;
    run = {
        if(win.notNil) {
            win.onResize = { applyVisualFix.value(win) };
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- Sequence ----
closeMagicWindows.value;
makeGui.value;

waitForGuiWindow.value(
    3.0, 0.05,
    { arg win;
        bringToFront.value(win);
        populateListsOnce.value;
        cycleCurrentHighlight.value;
        applyVisualFix.value(win);
        attachResizeFix.value(win);
    }
);
)
// Test_MagicDisplayGUI_LayoutOnly_v4.scd
// v0.4.0
// MD 20250919-09:25 BST

/*
Purpose
- Visual-only formatting test for MagicDisplayGUI with a bottom-docked "Processors" panel.
- Resizes the main window to ~1340 px width (and taller), disables meters, and uses GridLayout
  to render CURRENT/NEXT processor strings at the bottom (no overlap with columns).
- Narrows meters group width to avoid wasting the right third.

Style
- var-first in every function/closure; lowercase names; AppClock-only GUI ops; no server.sync.
- One window whose name begins with "MagicDisplayGUI".
*/

(
var closeMagicWindows, makeGui, waitForWindow, bringToFront,
    populateLists, buildBottomHud, refreshBottomHud, shrinkMeters, attachResize,
    winWantedW, winWantedH, hudH;

// ---- configuration ----
winWantedW = 1340;   // your requested width
winWantedH = 900;    // a bit taller to make room for the bottom panel
hudH       = 88;     // bottom panel height (dark grey)

closeMagicWindows = {
    var run;
    run = {
        var wins, count;
        wins = Window.allWindows.select({ arg w;
            var nm; nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        count = wins.size;
        wins.do({ arg w; w.close });
        ("[GUI] closed " ++ count ++ " MagicDisplayGUI windows").postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

makeGui = {
    var run;
    run = {
        ~gui = ~gui ?? { MagicDisplayGUI.new };
        // Visual-only = meters off
        ~gui.enableMeters(false);
        "[GUI] created; meters disabled".postln;
        nil
    };
    AppClock.sched(0.05, { run.value; nil });
};

waitForWindow = { arg timeoutSec = 3.0, pollSec = 0.05, onReadyFunc = nil;
    var startTime, poll;
    startTime = Main.elapsedTime;
    poll = {
        var win, have;
        win = Window.allWindows.detect({ arg w;
            var nm; nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        have = win.notNil;
        if(have) {
            if(onReadyFunc.notNil) { onReadyFunc.value(win) };
            nil
        }{
            if((Main.elapsedTime - startTime) > timeoutSec) {
                "[WAIT] MagicDisplayGUI window not found (timeout)".warn; nil
            }{
                AppClock.sched(pollSec, poll)
            }
        }
    };
    AppClock.sched(0.00, { poll.value; nil });
    ^this
};

bringToFront = { arg win;
    var run;
    run = {
        var x, y;
        if(win.notNil) {
            // Set to requested size; keep top-left where it is
            x = win.bounds.left; y = win.bounds.top;
            win.bounds = Rect(x, y, winWantedW, winWantedH);
            win.front; win.alwaysOnTop_(true);
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// Populate column lists with visual-only demo text
populateLists = {
    var run;
    run = {
        var current, next, effC, effN, bypassA, bypassB;
        current  = [\chainA, \delay, \chorus, \testmelody];
        next     = [\chainB, \reverb, \testmelody];
        bypassA  = [\chorus];
        bypassB  = [];
        effC = current; effN = next;
        if(~gui.notNil) {
            ~gui.showChainsDetailed(current, next, bypassA, bypassB, effC, effN);
            ~gui.highlightCurrentColumn(\chainA);
            ~gui.showExpectation("Visual-only: bottom Processors panel (GridLayout), meters disabled.", 0);
        };
        "[GUI] lists populated".postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// Build bottom-docked Processors panel using GridLayout
// Exposes ~bottomHud and ~bottomHud_update
buildBottomHud = { arg win;
    var run;
    run = {
        var root, pad, panelRect, hud, grid, title, curLabel, curText, nextLabel, nextText;
        var boundsNow;
        if(win.isNil) { ^nil };
        root = win.view;
        pad  = 10;
        boundsNow = root.bounds;

        panelRect = Rect(
            pad,
            boundsNow.height - hudH - pad,   // dock at bottom
            boundsNow.width  - (2 * pad),
            hudH
        );

        // Create once; reuse if present
        if(~bottomHud.notNil and: { ~bottomHud.isClosed.not }) {
            ~bottomHud.bounds = panelRect;
        }{
            hud = CompositeView(root, panelRect)
                .background_(Color(0.12, 0.12, 0.12, 0.92));
            // Use GridLayout for clean alignment and stretching:
            // We'll make 2 columns: [label][content], 3 rows: title (span 2 cols), current, next.
            grid = GridLayout.new;
            hud.layout = grid;

            title     = StaticText(hud).string_("Processors").stringColor_(Color(0.95, 0.95, 0.95));
            curLabel  = StaticText(hud).string_("CURRENT:").stringColor_(Color(0.90, 0.90, 0.90));
            curText   = StaticText(hud).string_("–").stringColor_(Color(0.90, 0.90, 0.90));
            nextLabel = StaticText(hud).string_("NEXT:").stringColor_(Color(0.80, 0.80, 0.80));
            nextText  = StaticText(hud).string_("–").stringColor_(Color(0.80, 0.80, 0.80));

            // Place items (row, col, rows, cols); stretch right column
            grid.add(title,     0, 0, 1, 2);  // span 2 columns
            grid.add(curLabel,  1, 0);
            grid.add(curText,   1, 1);
            grid.add(nextLabel, 2, 0);
            grid.add(nextText,  2, 1);
            grid.setColumnStretch(1, 1);  // right column grows
            grid.setRowStretch(0, 0);     // title fixed
            grid.setRowStretch(1, 1);     // rows get space if needed
            grid.setRowStretch(2, 1);
            grid.hSpacing = 10; grid.vSpacing = 4;

            // remember components for future updates
            ~bottomHud = IdentityDictionary[
                \view     -> hud,
                \curText  -> curText,
                \nextText -> nextText
            ];
            "[HUD] bottom (GridLayout) installed".postln;
        };

        // Provide updater function
        ~bottomHud_update = {
            var getTail, summarize, curArr, nxtArr, curTail, nxtTail, curStr, nxtStr;
            getTail = { arg arr; if(arr.isNil or: { arr.size < 2 }) { [] } { arr.copyRange(1, arr.size-1) } };
            summarize = { arg syms;
                var names, joined;
                names = syms.collect(_.asString);
                joined = names.join("  ->  ");
                if(joined.size > 96) { joined.copyRange(0, 93) ++ "…" } { joined }
            };
            if(~mpb.notNil) {
                curArr = ~mpb.effectiveCurrent;
                nxtArr = ~mpb.effectiveNext;
                curTail = getTail.value(curArr);
                nxtTail = getTail.value(nxtArr);
                curStr = summarize.value(curTail);
                nxtStr = summarize.value(nxtTail);
            }{
                // Visual demo fallback
                curStr = "delay  ->  chorus  ->  testmelody";
                nxtStr = "reverb ->  testmelody";
            };
            if(~bottomHud.notNil) {
                (~bottomHud[\curText]).string = curStr;
                (~bottomHud[\nextText]).string = nxtStr;
            };
        };

        // first fill
        AppClock.sched(0.00, { ~bottomHud_update.value; nil });
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// Narrow the meters group width so it doesn’t force a wide layout
shrinkMeters = { arg win;
    var run;
    run = {
        var root, pad, metersH, winRect, compositeChildren, metersGroupView, groupLeft, groupTop, groupW, labelW, barW, bars;
        if(win.isNil) { ^nil };
        root     = win.view;
        pad      = 10;
        metersH  = 86;
        winRect  = root.bounds;
        compositeChildren = root.children.select({ arg v; v.isKindOf(CompositeView) });
        // meters group: CompositeView child that contains LevelIndicators
        metersGroupView = compositeChildren.detect({ arg cv; cv.children.any({ arg c; c.isKindOf(LevelIndicator) }) });
        if(metersGroupView.notNil) {
            groupLeft = pad;
            groupTop  = winRect.height - metersH - pad;
            groupW    = (winRect.width * 0.55).clip(240, winRect.width - 2*pad); // ~55% width
            metersGroupView.bounds = Rect(groupLeft, groupTop, groupW, metersH);

            labelW = 60;
            barW   = groupW - labelW - 10;
            bars   = metersGroupView.children.select({ arg v; v.isKindOf(LevelIndicator) });
            if(bars.size >= 1) { bars[0].bounds = Rect(labelW + 6, 4,  barW, 20) };
            if(bars.size >= 2) { bars[1].bounds = Rect(labelW + 6, 42, barW, 20) };
            "[METERS] narrowed".postln;
        }{
            "[METERS] group not found (ok on some builds)".postln;
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// Re-apply on resize (keeps HUD docked at bottom & meters narrow)
attachResize = { arg win;
    var run;
    run = {
        if(win.notNil) {
            win.onResize = {
                var x, y, w, h, root, pad, hud;
                // keep width near your requested target if you resize huge
                root = win.view; pad = 10;
                w = win.bounds.width; h = win.bounds.height;
                // reposition HUD
                if(~bottomHud.notNil) {
                    hud = ~bottomHud[\view];
                    if(hud.notNil and: { hud.isClosed.not }) {
                        hud.bounds = Rect(pad, root.bounds.height - hudH - pad, root.bounds.width - (2*pad), hudH);
                    };
                };
                // keep meters narrow
                shrinkMeters.value(win);
                // refresh strings (if ~mpb present)
                if(~bottomHud_update.notNil) {
                    AppClock.sched(0.00, { ~bottomHud_update.value; nil });
                };
            };
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- run sequence ----
closeMagicWindows.value;
makeGui.value;

waitForWindow.value(
    3.0, 0.05,
    { arg win;
        bringToFront.value(win);
        populateLists.value;
        buildBottomHud.value(win);
        shrinkMeters.value(win);
        attachResize.value(win);
    }
);
)
// Test_MagicDisplayGUI_LayoutOnly.scd
// v0.3.9
// MD 20250919-10:46 BST

/*
Purpose
- Visual-only demo for MagicDisplayGUI_GridDemo with debug guides & row rects.

Style
- var-first; AppClock-only; no server.sync.
*/

(
var closeWindows, makeGui, populate, flipCurrent, showDebug, wins, count;

closeWindows = {
    var run;
    run = {
        var nm;
        wins = Window.allWindows.select({ arg w;
            nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        count = wins.size;
        wins.do(_.close);
        ("[GUI] closed " ++ count ++ " MagicDisplayGUI windows").postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

makeGui = {
    var run;
    run = {
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.enableMeters(false);
        "[GUI] created (GridDemo); meters disabled".postln;
        nil
    };
    AppClock.sched(0.05, { run.value; nil });
};

populate = {
    var run;
    run = {
        var current, next, effC, effN, bypassA, bypassB;
        current = [\chainA, \delay, \chorus, \testmelody];
        next    = [\chainB, \reverb, \testmelody];
        bypassA = [\chorus]; bypassB = [];
        effC = current; effN = next;

        ~gui.showChainsDetailed(current, next, bypassA, bypassB, effC, effN);
        ~gui.highlightCurrentColumn(\chainA);
        ~gui.showExpectation("Row0 two columns; rows 1–4 full-width (addSpanning); meters fixed to 30 px.", 0);
        "[GUI] lists populated".postln;
        nil
    };
    AppClock.sched(0.12, { run.value; nil });
};

showDebug = {
    var run;
    run = {
        ~gui.debugGuides(true);
        AppClock.sched(0.05, { ~gui.postLayoutReport; nil });
        nil
    };
    AppClock.sched(0.20, { run.value; nil });
};

flipCurrent = {
    var run;
    run = {
        var isA;
        isA = false;
        Routine({
            6.do({
                if(isA) {
                    ~gui.highlightCurrentColumn(\chainA);
                    ~gui.showExpectation("CURRENT: A (visual highlight only)", 0);
                }{
                    ~gui.highlightCurrentColumn(\chainB);
                    ~gui.showExpectation("CURRENT: B (visual highlight only)", 0);
                };
                isA = isA.not;
                3.0.wait;
            });
        }).play(AppClock);
        nil
    };
    AppClock.sched(0.25, { run.value; nil });
};

closeWindows.value;
makeGui.value;
populate.value;
// showDebug.value; // turn on/off red debug outlines
flipCurrent.value;
)
// Test_MagicDisplayGUI_LayoutOnlySelfContained.scd
// v0.4.0
// MD 20250919-09:45 BST

/*
Purpose
- Visual-only GUI demonstration using GridLayout (no audio, meters disabled).
- Window ~1340x900; top row: CURRENT/NEXT columns; middle rows: expectation + countdown;
  row below: meters (narrowed, left-anchored); bottom row: dark-grey "Processors" panel.
- No user interaction required.

Style
- var-first in every closure; lowercase method names; AppClock-only GUI ops; no server.sync.
*/

(
var pad, win, root, rootLayout,
    leftPanel, leftGrid, leftHeader, leftList, leftEff,
    rightPanel, rightGrid, rightHeader, rightList, rightEff,
    expectationText, countdownHolder, countdownGrid, countdownLabel, countdownBar,
    meterGroup, meterGrid, labelA, labelB, meterA, meterB, meterSpacer,
    bottomHud, bottomGrid, bottomTitle, bottomCurLabel, bottomCurText, bottomNextLabel, bottomNextText,
    populateDemo, cycleCurrent, wins, closedCount;

AppClock.sched(0.0, {
    // Close any existing MagicDisplayGUI* windows (deterministic)
    var nm;
    wins = Window.allWindows.select({ arg w;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    closedCount = wins.size;
    wins.do(_.close);
    ("[GUI] closed " ++ closedCount ++ " MagicDisplayGUI windows").postln;

    // Build main window
    pad = 10;
    win = Window("MagicDisplayGUI – GridDemo (Visual)", Rect(120, 80, 1340, 900))
        .front
        .alwaysOnTop_(true);
    root = win.view;

    // Root GridLayout
    rootLayout = GridLayout.new;
    root.layout = rootLayout;

    // === Row 0: two columns (CURRENT / NEXT) =================================
    leftPanel = CompositeView(root).background_(Color(0.92, 0.92, 0.92));
    leftGrid = GridLayout.new; leftPanel.layout = leftGrid;
    leftHeader = StaticText(leftPanel).string_("CHAIN A ACTIVE").align_(\center);
    leftList   = ListView(leftPanel).items_([]);
    leftEff    = StaticText(leftPanel).string_("eff: —").align_(\center);
    leftGrid.add(leftHeader, 0, 0);
    leftGrid.add(leftList,   1, 0);
    leftGrid.add(leftEff,    2, 0);
    leftGrid.setRowStretch(0, 0);
    leftGrid.setRowStretch(1, 1);
    leftGrid.setRowStretch(2, 0);

    rightPanel = CompositeView(root).background_(Color(0.92, 0.92, 0.92));
    rightGrid = GridLayout.new; rightPanel.layout = rightGrid;
    rightHeader = StaticText(rightPanel).string_("CHAIN B NEXT").align_(\center);
    rightList   = ListView(rightPanel).items_([]);
    rightEff    = StaticText(rightPanel).string_("eff: —").align_(\center);
    rightGrid.add(rightHeader, 0, 0);
    rightGrid.add(rightList,   1, 0);
    rightGrid.add(rightEff,    2, 0);
    rightGrid.setRowStretch(0, 0);
    rightGrid.setRowStretch(1, 1);
    rightGrid.setRowStretch(2, 0);

    rootLayout.add(leftPanel,  0, 0);
    rootLayout.add(rightPanel, 0, 1);
    rootLayout.setColumnStretch(0, 1);
    rootLayout.setColumnStretch(1, 1);
    rootLayout.setRowStretch(0, 6); // top row dominates height

    // === Row 1: expectation text (spans 2 columns) ===========================
    expectationText = TextView(root)
        .background_(Color(1, 1, 0.9))
        .string_("Command:");
    rootLayout.add(expectationText, 1, 0, 1, 2);
    rootLayout.setRowStretch(1, 0);

    // === Row 2: countdown (label + bar) spanning 2 columns ===================
    countdownHolder = CompositeView(root);
    countdownGrid   = GridLayout.new; countdownHolder.layout = countdownGrid;
    countdownLabel  = StaticText(countdownHolder).string_("Ready");
    countdownBar    = UserView(countdownHolder);
    countdownGrid.add(countdownLabel, 0, 0);
    countdownGrid.add(countdownBar,   0, 1);
    countdownGrid.setColumnStretch(0, 0);
    countdownGrid.setColumnStretch(1, 1);
    rootLayout.add(countdownHolder, 2, 0, 1, 2);
    rootLayout.setRowStretch(2, 0);

    // === Row 3: meters (left) + spacer (right) to keep meters narrow =========
    meterGroup = CompositeView(root).background_(Color(0.96, 0.96, 0.96));
    meterGrid  = GridLayout.new; meterGroup.layout = meterGrid;
    labelA = StaticText(meterGroup).string_("chainA");
    meterA = LevelIndicator(meterGroup);
    labelB = StaticText(meterGroup).string_("chainB");
    meterB = LevelIndicator(meterGroup);
    meterGrid.add(labelA, 0, 0);
    meterGrid.add(meterA, 0, 1);
    meterGrid.add(labelB, 1, 0);
    meterGrid.add(meterB, 1, 1);
    meterGrid.setColumnStretch(0, 0);
    meterGrid.setColumnStretch(1, 1);

    meterSpacer = CompositeView(root); // empty filler; absorbs right-space
    rootLayout.add(meterGroup,  3, 0);
    rootLayout.add(meterSpacer, 3, 1);
    // columns: 0 minimal (meters), 1 stretches (spacer)
    rootLayout.setColumnStretch(0, 0);
    rootLayout.setColumnStretch(1, 1);
    rootLayout.setRowStretch(3, 1);

    // === Row 4: bottom Processors panel (dark grey; spans 2 columns) ========
    bottomHud  = CompositeView(root).background_(Color(0.12, 0.12, 0.12, 0.92));
    bottomGrid = GridLayout.new; bottomHud.layout = bottomGrid;
    bottomTitle     = StaticText(bottomHud).string_("Processors").stringColor_(Color(0.95, 0.95, 0.95));
    bottomCurLabel  = StaticText(bottomHud).string_("CURRENT:").stringColor_(Color(0.90, 0.90, 0.90));
    bottomCurText   = StaticText(bottomHud).string_("–").stringColor_(Color(0.90, 0.90, 0.90));
    bottomNextLabel = StaticText(bottomHud).string_("NEXT:").stringColor_(Color(0.80, 0.80, 0.80));
    bottomNextText  = StaticText(bottomHud).string_("–").stringColor_(Color(0.80, 0.80, 0.80));

    bottomGrid.add(bottomTitle,     0, 0, 1, 2); // span 2 columns
    bottomGrid.add(bottomCurLabel,  1, 0);
    bottomGrid.add(bottomCurText,   1, 1);
    bottomGrid.add(bottomNextLabel, 2, 0);
    bottomGrid.add(bottomNextText,  2, 1);
    bottomGrid.setColumnStretch(0, 0);
    bottomGrid.setColumnStretch(1, 1);
    bottomGrid.hSpacing = 10; bottomGrid.vSpacing = 4;

    rootLayout.add(bottomHud, 4, 0, 1, 2);
    rootLayout.setRowStretch(4, 1);

    // Attach resize to the VIEW (not the Window). GridLayout handles sizing.
    root.onResize = { nil };

    // ---- Populate demo content ------------------------------------------------
    populateDemo = {
        var current, next, effC, effN, bypassA, bypassB, formatList, effCText, effNText;
        current = [\chainA, \delay, \chorus, \testmelody];
        next    = [\chainB, \reverb, \testmelody];
        bypassA = [\chorus]; bypassB = [];
        effC = current; effN = next;

        formatList = { arg listRef, bypassKeys, effList;
            var out, lastIdx, procs, idx;
            out = Array.new;
            lastIdx = listRef.size - 1;
            out = out.add("src : " ++ listRef[lastIdx]);
            if(listRef.size > 2) {
                out = out.add("procs:");
                procs = listRef.copyRange(1, lastIdx - 1).reverse;
                idx = 1;
                procs.do({ arg key;
                    var byp, badge, line;
                    byp = bypassKeys.includes(key);
                    badge = byp.if({ "[BYP]" }, { "[ON]" });
                    line = " [" ++ idx ++ "] " ++ key ++ " " ++ badge;
                    out = out.add(line);
                    idx = idx + 1;
                });
            }{
                out = out.add("procs: (none)");
            };
            out = out.add("sink : " ++ listRef[0]);
            out
        };

        leftList.items_(formatList.value(current, bypassA, effC));
        rightList.items_(formatList.value(next,    bypassB, effN));

        effCText = "eff: " ++ effC.join(" -> ");
        effNText = "eff: " ++ effN.join(" -> ");
        leftEff.string_(effCText);
        rightEff.string_(effNText);

        // headers + highlight
        leftHeader.string_("CHAIN A ACTIVE");
        rightHeader.string_("CHAIN B NEXT");
        leftPanel.background_(Color(0.85, 1.0, 0.85));
        rightPanel.background_(Color(0.92, 0.92, 0.92));

        // bottom HUD strings
        bottomCurText.string_((" " ++ effC.copyRange(1, effC.size - 1).join(" -> ")).trim);
        bottomNextText.string_((" " ++ effN.copyRange(1, effN.size - 1).join(" -> ")).trim);

        expectationText.string_("Visual-only: GridLayout; bottom Processors panel; meters narrowed (left).");
        countdownLabel.string_("Ready");
        nil
    };
    populateDemo.value;

    // ---- Flip CURRENT highlight every ~3s (visual only) ----------------------
    cycleCurrent = {
        var isA;
        isA = false;
        Routine({
            8.do({
                if(isA) {
                    leftPanel.background_(Color(0.85, 1.0, 0.85));
                    rightPanel.background_(Color(0.92, 0.92, 0.92));
                    leftHeader.string_("CHAIN A ACTIVE");
                    rightHeader.string_("CHAIN B NEXT");
                    expectationText.string_("CURRENT: A (visual highlight only)");
                }{
                    leftPanel.background_(Color(0.92, 0.92, 0.92));
                    rightPanel.background_(Color(0.85, 1.0, 0.85));
                    leftHeader.string_("CHAIN A NEXT");
                    rightHeader.string_("CHAIN B ACTIVE");
                    expectationText.string_("CURRENT: B (visual highlight only)");
                };
                isA = isA.not;
                3.0.wait;
            });
        }).play(AppClock);
        nil
    };
    cycleCurrent.value;

    nil
});
)
/* Test_MagicDisplayGUI_Scenarios.scd v0.5
   Very explicit scenarios: log each step, update "Command:", then force GUI redraw.
*/

(
~log = { |msg| ("[SC] " ++ msg).postln };

~refreshGuiFromMpb = {
    var curr, nxt, bA, bB, eA, eB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    curr = ~mpb.currentChain;  nxt = ~mpb.nextChain;
    bA = ~mpb.bypassKeysCurrent; bB = ~mpb.bypassKeysNext;
    eA = ~mpb.effectiveCurrent;  eB = ~mpb.effectiveNext;
    ~gui.showChainsDetailed(curr, nxt, bA, bB, eA, eB);
};

~scenario1v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.8;
    steps = [
        { ~log.("init");               ~gui.showExpectation("Command: init", 0);               ~refreshGuiFromMpb.() },
        { ~log.("add flanger");        ~gui.showExpectation("Command: add flanger", 0);        ~mpb.add(\flanger);       ~refreshGuiFromMpb.() },
        { ~log.("bypass flanger true");~gui.showExpectation("Command: bypass flanger true", 0);~mpb.bypass(\flanger, true);~refreshGuiFromMpb.() },
        { ~log.("add delay");          ~gui.showExpectation("Command: add delay", 0);          ~mpb.add(\delay);         ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT");         ~gui.showExpectation("Command: clear NEXT", 0);         ~mpb.clearChain;          ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario2v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.25;
    steps = [
        { ~log.("init");        ~gui.showExpectation("Command: init", 0);        ~refreshGuiFromMpb.() },
        { ~log.("add chorus");  ~gui.showExpectation("Command: add chorus", 0);  ~mpb.add(\chorus);     ~refreshGuiFromMpb.() },
        { ~log.("add reverb");  ~gui.showExpectation("Command: add reverb", 0);  ~mpb.add(\reverb);     ~refreshGuiFromMpb.() },
        { ~log.("add tremolo"); ~gui.showExpectation("Command: add tremolo", 0); ~mpb.add(\tremolo);    ~refreshGuiFromMpb.() },
        { ~log.("removeAt 2");  ~gui.showExpectation("Command: removeAt 2", 0);  ~mpb.removeAt(2);      ~refreshGuiFromMpb.() },
        { ~log.("add phaser");  ~gui.showExpectation("Command: add phaser", 0);  ~mpb.add(\phaser);     ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT");  ~gui.showExpectation("Command: clear NEXT", 0);  ~mpb.clearChain;       ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario3v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.6;
    steps = [
        { ~log.("init");                 ~gui.showExpectation("Command: init", 0);                 ~refreshGuiFromMpb.() },
        { ~log.("add bitcrusher");       ~gui.showExpectation("Command: add bitcrusher", 0);       ~mpb.add(\bitcrusher);  ~refreshGuiFromMpb.() },
        { ~log.("bypass bitcrusher false");~gui.showExpectation("Command: bypass bitcrusher false", 0); ~mpb.bypass(\bitcrusher, false); ~refreshGuiFromMpb.() },
        { ~log.("removeAt 1");          ~gui.showExpectation("Command: removeAt 1", 0);           ~mpb.removeAt(1);       ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT");           ~gui.showExpectation("Command: clear NEXT", 0);           ~mpb.clearChain;        ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};
)
// Test_MagicPedalboardRunner.scd
// v0.2.2
// MD 20250919

/*
Purpose:
- Instantiate MagicPedalboardTestRunner and run full bring-up and acceptance test.
- Ensures ~gui and ~mpb are created if nil.
*/

(
// Ensure GUI and pedalboard exist
~gui = ~gui ?? { MagicDisplayGUI.new };
~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };

// Instantiate and run the test
~runner = MagicPedalboardTestRunner.new(~mpb, ~gui);
~runner.bringUp;
~runner.audioReset;
~runner.syncGui;
~runner.runAcceptanceTest;
~runner.verifyAudioState;
~runner.help;
)
// testAfterFix.scd
// v0.1
// MD 20250916

// PRE-RUN REQUIRED:
// 1. Recompile class library after editing MagicPedalboardNew.sc
// 2. Run MagicPedalboardNew.scd (if you have a setup/init script)
// 3. Run MagicDisplayGUI.scd to launch GUI
// 4. Run adapter_commandtree_to_magicpedalboard.scd v0.3

(
// Test sequence: add → switch → bypass → switch
~adapter.applyQueue([
    ["commands/add", "delay"],
    ["commands/switch", "chainB"],
    ["commands/bypass", "delay", true],
    ["commands/bypass", "delay", false],
    ["commands/switch", "chainA"]
]);

// Confirm:
// - Audio is audible at each step
// - GUI columns match chain state
// - chainB is stopped unless switching
)
// tool_export_commandtree_with_payloads.scd
// v0.1
// MD 20250916-0956

(
~ct_nodeToDictWithPayload = { arg nodeRef;
    var childDicts, outDict;
    childDicts = Array.new;
    nodeRef.children.do({ arg childNode;
        childDicts = childDicts.add(~ct_nodeToDictWithPayload.(childNode));
    });
    outDict = (
        id: nodeRef.id,
        name: nodeRef.name,
        fret: nodeRef.fret,
        payload: nodeRef.payload,   // <— keep payload
        children: childDicts
    );
    outDict
};

~ct_writeJsonWithPayloads = {
    arg treeRef,
        outPath = "/Users/martindupras/CommandTreeSavefiles/myTree.json",
        writeVersioned = true,
        saveFolder = "/Users/martindupras/CommandTreeSavefiles",
        savePrefix = "myTree";

    var topDict, jsonString;

    // Top-level object: include root payload and nodeLimit if available
    topDict = (
        name: treeRef.root.name,
        id: treeRef.root.id,
        nodeLimit: treeRef.nodeLimit ? 200,
        payload: treeRef.root.payload,
        children: treeRef.root.children.collect({ arg child; ~ct_nodeToDictWithPayload.(child) })
    );

    jsonString = JSONlib.convertToJSON(topDict);

    if(writeVersioned) {
        var saver;
        saver = CircularFileSave.new(savePrefix, saveFolder, 10);
        saver.saveVersion(jsonString);  // versioned copy with payloads preserved
    };

    File.use(outPath.standardizePath, "w", { arg f; f.write(jsonString) });
    ("[CT] Wrote JSON with payloads -> " ++ outPath).postln;
};
)
// tool_xml_to_json_commandtree.scd
// v0.1
// MD 20250916-0850

(
~ct_convertXmlToJson = { arg inPath = "~/myTree.xml", outPath = "~/CommandTreeSavefiles/myTree.json";
    var xmlText, lines, stack, rootDict, currentDict, parseOpen, parseClose, parseAttrs, toJSON;

    inPath = inPath.standardizePath;
    outPath = outPath.standardizePath;

    xmlText = File.readAllString(inPath);
    if(xmlText.isNil or: { xmlText.isEmpty }) { "XML empty or unreadable.".warn; ^false };

    // Helpers
    parseAttrs = { arg tagLine;
        var dict, pairs;
        dict = IdentityDictionary.new;
        // crude attribute parse: key="value"
        pairs = tagLine.findAllRegexp("\"([^\"]*)\"");
        // We walk the string: extract id, name, fret, payload if present
        // Better: regex for key="value" tuples
        tagLine.findAllRegexp("(\\w+)\\s*=\\s*\"([^\"]*)\"").do({ arg m;
            var key = m[1].asString.asSymbol;
            var val = m[2].asString;
            dict[key] = val;
        });
        dict
    };

    parseOpen = { arg line;
        var attrs, dict, idNum, fretNum;
        attrs = parseAttrs.(line);
        dict = (
            id: (attrs[\id] ?? { "0" }).asInteger,
            name: (attrs[\name] ?? { "unnamed" }).asString,
            fret: (attrs[\fret] ?? { "0" }).asInteger,
            payload: (attrs[\payload] ?? { nil }),
            children: Array.new
        );
        dict
    };

    parseClose = { arg stackRef;
        if(stackRef.size > 1, {
            var child = stackRef.pop;
            stackRef.last[\children] = stackRef.last[\children].add(child);
        });
    };

    stack = Array.new;

    // Tokenize lines and handle <node .../> self-close and </node>
    lines = xmlText.replace($\t, $ ).replace($\r, $ ).split($\n);
    lines.do({ arg raw;
        var line = raw.trim;
        if(line.isEmpty) { ^nil };

        if(line.beginsWith("<node") and: { line.endsWith("/>") }) {
            var dict = parseOpen.(line);
            if(stack.isEmpty) { stack.push(dict) } { stack.last[\children] = stack.last[\children].add(dict) };
        }{
            if(line.beginsWith("</node")) {
                parseClose.(stack);
            }{
                if(line.beginsWith("<node")) {
                    stack.push(parseOpen.(line));
                };
            };
        };
    });

    // Close remaining nodes
    while({ stack.size > 1 }, { parseClose.(stack) });

    rootDict = if(stack.size == 1) { stack[0] } { nil };
    if(rootDict.isNil) { "Parse failed (no root)".warn; ^false };

    // Build top-level tree dict for MDCommandTree.fromDict
    currentDict = (
        name: rootDict[\name],
        id: rootDict[\id],
        nodeLimit: 200,
        payload: rootDict[\payload],
        children: rootDict[\children]
    );

    // Write JSON (uses JSONlib from your environment)
    File.use(outPath, "w", { arg f; f.write(JSONlib.convertToJSON(currentDict)) });
    ("[CT] Wrote JSON -> " ++ outPath).postln;
    true
};
)
(
// =========================
// Utils_MagicDisplayGUI_Checks.scd  (single block)
// =========================

~md_checkEnv = {
    var gui_present, queue_ok, setter_ok, atput_ok, win_count, win_titles;
    gui_present = ~gui.notNil;
    queue_ok = gui_present and: { ~gui.respondsTo(\queueUi) };
    setter_ok = gui_present and: { ~gui.respondsTo(\queueUi_) };
    atput_ok = gui_present and: { ~gui.respondsTo(\atPut) };
    win_count = (~md_get_gui_windows.notNil).if({ ~md_get_gui_windows.().size }, { 0 });
    win_titles = (win_count > 0).if({ ~md_get_gui_windows.().collect({ |w| w.name.asString }) }, { [] });
    "[ENV] mpb:% gui:% queueUi:% queueUi_:% atPut:% windows:% titles:%"
        .format(~mpb.notNil, gui_present, queue_ok, setter_ok, atput_ok, win_count, win_titles)
        .postln;
};

~md_appclock_ping = {
    AppClock.sched(0.0, { "[AC] ping ok @ % s".format(Main.elapsedTime.round(0.001)).postln; nil });
};

) // end block
// utils_mpb_force_reconnect.scd
// v0.2
// MD 20250916-1057

(
~mpb_forceReconnect = { arg pedalboard;
    var log, connectPair, reconnectList, effCur, effNext, sinkCur, sinkNext, indexCounter, lastIndex;

    log = { arg txt; ("[FIX] " ++ txt).postln };

    connectPair = { arg leftKey, rightKey;
        Server.default.bind({
            // Correct JITLib embed operator used in your project:
            Ndef(leftKey) <<> Ndef(rightKey);
        });
    };

    reconnectList = { arg listSymbols;
        indexCounter = 0;
        lastIndex = listSymbols.size - 1;
        while({ indexCounter < lastIndex }, {
            connectPair.(listSymbols[indexCounter], listSymbols[indexCounter + 1]);
            indexCounter = indexCounter + 1;
        });
    };

    effCur = pedalboard.effectiveCurrent;
    effNext = pedalboard.effectiveNext;

    reconnectList.(effCur);
    reconnectList.(effNext);

    sinkCur = effCur[0];
    sinkNext = effNext[0];

    Server.default.bind({
        if(Ndef(sinkCur).isPlaying.not) { Ndef(sinkCur).play(numChannels: 2) };
        if(Ndef(sinkNext).isPlaying)    { Ndef(sinkNext).stop };
    });

    log.("forceReconnect done. current=" ++ effCur ++ "  next=" ++ effNext);
};
)
// Verify_SetSourcesBoth_Today.scd
// v0.2
// MD 2025-09-18 13:46 BST

// Purpose
// - Verify that both chains have \testmelody as their source symbol, without assuming ~mpb exists.
// Style
// - var-first; lowercase; no server.sync; server ops via class methods only.

(
var warn, ensureSources;
warn = { arg s; var msg; msg = "[VERIFY] " ++ s; msg.warn };

if(~mpb.isNil) {
    warn.("~mpb is nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.");
    ^nil;
};

ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

ensureSources.();
~mpb.setSourceCurrent(\testmelody);
~mpb.setSource(\testmelody);
~mpb.printChains;
"[VERIFY] Both chains point to \\testmelody (CURRENT and NEXT)".postln;
)
// XEnforce_EndAndRecreateSilent_Now.scd
// v0.1
// MD 20250917-1305
//
// Purpose: Deterministically enforce Option A for both audio *and* flags.
//          - CURRENT robust \in.ar(2), playing
//          - NEXT: .end (drops monitor + flag), then recreate Silent.ar(2) + mold(2,\audio)
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, curSink, nextSink;
log = { arg s; ("[XEND] " ++ s).postln };

if(~mpb.isNil) { "[XEND] ~mpb is nil".warn; ^nil };

curSink  = ~mpb.currentChain[0];
nextSink = ~mpb.nextChain[0];

if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false) };

Server.default.bind({
    // CURRENT: robust + stereo + playing
    Ndef(curSink,  { \in.ar(2) }); Ndef(curSink).mold(2, \audio);
    if(Ndef(curSink).isPlaying.not) { Ndef(curSink).play(numChannels: 2) };

    // NEXT: end monitor -> recreate as silent stereo (no play)
    Ndef(nextSink).end;                              // flag reliably drops
    Ndef(nextSink, { Silent.ar(2) });                // silent source
    Ndef(nextSink).mold(2, \audio);                  // stereo pin
});

log.("enforced; checking in 250ms…");
AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[XEND] [PLAY] A=% B=%".format(a, b)).postln;
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(true) };
    nil
});
)
